var typedArrayToString = function () {
  return "";
};

var CM = {};

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
CM.Conf = {};

// Common paths
CM.Conf.tileLoaderUrl = "/src/layer/tile/TileLoader.js";
CM.Conf.protocol = "https:";//window.location.protocol;
CM.Conf.baseUrl = CM.Conf.protocol + window.location.host;//localhost:9021";
CM.Conf.distDirectory = "/dist/";

// Remote paths
CM.Conf.glyphPathForChar = "https://glyph.citymaps.io/glyph/search/";

CM.Conf.glyphPathByIndex = "https://res.citymaps.io/glyph/v1/256/{file}/{index}.glyph";
CM.Conf.labelPlacementPath = "https://glyph.citymaps.io/shape";
CM.Conf.vectorMapTileUrl = "https://{s}/map/v3/{z}/{x}/{y}";
CM.Conf.vectorMapTileSubdomains = ['a-tile.citymaps.com','b-tile.citymaps.com','c-tile.citymaps.com','d-tile.citymaps.com'];
CM.Conf.buildingTileUrl = "https://{s}/building/v3/{z}/{x}/{y}";
CM.Conf.venueMapTileUrl = "https://tile.citymaps.com/venue/v2/{z}/{x}/{z}_{x}_{y}.json.gz";
CM.Conf.elevation = {
    defaultTileURL: "https://{s}/elevation/v3/{z}/{x}/{y}.png",
    minZoom: 2,
    maxZoom: 7,
    minLandCoverZoom: 2,
    maxLandCoverZoom: 6
};

CM.Conf.apiKeyValidateUrl = "https://ca.citymaps.com/v2/apikey/validate/";
CM.Conf.logoUrl = "https://res.citymaps.io/images/business_logos/{id}_150x150?cb=081816";
CM.Conf.categoryUrl = "https://res.citymaps.io/images/category_icons6_app/{id}?cb=081816";
CM.Conf.signingKeysUrl = CM.Conf.baseUrl + "/assets/keys/";

// Flags / fields
CM.Conf.cloudfrontAccessKey = "APKAIPPUPIOAVQKJIX6A";
CM.Conf.remoteWorkers = false;
CM.Conf.loggingEnabled = true;

// Don't allow DPR higher than 2
//if (window.outerWidth && window.innerWidth) {
//    var zoomLevel = (window.outerWidth / window.innerWidth).toFixed(2);
//    var rawDPR = window.devicePixelRatio ? Math.round((window.devicePixelRatio / zoomLevel)) : 1;
//    CM.Conf.devicePixelRatio = Math.min(rawDPR, 2);
//} else {
    CM.Conf.devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2);
//}

module.exports = {
    Conf: CM.Conf
};

},{}],2:[function(require,module,exports){
var CM = require('./config');

// Common paths
CM.Conf.baseUrl = CM.Conf.protocol + "//dev-mapengineweb.citymaps.com";
CM.Conf.distDirectory = "/dist/";
CM.Conf.venueMapTileUrl = "//vstaging.citymaps.com/venue/v2/{z}/{x}/{z}_{x}_{y}.json.gz";

CM.Conf.remoteWorkers = true;
CM.Conf.loggingEnabled = false;

module.exports = {
    Conf: CM.Conf
};
},{"./config":1}],3:[function(require,module,exports){
var CM = require('./config_dev');

// Common paths
CM.Conf.baseUrl = CM.Conf.protocol + "//s3.amazonaws.com/citymaps-dev-resources/map/develop";
CM.Conf.distDirectory = "/";

module.exports = {
    Conf: CM.Conf
};
},{"./config_dev":2}]},{},[3]);

CM.Files = {};

CM.Files['effects.xml'] = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<EffectConfig>\n    <Effect name="polygon_color" >\n        <Technique name="fill" >\n            <Pass program="polygon_color" />\n        </Technique>\n        <Technique name="elevation" >\n            <Pass program="polygon_color_elevation" />\n        </Technique>\n    </Effect>\n    <Effect name="polygon_texture" >\n        <Technique name="fill" >\n            <Pass program="polygon_texture" />\n        </Technique>\n    </Effect>\n    <Effect name="line_solid">\n        <Technique name="fill">\n            <Pass program="line_solid" />\n        </Technique>\n    </Effect>\n    <Effect name="line_pattern">\n        <Technique name="fill">\n            <Pass program="line_pattern" />\n        </Technique>\n    </Effect>\n    <Effect name="line_solid_joint">\n        <Technique name="fill">\n            <Pass program="line_solid_joint" />\n        </Technique>\n    </Effect>\n    <Effect name="line" >\n        <Technique name="simple" >\n            <Pass program="vector_pass" />\n        </Technique>\n        <Technique name="line_solid" >\n            <Pass program="vector_df" />\n        </Technique>\n    </Effect>\n    <Effect name="vector_texture" >\n        <Technique name="vector_texture" >\n            <Pass program="vector_texture" />\n        </Technique>\n    </Effect>\n    <Effect name="sprite" >\n        <Technique name="simple" >\n            <Pass program="sprite" />\n        </Technique>\n        <Technique name="masked">\n            <Pass program="sprite_mask" />\n        </Technique>\n        <Technique name="filter" >\n            <Pass program="sprite_filter" />\n        </Technique>\n    </Effect>\n    <Effect name="sprite_business" >\n        <Technique name="simple" >\n            <Pass program="sprite_business" />\n        </Technique>\n        <Technique name="lanczos" >\n            <Pass program="sprite_business_lanczos" />\n        </Technique>\n    </Effect>\n    <Effect name="sprite_batch" >\n        <Technique name="simple" >\n            <Pass program="sprite_batch" />\n        </Technique>\n        <Technique name="src_alpha" >\n            <Pass program="sprite_batch_src_alpha" />\n        </Technique>\n    </Effect>\n    <Effect name="business" >\n        <Technique name="business" >\n            <Pass program="business" />\n        </Technique>\n        <Technique name="mini" >\n            <Pass program="business_mini" />\n        </Technique>\n    </Effect>\n    <Effect name="label" >\n        <Technique name="label" >\n            <Pass program="label" />\n        </Technique>\n        <Technique name="simple" >\n            <Pass program="label_simple" />\n        </Technique>\n        <Technique name="map" >\n            <Pass program="label_map" />\n        </Technique>\n    </Effect>\n    <Effect name="debug" >\n        <Technique name="debug" >\n            <Pass program="debug" />\n        </Technique>\n    </Effect>\n</EffectConfig>\n        ';

CM.Files['shaders.xml'] = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<ShaderConfig>\n    <Shaders>\n        <Shader name="polygon_color_vertex" filename="polygon_color_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_baseResolution"/>\n            <GlobalData name="u_tileSize" />\n            <GlobalData name="u_landLayerId" />\n        </Shader>\n        <Shader name="polygon_color_fragment" filename="polygon_color_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="polygon_texture_vertex" filename="polygon_texture_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_texDimensions" />\n            <GlobalData name="u_baseResolution"/>\n            <GlobalData name="u_tileSize" />\n        </Shader>\n        <Shader name="polygon_texture_fragment" filename="polygon_texture_frag.glsl" type="pixel" >\n            <GlobalData name="u_texture" />\n        </Shader>\n        <Shader name="polygon_color_elevation_fragment" filename="polygon_color_elevation_frag.glsl" type="pixel" >\n            <GlobalData name="u_elevationTexture" />\n            <GlobalData name="u_zenithAngle" />\n            <GlobalData name="u_azimuthAngle" />\n            <GlobalData name="u_zFactor" />\n            <GlobalData name="u_hillshadeFactor" />\n            <GlobalData name="u_colorFactor" />\n            <GlobalData name="u_pixelSize" />\n            <GlobalData name="u_landFactor" />\n        </Shader>\n        <Shader name="vector_pass_vertex" filename="vector_pass_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_colors" />\n            <GlobalData name="u_widths" />\n        </Shader>\n        <Shader name="vector_pass_fragment" filename="vector_pass_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="line_solid_vertex" filename="line_solid_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_resolution" />\n            <GlobalData name="u_baseResolution" />\n            <GlobalData name="u_aaPadding" />\n        </Shader>\n        <Shader name="line_solid_fragment" filename="line_solid_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="line_solid_joint_vertex" filename="line_solid_joint_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_resolution" />\n        </Shader>\n        <Shader name="line_solid_joint_fragment" filename="line_solid_joint_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="line_pattern_vertex" filename="line_pattern_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_resolution" />\n            <GlobalData name="u_baseResolution" />\n            <GlobalData name="u_aaPadding" />\n        </Shader>\n        <Shader name="line_pattern_fragment" filename="line_pattern_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="vector_df_vertex" filename="vector_df_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_resolution" />\n            <GlobalData name="u_baseResolution" />\n            <GlobalData name="u_aaPadding" />\n        </Shader>\n        <Shader name="vector_df_fragment" filename="vector_df_frag.glsl" type="pixel" >\n        </Shader>\n        <Shader name="sprite_vertex" filename="sprite_vert.glsl" type="vertex" >\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_textureDimensions" />\n            <GlobalData name="u_dimensions" />\n            <GlobalData name="u_anchorPoint" />\n            <GlobalData name="u_rotation" />\n        </Shader>\n        <Shader name="sprite_fragment" filename="sprite_frag.glsl" type="pixel" >\n            <GlobalData name="u_texture" />\n            <GlobalData name="u_alpha" />\n            <GlobalData name="u_blendColor" />\n        </Shader>\n        <Shader name="sprite_mask_fragment" filename="sprite_mask_frag.glsl" type="pixel" >\n            <GlobalData name="u_texture" />\n            <GlobalData name="u_alphaMaskTexture" />\n            <GlobalData name="u_alpha" />\n            <GlobalData name="u_blendColor" />\n        </Shader>\n        <Shader name="sprite_filter_fragment" filename="sprite_lanczos_frag.glsl" type="pixel">\n            <GlobalData name="u_texture" />\n            <GlobalData name="u_alpha" />\n            <GlobalData name="u_blendColor" />\n            <GlobalData name="u_inSize" />\n            <GlobalData name="u_outSize" />\n        </Shader>\n        <Shader name="sprite_business_fragment" filename="sprite_business_frag.glsl" type="pixel" >\n            <GlobalData name="u_texture" />\n            <GlobalData name="u_cornerRadius" />\n        </Shader>\n        <Shader name="sprite_business_lanczos_fragment" filename="sprite_business_lanczos_frag.glsl" type="pixel" >\n            <GlobalData name="u_texture" />\n            <GlobalData name="u_cornerRadius" />\n            <GlobalData name="u_inSize" />\n            <GlobalData name="u_outSize" />\n        </Shader>\n        <Shader name="sprite_batch_vertex" filename="sprite_batch_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n        </Shader>\n        <Shader name="sprite_batch_fragment" filename="sprite_batch_frag.glsl" type="pixel">\n            <GlobalData name="u_texture[0]" />\n        </Shader>\n        <Shader name="sprite_batch_src_alpha_fragment" filename="sprite_batch_frag_src_alpha.glsl" type="pixel">\n            <GlobalData name="u_texture[0]" />\n        </Shader>\n        <Shader name="business_vertex" filename="business_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n        </Shader>\n        <Shader name="business_fragment" filename="business_frag.glsl" type="pixel">\n            <GlobalData name="u_texture[0]" />\n        </Shader>\n        <Shader name="business_mini_vertex" filename="business_mini_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n        </Shader>\n        <Shader name="business_mini_fragment" filename="business_mini_frag.glsl" type="pixel">\n            <GlobalData name="u_texture" />\n        </Shader>\n        <Shader name="label_vertex" filename="label_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_outlinePass" />\n        </Shader>\n        <Shader name="label_vertex_simple" filename="label_simple_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_outlinePass" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_color" />\n            <GlobalData name="u_outlineColor" />\n            <GlobalData name="u_textSize" />\n            <GlobalData name="u_outlineWidth" />\n        </Shader>\n        <Shader name="label_vertex_map" filename="label_map_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n            <GlobalData name="u_outlinePass" />\n            <GlobalData name="u_origin" />\n            <GlobalData name="u_mapBounds" />\n            <GlobalData name="u_mapSize" />\n        </Shader>\n        <Shader name="label_fragment" filename="df_text_frag.glsl" type="pixel">\n            <GlobalData name="u_texture[0]" />\n            <GlobalData name="u_baseTextSize" />\n            <GlobalData name="u_atlasSize" />\n        </Shader>\n        <Shader name="vector_texture_vert" filename="vector_texture_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n        </Shader>\n        <Shader name="vector_texture_frag" filename="vector_texture_frag.glsl" type="pixel">\n            <GlobalData name="u_texture" />\n        </Shader>\n        <Shader name="debug_vert" filename="debug_vert.glsl" type="vertex">\n            <GlobalData name="u_mvp" />\n        </Shader>\n        <Shader name="debug_frag" filename="debug_frag.glsl" type="pixel">\n            <GlobalData name="u_color" />\n        </Shader>\n    </Shaders>\n    <ShaderPrograms>\n        <ShaderProgram name="polygon_color">\n            <Shaders>\n                <Shader name="polygon_color_vertex" />\n                <Shader name="polygon_color_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_layerId" size="1" offset="12" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="polygon_texture">\n            <Shaders>\n                <Shader name="polygon_texture_vertex" />\n                <Shader name="polygon_texture_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_textureId" size="1" offset="12" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="polygon_color_elevation">\n            <Shaders>\n                <Shader name="polygon_color_vertex" />\n                <Shader name="polygon_color_elevation_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_layerId" size="1" offset="12" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="vector_pass">\n            <Shaders>\n                <Shader name="vector_pass_vertex" />\n                <Shader name="vector_pass_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_posAnsPerp" size="4" offset="0" />\n                <InputElement name="a_layerAndU" size="2" offset="16" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="line_solid">\n            <Shaders>\n                <Shader name="line_solid_vertex" />\n                <Shader name="line_solid_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_perpSignSize" size="4" offset="12" type="int16" normalized="true"/>\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="line_solid_joint">\n            <Shaders>\n                <Shader name="line_solid_joint_vertex" />\n                <Shader name="line_solid_joint_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_texCoord" size="2" offset="12" normalized="true" type="uint8"/>\n                <InputElement name="a_size" size="1" offset="14" type="int16"/>\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="line_pattern">\n            <Shaders>\n                <Shader name="line_pattern_vertex" />\n                <Shader name="line_pattern_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_color" size="4" offset="8" normalized="true" type="uint8"/>\n                <InputElement name="a_perpSignSize" size="4" offset="12" type="int16" normalized="true"/>\n                <InputElement name="a_linePattern" size="4" offset="20" type="uint8" />\n                <InputElement name="a_length" size="1" offset="24" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="vector_df">\n            <Shaders>\n                <Shader name="vector_df_vertex" />\n                <Shader name="vector_df_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_perp_distSign" size="3" offset="8"/>\n                <InputElement name="a_size" size="1" offset="20"/>\n                <InputElement name="a_color" size="4" offset="24" normalized="true" type="uint8"/>\n                <InputElement name="a_length" size="1" offset="28" />\n                <InputElement name="a_linePattern" size="4" offset="32" type="uint8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite">\n            <Shaders>\n                <Shader name="sprite_vertex" />\n                <Shader name="sprite_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_coords" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_mask">\n            <Shaders>\n                <Shader name="sprite_vertex" />\n                <Shader name="sprite_mask_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_coords" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_filter">\n            <Shaders>\n                <Shader name="sprite_vertex" />\n                <Shader name="sprite_filter_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_coords" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_business">\n            <Shaders>\n                <Shader name="sprite_vertex" />\n                <Shader name="sprite_business_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_coords" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_business_lanczos">\n            <Shaders>\n                <Shader name="sprite_vertex" />\n                <Shader name="sprite_business_lanczos_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_coords" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_batch">\n            <Shaders>\n                <Shader name="sprite_batch_vertex" />\n                <Shader name="sprite_batch_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_blendColor" size="4" offset="8" type="uint8" normalized="true" />\n                <InputElement name="a_alpha" size="1" offset="12" type="uint8" normalized="true" />\n                <InputElement name="a_textureId" size="1" offset="13" type="uint8" />\n                <InputElement name="a_padding" size="2" offset="14" type="int8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="sprite_batch_src_alpha">\n            <Shaders>\n                <Shader name="sprite_batch_vertex" />\n                <Shader name="sprite_batch_src_alpha_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_blendColor" size="4" offset="8" type="uint8" normalized="true" />\n                <InputElement name="a_alpha" size="1" offset="12" type="uint8" normalized="true" />\n                <InputElement name="a_textureId" size="1" offset="13" type="uint8" />\n                <InputElement name="a_padding" size="2" offset="14" type="int8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="business">\n            <Shaders>\n                <Shader name="business_vertex" />\n                <Shader name="business_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_maskTexCoord" size="2" offset="8" type="uint16" normalized="true" />\n                <InputElement name="a_blendColor" size="4" offset="12" type="uint8" normalized="true" />\n                <InputElement name="a_alpha" size="1" offset="16" type="uint8" normalized="true" />\n                <InputElement name="a_textureId" size="1" offset="17" type="uint8" />\n                <InputElement name="a_padding" size="2" offset="18" type="int8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="business_mini">\n            <Shaders>\n                <Shader name="business_mini_vertex" />\n                <Shader name="business_mini_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_alpha" size="1" offset="8" type="uint8" normalized="true" />\n                <InputElement name="a_padding" size="3" offset="9" type="int8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="business_filter">\n            <Shaders>\n                <Shader name="business_vertex" />\n                <Shader name="business_filter_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_blendColor" size="4" offset="8" type="uint8" normalized="true" />\n                <InputElement name="a_alpha" size="1" offset="12" type="uint8" normalized="true" />\n                <InputElement name="a_textureId" size="1" offset="13" type="uint8" />\n                <InputElement name="a_padding" size="2" offset="14" type="int8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="label">\n            <Shaders>\n                <Shader name="label_vertex" />\n                <Shader name="label_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="uint16" normalized="true" />\n                <InputElement name="a_color" size="4" offset="8" type="uint8" normalized="true" />\n                <InputElement name="a_outlineColor" size="4" offset="12" type="uint8" normalized="true" />\n                <InputElement name="a_textSize" size="1" offset="16" type="uint8" />\n                <InputElement name="a_outlineWidth" size="1" offset="17" type="uint8" />\n                <InputElement name="a_alpha" size="1" offset="18" type="uint8" normalized="true" />\n                <InputElement name="a_textureId" size="1" offset="19" type="uint8" />\n                <InputElement name="a_actualSize" size="2" offset="20" type="uint8" />\n                <InputElement name="a_angle" size="1" offset="22" type="int16" />\n                <InputElement name="a_anchor" size="2" offset="24" type="int16" />\n                <InputElement name="a_glyphCenter" size="2" offset="28" type="int16" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="label_simple">\n            <Shaders>\n                <Shader name="label_vertex_simple" />\n                <Shader name="label_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="4" type="int16" normalized="true" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="label_map">\n            <Shaders>\n                <Shader name="label_vertex_map" />\n                <Shader name="label_fragment" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_offset" size="2" offset="8" type="int16" />\n                <InputElement name="a_texCoord" size="2" offset="12" type="uint16" normalized="true" />\n                <InputElement name="a_color" size="4" offset="16" type="uint8" normalized="true" />\n                <InputElement name="a_outlineColor" size="4" offset="20" type="uint8" normalized="true" />\n                <InputElement name="a_textSize" size="1" offset="24" type="uint8" />\n                <InputElement name="a_outlineWidth" size="1" offset="25" type="uint8" />\n                <InputElement name="a_padding" size="1" offset="26" type="uint16" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="vector_texture">\n            <Shaders>\n                <Shader name="vector_texture_vert" />\n                <Shader name="vector_texture_frag" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n                <InputElement name="a_texCoord" size="2" offset="8" />\n            </InputLayout>\n        </ShaderProgram>\n        <ShaderProgram name="debug">\n            <Shaders>\n                <Shader name="debug_vert" />\n                <Shader name="debug_frag" />\n            </Shaders>\n            <InputLayout>\n                <InputElement name="a_position" size="2" offset="0" />\n            </InputLayout>\n        </ShaderProgram>\n    </ShaderPrograms>\n</ShaderConfig>';

CM.Files['strings.json'] = {
    "building_pin_display": {
        "_": {
            "value": "and {0} others",
            "plural": {
                "one": "and {0} other",
                "many": "and {0} others"
            }
        }
    }
};

CM.Files['style.json'] = {"profile":{"background-color":[240,237,229,1],"background-image":null,"background-image-opacity":null,"base":"/","default_style":{"line-color":[0,0,0,0],"line-width":0,"line-opacity":1,"line-join":"miter","line-cap":"butt","line-gamma":1,"line-dasharray":[],"polygon-fill":[0,0,0,0],"polygon-opacity":1,"polygon-pattern-file":null,"text-face-name":null,"text-weight":400,"text-style":"regular","text-size":0,"text-wrap-width":0,"text-wrap-character":" ","text-spacing":200,"text-character-spacing":0,"text-line-spacing":0,"text-max-char-angle-delta":22.5,"text-fill":[0,0,0,0],"text-opacity":1,"text-halo-fill":[0,0,0,0],"text-halo-opacity":1,"text-halo-radius":0,"text-dx":0,"text-dy":0,"text-vertical-alignment":"middle","text-align":"left","text-margin":0,"text-min-path-length":0,"text-orientation":0,"text-transform":"none","hillshade-azimuth-angle":0,"hillshade-altitude":0,"hillshade-z-factor":0,"hillshade-factor":0,"hillshade-color-factor":0},"remote_files":[],"layers":[{"id":92,"name":"ocean","min_zoom":0,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":50,"type":"polygon","delta":0,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[163,204,255,1]},"filters":[],"styles":[]}]}]}]},{"id":52,"name":"land","min_zoom":0,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"polygon","delta":1,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[240,237,229,1]},"filters":[],"styles":[{"rules":{"polygon-fill":[228,234,222,1]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"<="}]}],"styles":[]},{"rules":{"polygon-fill":[243,241,238,1]},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[243,241,237,1]},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[243,241,237,1]},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[233,229,220,1]},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[233,230,223,1]},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[233,231,227,1]},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[233,232,230,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[234,234,234,1]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":">="}]}],"styles":[]}]}]}]}]},{"id":79,"name":"landuse","min_zoom":10,"max_zoom":21,"label_min_zoom":11,"badge_min_zoom":11,"priority":15,"type":"polygon","delta":2,"groups":[{"instances":[{"styles":[{"rules":{},"filters":[{"conditions":[{"key":"landuse","value":"residential","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-fill":[138,138,138,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-align":"center","text-style":"italic","text-line-spacing":3,"text-wrap-width":150,"text-character-spacing":0,"text-repeat-distance":1500},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="},{"key":"zoom","value":16,"op":"<="}]}],"styles":[{"rules":{"text-size":11,"text-margin":10},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":10},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]}]}]},{"rules":{},"filters":[],"styles":[{"rules":{"polygon-fill":[222,220,217,1]},"filters":[{"conditions":[{"key":"aeroway","value":"apron","op":"=="}]},{"conditions":[{"key":"aeroway","value":"gate","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[236,235,233,1]},"filters":[{"conditions":[{"key":"aeroway","value":"aerodrome","op":"=="}]}],"styles":[{"rules":{"text-dy":-7,"text-vertical-alignment":"bottom","text-optional":"true","icon-optional":"false","icon-image":"icon_airport","icon-size":[14,14],"icon-opacity":1,"icon-color":[255,255,255,1],"icon-offset":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":11,"op":">="},{"key":"zoom","value":13,"op":"<="}]}],"styles":[]},{"rules":{"text-face-name":"SanFrancisco","text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-wrap-width":250,"text-line-spacing":3,"text-margin":0,"text-align":"center","text-repeat-distance":1000},"filters":[{"conditions":[{"key":"zoom","value":11,"op":">="}]}],"styles":[]},{"rules":{"text-size":13,"text-fill":[102,102,102,1],"text-character-spacing":0,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-fill":[102,102,102,1],"text-character-spacing":0,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-fill":[134,136,138,1],"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]}]},{"id":91,"name":"buildings","min_zoom":15,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":4,"type":"line","delta":3,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[240,240,240,1],"line-color":[234,234,234,1]},"filters":[],"styles":[{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":7},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[248,233,242,1]},"filters":[{"conditions":[{"key":"amenity","value":"hospital","op":"=="}]}],"styles":[]}]}]}]}]},{"id":93,"name":"schools","min_zoom":13,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":1,"type":"polygon","delta":4,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[228,228,223,1]},"filters":[],"styles":[]}]}]}]},{"id":94,"name":"parks","min_zoom":0,"max_zoom":21,"label_min_zoom":13,"badge_min_zoom":0,"priority":1,"type":"polygon","delta":5,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[203,230,163,1],"label-priority":0},"filters":[],"styles":[{"rules":{},"filters":[{"conditions":[{"key":"leisure","value":"park","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-size":13,"text-style":"italic","text-fill":[107,126,73,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-wrap-width":250,"text-line-spacing":4,"text-margin":5,"text-align":"center","text-repeat-distance":1000,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":13,"op":">="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]},{"rules":{"polygon-fill":[194,226,147,0.44999999999999996],"line-color":[194,226,147,0.44999999999999996],"line-width":5},"filters":[{"conditions":[{"key":"boundary","value":"national_park","op":"=="}]}],"styles":[]},{"rules":{"line-color":[194,226,147,0.44999999999999996],"line-width":5},"filters":[{"conditions":[{"key":"leisure","value":"nature_reserve","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[214,233,185,1]},"filters":[{"conditions":[{"key":"amenity","value":"grave_yard","op":"=="},{"key":"zoom","value":9,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[214,233,185,1]},"filters":[{"conditions":[{"key":"landuse","value":"cemetery","op":"=="},{"key":"zoom","value":9,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[196,227,151,1]},"filters":[{"conditions":[{"key":"leisure","value":"track","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[224,225,230,1]},"filters":[{"conditions":[{"key":"leisure","value":"sports_centre","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[196,227,151,1]},"filters":[{"conditions":[{"key":"leisure","value":"golf_course","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[224,225,230,1]},"filters":[{"conditions":[{"key":"leisure","value":"stadium","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[196,227,151,1]},"filters":[{"conditions":[{"key":"leisure","value":"pitch","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[210,233,175,1]},"filters":[{"conditions":[{"key":"landuse","value":"grass","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[210,233,175,1]},"filters":[{"conditions":[{"key":"leisure","value":"garden","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"line-color":[207,224,189,1],"line-width":3},"filters":[{"conditions":[{"key":"leisure","value":"playground","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[240,237,229,1],"line-color":[163,204,255,1],"line-width":10},"filters":[{"conditions":[{"key":"leisure","value":"marina","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[228,228,228,1]},"filters":[{"conditions":[{"key":"leisure","value":"ice_rink","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[163,204,255,1]},"filters":[{"conditions":[{"key":"leisure","value":"swimming_pool","op":"=="},{"key":"zoom","value":16,"op":">="}]}],"styles":[]}]}]}]}]},{"id":55,"name":"natural","min_zoom":6,"max_zoom":21,"label_min_zoom":7,"badge_min_zoom":7,"priority":1,"type":"polygon","delta":6,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[203,230,163,1]},"filters":[],"styles":[{"rules":{"polygon-fill":[208,237,232,0.5]},"filters":[{"conditions":[{"key":"natural","value":"wetland","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[194,226,147,1]},"filters":[{"conditions":[{"key":"landuse","value":"forest","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[194,226,147,1]},"filters":[{"conditions":[{"key":"natural","value":"wood","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[194,226,147,1]},"filters":[{"conditions":[{"key":"natural","value":"scrub","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[242,232,195,1]},"filters":[{"conditions":[{"key":"natural","value":"desert","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[242,232,195,1]},"filters":[{"conditions":[{"key":"natural","value":"beach","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[242,232,195,1]},"filters":[{"conditions":[{"key":"natural","value":"sand","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[242,232,195,1]},"filters":[{"conditions":[{"key":"natural","value":"heath","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[232,245,250,1],"text-face-name":"SanFrancisco","text-style":"italic","text-size":13,"text-fill":[99,182,235,1],"text-wrap-width":250,"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-line-spacing":6,"text-repeat-distance":800,"text-margin":5,"text-align":"center"},"filters":[{"conditions":[{"key":"natural","value":"glacier","op":"=="}]}],"styles":[]}]}]}]}]},{"id":80,"name":"runways","min_zoom":11,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"line","delta":7,"groups":[{"instances":[{"styles":[{"rules":{"line-color":[222,220,217,1]},"filters":[],"styles":[{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":10},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":12},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":14},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":16},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":18},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]},{"rules":{},"filters":[{"conditions":[{"key":"width","value":0,"op":">="}]}],"styles":[{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":12},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":18},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":30},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":35},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":55},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":75},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":90},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]}]},{"id":60,"name":"railways","min_zoom":11,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"line","delta":8,"groups":[{"instances":[{"styles":[{"rules":{},"filters":[{"conditions":[{"key":"railway","value":"rail","op":"=="}]}],"styles":[{"rules":{"line-color":[221,221,221,1],"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":">="}]}],"styles":[]}]},{"rules":{},"filters":[{"conditions":[{"key":"aerialway","value":"chair_lift","op":"=="}]},{"conditions":[{"key":"aerialway","value":"gondola","op":"=="}]}],"styles":[{"rules":{"line-color":[174,164,164,1],"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":">="}]}],"styles":[]}]}]},{"styles":[{"rules":{"line-color":[221,221,221,1]},"filters":[{"conditions":[{"key":"railway","value":"rail","op":"=="}]}],"styles":[{"rules":{"line-dasharray":[1,2],"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,3],"line-width":7},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,4],"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,7],"line-width":10},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]},{"rules":{"line-color":[174,164,164,1]},"filters":[{"conditions":[{"key":"aerialway","value":"chair_lift","op":"=="}]},{"conditions":[{"key":"aerialway","value":"gondola","op":"=="}]}],"styles":[{"rules":{"line-dasharray":[1,2],"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,3],"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,5],"line-width":7},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,7],"line-width":8},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,10],"line-width":11},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,14],"line-width":13},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-dasharray":[1,18],"line-width":15},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":86,"name":"country_labels","min_zoom":0,"max_zoom":13,"label_min_zoom":0,"badge_min_zoom":0,"priority":50,"type":"point","delta":9,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-fill":[38,38,38,1],"text-halo-fill":[255,255,255,0.95],"text-halo-radius":1,"text-margin":3,"text-repeat-distance":1000,"text-align":"center","text-vertical-alignment":"middle"},"filters":[],"styles":[{"rules":{},"filters":[{"conditions":[{"key":"zoom","value":2,"op":"<="}]}],"styles":[{"rules":{"text-size":9,"text-weight":700,"text-wrap-width":200,"text-line-spacing":3,"text-character-spacing":0},"filters":[{"conditions":[{"key":"country_code_fips","value":"US","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"IN","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"RS","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CH","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"BR","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"AS","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"AR","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"KZ","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"AG","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SF","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"UK","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"MX","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"ID","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"FR","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"GL","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"BL","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"PA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"PE","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CO","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"NG","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SG","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SU","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CF","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"YM","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"MY","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"RP","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CE","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"LA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"PP","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"NZ","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"MA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"JA","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"MG","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"BO","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"IC","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"GM","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"IT","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"UP","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SP","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"IZ","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"TU","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"PK","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"IR","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"TS","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"UZ","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"NO","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SV","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"CU","op":"=="}]},{"conditions":[{"key":"country_code_fips","value":"SW","op":"=="}]}],"styles":[]}]},{"rules":{"text-size":11,"text-weight":700,"text-wrap-width":200,"text-line-spacing":3,"text-character-spacing":0},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":700,"text-wrap-width":200,"text-line-spacing":3,"text-character-spacing":0},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-weight":700,"text-wrap-width":300,"text-line-spacing":3,"text-character-spacing":0},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":21,"text-weight":700,"text-wrap-width":350,"text-line-spacing":4,"text-character-spacing":2},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":24,"text-weight":700,"text-wrap-width":400,"text-line-spacing":4,"text-character-spacing":2},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":8,"op":">="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":600,"text-wrap-width":400,"text-line-spacing":4,"text-character-spacing":4},"filters":[{"conditions":[{"key":"name","value":"Vatican City","op":"=="}]}],"styles":[]}]}]}]}]},{"id":85,"name":"state_labels","min_zoom":4,"max_zoom":7,"label_min_zoom":0,"badge_min_zoom":0,"priority":40,"type":"point","delta":10,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-fill":[115,111,103,1],"text-line-spacing":5,"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-wrap-width":200,"text-margin":5,"text-align":"center","text-transform":"uppercase"},"filters":[],"styles":[{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10,"text-weight":700,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-fill":[115,111,103,1],"text-size":11,"text-weight":700,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":500,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-fill":[155,145,120,1],"text-wrap-width":400,"text-size":18,"text-weight":500,"text-character-spacing":3},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":8,"op":">="}]}],"styles":[]}]}]}]}]},{"id":104,"name":"cities","min_zoom":3,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":20,"type":"point","delta":11,"groups":[{"instances":[{"styles":[{"rules":{},"filters":[{"conditions":[{"key":"place","value":"neighbourhood","op":"!="},{"key":"place","value":"suburb","op":"!="},{"key":"place","value":"island","op":"!="},{"key":"place","value":"islet","op":"!="},{"key":"place","value":"village","op":"!="}]}],"styles":[{"rules":{"text-dy":-4,"text-vertical-alignment":"bottom","text-optional":"false","icon-optional":"false","icon-size":[6,6],"icon-image":"icon_point","icon-opacity":1,"icon-color":[255,255,255,1],"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"<="}]}],"styles":[]},{"rules":{"text-face-name":"SanFrancisco","text-size":13,"text-character-spacing":0,"text-fill":[74,74,74,1],"text-weight":500,"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":10,"text-align":"center"},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"<="}]}],"styles":[]},{"rules":{"text-margin":8,"text-weight":500,"text-halo-radius":1},"filters":[{"conditions":[{"key":"population","value":0,"op":">="},{"key":"population","value":249999,"op":"<="}]},{"conditions":[{"key":"place","value":"town","op":"=="}]}],"styles":[{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":600,"text-fill":[85,71,37,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":600,"text-character-spacing":1,"text-fill":[100,83,43,1]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-weight":600,"text-character-spacing":2,"text-fill":[192,170,162,1],"text-halo-fill":[255,255,255,0.73]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":">="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]},{"rules":{"text-margin":8,"text-weight":500},"filters":[{"conditions":[{"key":"population","value":250000,"op":">="},{"key":"population","value":499999,"op":"<="}]}],"styles":[{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":600},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":17,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":19,"text-weight":600,"text-character-spacing":1,"text-fill":[100,83,43,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":20,"text-weight":600,"text-character-spacing":2,"text-fill":[192,170,162,1],"text-halo-fill":[255,255,255,0.73]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":14,"op":">="}]}],"styles":[]}]},{"rules":{"text-margin":8,"text-weight":500},"filters":[{"conditions":[{"key":"population","value":500000,"op":">="},{"key":"population","value":999999,"op":"<="}]}],"styles":[{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":17,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":18,"text-weight":700,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":20,"text-weight":700,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":">="}]}],"styles":[]}]},{"rules":{"text-margin":8,"text-weight":700},"filters":[{"conditions":[{"key":"population","value":1000000,"op":">="},{"key":"population","value":7999999,"op":"<="}]}],"styles":[{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":900},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":900},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":17,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":18,"text-character-spacing":1,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":20,"text-character-spacing":2,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":21,"text-weight":600,"text-character-spacing":3,"text-fill":[192,170,162,1],"text-halo-fill":[255,255,255,0.73]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]},{"rules":{"text-margin":8,"text-weight":700},"filters":[{"conditions":[{"key":"population","value":8000000,"op":">="}]}],"styles":[{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":17,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":18,"text-weight":700},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":19,"text-weight":600,"text-character-spacing":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":20,"text-weight":600,"text-character-spacing":2},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":22,"text-weight":600,"text-character-spacing":3,"text-fill":[192,170,162,1],"text-halo-fill":[255,255,255,0.73]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]}]},{"rules":{},"filters":[{"conditions":[{"key":"place","value":"island","op":"=="}]},{"conditions":[{"key":"place","value":"islet","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-fill":[116,108,89,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-align":"center","text-style":"italic","text-wrap-width":200,"text-character-spacing":0,"text-repeat-distance":1500},"filters":[{"conditions":[{"key":"zoom","value":8,"op":">="}]}],"styles":[{"rules":{"text-size":11,"text-margin":50},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-margin":80},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-margin":120},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-margin":150},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-margin":190},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"text-margin":240},"filters":[{"conditions":[{"key":"zoom","value":13,"op":">="}]}],"styles":[]}]},{"rules":{},"filters":[{"conditions":[{"key":"place","value":"islet","op":"=="}]}],"styles":[{"rules":{"text-size":14,"text-margin":100},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-margin":100},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-margin":100},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":16,"op":">="}]}],"styles":[]}]}]},{"rules":{},"filters":[{"conditions":[{"key":"place","value":"village","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":600,"text-margin":5,"text-wrap-width":200,"text-line-spacing":5,"text-fill":[150,122,89,1],"text-character-spacing":1,"text-halo-fill":[242,242,242,1],"text-halo-radius":1,"text-align":"center"},"filters":[{"conditions":[{"key":"zoom","value":9,"op":">="}]}],"styles":[{"rules":{"text-size":10,"text-margin":10,"text-fill":[106,88,58,1]},"filters":[{"conditions":[{"key":"population","value":1500,"op":">"},{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10,"text-margin":10,"text-fill":[106,88,58,1]},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":10,"text-fill":[106,88,58,1]},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":10,"text-fill":[110,91,61,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":5,"text-fill":[121,99,69,1]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-margin":5,"text-fill":[150,122,89,1]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]}]},{"rules":{},"filters":[{"conditions":[{"key":"place","value":"suburb","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":600,"text-character-spacing":4,"text-line-spacing":5,"text-transform":"uppercase","text-fill":[144,128,92,1],"text-halo-fill":[255,255,255,0.65],"text-halo-radius":2,"text-margin":20,"text-align":"center"},"filters":[{"conditions":[{"key":"zoom","value":11,"op":">="}]}],"styles":[{"rules":{"text-size":10,"text-character-spacing":0,"text-margin":8,"text-halo-radius":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-character-spacing":1,"text-margin":10,"text-halo-radius":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-character-spacing":0,"text-margin":40,"text-halo-radius":2},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-character-spacing":1,"text-margin":25,"text-halo-radius":2},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-character-spacing":1,"text-margin":10,"text-halo-radius":2},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":16,"op":">="}]}],"styles":[]}]}]},{"rules":{},"filters":[{"conditions":[{"key":"place","value":"neighbourhood","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":600,"text-character-spacing":1,"text-line-spacing":5,"text-wrap-width":200,"text-transform":"uppercase","text-fill":[153,127,96,1],"text-halo-fill":[255,255,255,0.45],"text-halo-radius":1,"text-margin":40,"text-align":"center"},"filters":[{"conditions":[{"key":"zoom","value":11,"op":">="}]}],"styles":[{"rules":{"text-size":9,"text-weight":700,"text-wrap-width":200,"text-margin":30},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":9,"text-weight":700,"text-wrap-width":200,"text-margin":25},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10,"text-weight":700,"text-wrap-width":200,"text-margin":20},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-weight":700,"text-wrap-width":200,"text-margin":20},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":700,"text-wrap-width":200,"text-margin":5},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":16,"op":">="}]}],"styles":[]}]}]}]}]}]},{"id":90,"name":"ocean_labels","min_zoom":0,"max_zoom":7,"label_min_zoom":0,"badge_min_zoom":0,"priority":10,"type":"point","delta":12,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-style":"italic","text-fill":[87,137,203,1],"text-halo":[140,184,240,1],"text-halo-radius":1,"text-transform":"none","text-line-spacing":4,"text-wrap-width":100,"text-repeat-distance":1000,"text-margin":5,"text-align":"center","text-character-spacing":1},"filters":[],"styles":[{"rules":{"text-size":11,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":2,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":3,"op":">="}]}],"styles":[]}]}]}]}]},{"id":57,"name":"water","min_zoom":0,"max_zoom":21,"label_min_zoom":2,"badge_min_zoom":7,"priority":1,"type":"polygon","delta":13,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[163,204,255,1]},"filters":[],"styles":[]}]}]}]},{"id":59,"name":"rivers","min_zoom":5,"max_zoom":21,"label_min_zoom":13,"badge_min_zoom":7,"priority":1,"type":"line","delta":14,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[163,204,255,1]},"filters":[],"styles":[]},{"rules":{"line-color":[163,204,255,1],"text-face-name":"SanFrancisco","text-style":"italic","text-fill":[94,144,209,1],"text-spacing":400,"text-margin":15,"text-align":"center"},"filters":[],"styles":[{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"<="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2,"text-size":10},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3,"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3,"text-size":12},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4,"text-size":13},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6,"text-size":14},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":8,"text-size":15},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":11,"text-size":16},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":12,"text-size":17},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":15,"text-size":18},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":89,"name":"water_labels","min_zoom":4,"max_zoom":18,"label_min_zoom":0,"badge_min_zoom":0,"priority":1,"type":"point","delta":15,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-style":"italic","text-character-spacing":0,"text-fill":[87,137,203,1],"text-halo":[190,212,239,1],"text-halo-radius":1,"text-line-spacing":2,"text-wrap-width":200,"text-repeat-distance":1000,"text-margin":5,"text-align":"center","text-weight":400},"filters":[],"styles":[{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"<="}]}],"styles":[]},{"rules":{"text-size":10},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0},"filters":[{"conditions":[{"key":"zoom","value":17,"op":">="}]}],"styles":[]}]}]}]}]},{"id":78,"name":"ferry_routes","min_zoom":11,"max_zoom":21,"label_min_zoom":13,"badge_min_zoom":21,"priority":1,"type":"line","delta":16,"groups":[{"instances":[{"styles":[{"rules":{"line-color":[140,182,253,1],"line-width":2,"line-dasharray":[5,5],"line-join":"round","text-face-name":"SanFrancisco","text-character-spacing":0,"text-weight":400,"text-fill":[110,151,215,1],"text-halo-fill":[163,204,255,1],"text-align":"center","text-halo-radius":4,"text-margin":0},"filters":[],"styles":[{"rules":{"text-size":0,"line-dasharray":[6,2],"text-margin":20,"text-spacing":50},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"line-dasharray":[6,2],"text-margin":20,"text-spacing":50},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"line-dasharray":[6,2],"text-margin":20,"text-spacing":50},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"line-dasharray":[7,3],"text-margin":20,"text-spacing":50},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"line-dasharray":[8,4],"text-margin":20,"text-spacing":100},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"line-dasharray":[9,5],"text-margin":20,"text-spacing":200},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"line-dasharray":[10,6],"text-margin":20,"text-spacing":300},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"line-dasharray":[11,7],"text-margin":10,"text-spacing":400},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"line-dasharray":[12,8],"text-margin":0,"text-spacing":500},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":61,"name":"paths","min_zoom":15,"max_zoom":21,"label_min_zoom":14,"badge_min_zoom":0,"priority":1,"type":"line","delta":17,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":300,"text-size":8,"text-character-spacing":1,"text-spacing":300,"text-margin":5,"text-fill":[97,93,80,1],"text-halo-fill":[252,252,252,0.78],"text-halo-radius":2,"text-align":"center","line-color":[246,246,246,1],"line-join":"round"},"filters":[],"styles":[{"rules":{"text-size":8},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"<="}]}],"styles":[]},{"rules":{"text-size":8},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":8},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":9},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":500,"text-fill":[102,102,102,1]},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"<="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":11},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":20},"filters":[{"conditions":[{"key":"zoom","value":19,"op":"=="}]}],"styles":[]},{"rules":{"line-width":40},"filters":[{"conditions":[{"key":"zoom","value":20,"op":">="}]}],"styles":[]},{"rules":{"line-width":0,"text-size":0},"filters":[{"conditions":[{"key":"highway","value":"cycleway","op":"=="},{"key":"zoom","value":17,"op":"<="}]}],"styles":[]},{"rules":{"line-width":0,"text-size":0},"filters":[{"conditions":[{"key":"footway","value":"sidewalk","op":"=="},{"key":"zoom","value":21,"op":"<="}]}],"styles":[]},{"rules":{"line-color":[210,206,206,1],"line-width":5},"filters":[{"conditions":[{"key":"barrier","value":"ditch","op":"=="}]}],"styles":[]},{"rules":{"polygon-fill":[244,244,244,1],"text-margin":35},"filters":[{"conditions":[{"key":"highway","value":"pedestrian","op":"=="},{"key":"zoom","value":15,"op":">="}]}],"styles":[]},{"rules":{"polygon-fill":[244,244,244,1]},"filters":[{"conditions":[{"key":"highway","value":"footway","op":"=="},{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]}]}]}]},{"id":195,"name":"man_made","min_zoom":16,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"polygon","delta":18,"groups":[{"instances":[{"styles":[{"rules":{"polygon-fill":[242,242,242,1],"line-width":10,"line-color":[242,242,242,1]},"filters":[],"styles":[]}]}]}]},{"id":68,"name":"primary_roads","min_zoom":6,"max_zoom":21,"label_min_zoom":11,"badge_min_zoom":6,"priority":9,"type":"line","delta":19,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":400,"text-character-spacing":1,"text-fill":[146,146,146,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":50,"text-spacing":100,"text-align":"center","line-cap":"round","line-join":"round"},"filters":[],"styles":[{"rules":{"text-size":9},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"<="}]}],"styles":[]},{"rules":{"text-size":9,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10,"text-spacing":500,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-spacing":200,"text-weight":500,"text-margin":40},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-spacing":400,"text-weight":500,"text-margin":30},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-spacing":400,"text-weight":500,"text-margin":20},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-spacing":400,"text-weight":400,"text-margin":10},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":16,"text-spacing":500,"text-weight":300,"text-margin":5},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]},{"rules":{"line-width":2,"line-color":[244,215,172,1]},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2,"line-color":[244,215,172,1]},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5,"line-color":[255,255,255,0.9]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9.5,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":10,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":14,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":28,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":45,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":75,"line-color":[255,255,255,1]},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]},{"rules":{"line-width":1,"line-color":[232,192,134,1]},"filters":[{"conditions":[{"key":"type","value":"Secondary Highway","op":"=="}]}],"styles":[{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]}]},{"rules":{"line-width":4,"line-color":[220,205,156,1]},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]}]}]}]},{"instances":[{"styles":[{"rules":{"line-width":2,"line-color":[243,226,170,1]},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]}]}]}]},{"id":75,"name":"highways","min_zoom":5,"max_zoom":21,"label_min_zoom":11,"badge_min_zoom":6,"priority":10,"type":"line","delta":20,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":300,"text-character-spacing":1,"text-spacing":500,"text-line-spacing":5,"text-fill":[68,68,68,1],"text-halo-fill":[255,255,255,0.56],"text-halo-radius":2,"text-margin":10,"text-align":"center","line-cap":"round","line-join":"round"},"filters":[],"styles":[{"rules":{"text-size":10,"text-weight":400,"text-character-spacing":0},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"<="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":12,"op":">="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]}]}]}]},{"instances":[{"styles":[{"rules":{"line-color":[234,187,125,1],"line-width":2},"filters":[],"styles":[{"rules":{"line-width":4,"line-color":[225,191,142,1]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4,"line-color":[225,191,142,1]},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":4},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":12},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":17},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":22},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":30},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]},{"instances":[{"styles":[{"rules":{"line-color":[254,216,158,1]},"filters":[],"styles":[{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":14},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":19},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":27},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":76,"name":"highway_links","min_zoom":13,"max_zoom":21,"label_min_zoom":14,"badge_min_zoom":0,"priority":0,"type":"line","delta":21,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":300,"text-character-spacing":1,"text-spacing":500,"text-line-spacing":5,"text-fill":[68,68,68,1],"text-halo-fill":[255,255,255,0.56],"text-halo-radius":2,"text-margin":10,"text-align":"center","line-cap":"round","line-join":"round"},"filters":[],"styles":[{"rules":{"text-size":10,"text-weight":400,"text-character-spacing":0},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"<="}]}],"styles":[]},{"rules":{"text-size":12,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":12,"op":">="}]}],"styles":[]},{"rules":{"text-size":14,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]}]}]}]},{"instances":[{"styles":[{"rules":{"line-color":[234,187,125,1],"line-width":2},"filters":[],"styles":[{"rules":{"line-width":1,"line-color":[225,191,142,1]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-color":[225,191,142,1]},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":12},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":17},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":22},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":30},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]},{"instances":[{"styles":[{"rules":{"line-color":[254,216,158,1]},"filters":[],"styles":[{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":8,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":3},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":14},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":19},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":27},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":67,"name":"secondary_roads","min_zoom":11,"max_zoom":21,"label_min_zoom":11,"badge_min_zoom":8,"priority":8,"type":"line","delta":22,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":500,"text-character-spacing":0,"text-fill":[146,146,146,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":50,"text-spacing":200,"text-align":"center","line-cap":"round","line-join":"round","line-color":[255,255,255,1]},"filters":[],"styles":[{"rules":{"text-size":9,"text-margin":40,"text-spacing":200},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"<="}]}],"styles":[]},{"rules":{"text-size":10,"text-margin":30},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-margin":30,"text-spacing":300},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-margin":20},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-weight":400,"text-margin":10},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-weight":400,"text-margin":5},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":5},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":9},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":14},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":24},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":40},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":70},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":66,"name":"roads","min_zoom":13,"max_zoom":21,"label_min_zoom":13,"badge_min_zoom":13,"priority":7,"type":"line","delta":23,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":400,"text-size":8,"text-character-spacing":0,"text-fill":[146,146,146,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":10,"text-spacing":100,"text-align":"center","line-color":[255,255,255,1],"line-width":1},"filters":[],"styles":[{"rules":{"text-size":9,"text-margin":2,"text-spacing":100,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"<="}]}],"styles":[]},{"rules":{"text-size":9,"text-margin":1,"text-spacing":100,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":1,"text-spacing":100,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-margin":1,"text-spacing":100,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-margin":0,"text-spacing":50,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":13,"text-margin":0,"text-spacing":25,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":15,"text-margin":0,"text-spacing":25,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":0.01,"line-color":[255,255,255,0.9]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":22},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":40},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":65},"filters":[{"conditions":[{"key":"zoom","value":19,"op":">="}]}],"styles":[]}]}]}]}]},{"id":204,"name":"finer_roads","min_zoom":14,"max_zoom":21,"label_min_zoom":14,"badge_min_zoom":14,"priority":6,"type":"line","delta":24,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":400,"text-size":8,"text-character-spacing":1,"text-fill":[111,109,109,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":0,"text-spacing":100,"text-align":"center","line-color":[255,255,255,1],"line-width":1},"filters":[],"styles":[{"rules":{"text-size":9,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"<="}]}],"styles":[]},{"rules":{"text-size":10,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":10,"text-spacing":300,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-spacing":300,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-spacing":400,"text-weight":500},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"text-size":14,"text-spacing":500,"text-weight":400},"filters":[{"conditions":[{"key":"zoom","value":18,"op":">="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":15,"op":"=="}]}],"styles":[]},{"rules":{"line-width":2},"filters":[{"conditions":[{"key":"zoom","value":16,"op":"=="}]}],"styles":[]},{"rules":{"line-width":6},"filters":[{"conditions":[{"key":"zoom","value":17,"op":"=="}]}],"styles":[]},{"rules":{"line-width":11},"filters":[{"conditions":[{"key":"zoom","value":18,"op":"=="}]}],"styles":[]},{"rules":{"line-width":20},"filters":[{"conditions":[{"key":"zoom","value":19,"op":"=="}]}],"styles":[]},{"rules":{"line-width":40},"filters":[{"conditions":[{"key":"zoom","value":20,"op":">="}]}],"styles":[]}]}]}]}]},{"id":53,"name":"state_borders","min_zoom":3,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"line","delta":25,"groups":[{"instances":[{"styles":[{"rules":{"line-color":[170,169,169,1]},"filters":[],"styles":[{"rules":{"line-width":1,"line-dasharray":[7,2]},"filters":[{"conditions":[{"key":"zoom","value":2,"op":"<="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[6,2]},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[6,2]},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[6,2]},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[9,3]},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[11,4]},"filters":[{"conditions":[{"key":"zoom","value":7,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-dasharray":[13,4]},"filters":[{"conditions":[{"key":"zoom","value":8,"op":">="}]}],"styles":[]}]}]}]}]},{"id":54,"name":"country_borders","min_zoom":0,"max_zoom":21,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"line","delta":26,"groups":[{"instances":[{"styles":[{"rules":{"line-width":4,"line-color":[108,112,118,1]},"filters":[],"styles":[{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":2,"op":"<="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":3,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":4,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":5,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1},"filters":[{"conditions":[{"key":"zoom","value":6,"op":"=="}]}],"styles":[]},{"rules":{"line-width":1,"line-color":[90,94,99,1]},"filters":[{"conditions":[{"key":"zoom","value":7,"op":">="}]}],"styles":[]}]}]}]}]},{"id":205,"name":"landmarks","min_zoom":11,"max_zoom":21,"label_min_zoom":12,"badge_min_zoom":12,"priority":2,"type":"line","delta":27,"groups":[{"instances":[{"styles":[{"rules":{},"filters":[],"styles":[{"rules":{"text-dy":0,"text-dx":-10,"text-vertical-alignment":"middle","text-optional":"true","icon-optional":"false","icon-image":"icon_transit","icon-size":[10,10],"icon-opacity":1,"icon-color":[255,255,255,1],"icon-offset":[0,0]},"filters":[{"conditions":[{"key":"railway","value":"station","op":"=="}]}],"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":400,"text-character-spacing":1,"text-line-spacing":5,"text-fill":[46,155,206,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":5,"text-size":11,"text-wrap-width":200,"text-align":"right"},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]},{"rules":{"icon-size":[8,8]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"<="}]}],"styles":[]},{"rules":{"icon-margin":10},"filters":[{"conditions":[{"key":"zoom","value":13,"op":">="}]}],"styles":[]}]},{"rules":{"text-face-name":"SanFrancisco","text-style":"italic","text-weight":600,"text-character-spacing":1,"text-line-spacing":5,"text-fill":[88,169,81,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":20,"text-size":11,"text-wrap-width":150,"text-align":"right","text-dy":0,"text-dx":-10,"text-vertical-alignment":"middle","text-optional":"true","icon-optional":"false","icon-image":"icon_mountain","icon-size":[12,12],"icon-opacity":1,"icon-color":[255,255,255,1],"icon-offset":[0,0],"icon-margin":40},"filters":[{"conditions":[{"key":"natural","value":"peak","op":"=="}]}],"styles":[]},{"rules":{"text-face-name":"SanFrancisco","text-style":"italic","text-weight":600,"text-character-spacing":1,"text-line-spacing":5,"text-fill":[88,169,81,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":20,"text-size":11,"text-wrap-width":150,"text-align":"right","text-dy":-10,"text-vertical-alignment":"middle","text-optional":"false","icon-optional":"false","icon-image":"icon_mountain","icon-size":[12,12],"icon-opacity":1,"icon-color":[255,255,255,1],"icon-offset":[0,0],"icon-margin":40},"filters":[{"conditions":[{"key":"natural","value":"volcano","op":"=="}]}],"styles":[]},{"rules":{"text-face-name":"SanFrancisco","text-weight":400,"text-character-spacing":1,"text-line-spacing":5,"text-fill":[31,87,169,1],"text-halo-fill":[255,255,255,1],"text-halo-radius":1,"text-margin":5,"text-size":11,"text-align":"center","text-dy":-10,"text-vertical-alignment":"middle","text-optional":"false","icon-optional":"false","icon-image":"icon_box","icon-size":[6,6],"icon-opacity":1,"icon-color":[41,74,133,1],"icon-offset":[0,0]},"filters":[{"conditions":[{"key":"aerialway","value":"station","op":"=="}]}],"styles":[]}]}]}]}]},{"id":202,"name":"railway_station","min_zoom":14,"max_zoom":21,"label_min_zoom":14,"badge_min_zoom":27,"priority":7,"type":"line","delta":28,"groups":[{"instances":[{"styles":[]}]}]},{"id":206,"name":"hamlet","min_zoom":12,"max_zoom":21,"label_min_zoom":12,"badge_min_zoom":0,"priority":4,"type":"line","delta":29,"groups":[{"instances":[{"styles":[{"rules":{"text-face-name":"SanFrancisco","text-weight":500,"text-margin":10,"text-wrap-width":200,"text-line-spacing":5,"text-fill":[150,122,89,1],"text-character-spacing":1,"text-halo-fill":[242,242,242,1],"text-halo-radius":1,"text-align":"center"},"filters":[],"styles":[{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":9,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":30},"filters":[{"conditions":[{"key":"zoom","value":10,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-margin":30,"text-fill":[106,88,58,1]},"filters":[{"conditions":[{"key":"zoom","value":11,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-fill":[110,91,61,1]},"filters":[{"conditions":[{"key":"zoom","value":12,"op":"=="}]}],"styles":[]},{"rules":{"text-size":11,"text-fill":[124,102,71,1]},"filters":[{"conditions":[{"key":"zoom","value":13,"op":"=="}]}],"styles":[]},{"rules":{"text-size":12,"text-fill":[150,122,89,1]},"filters":[{"conditions":[{"key":"zoom","value":14,"op":"=="}]}],"styles":[]},{"rules":{"text-size":0,"icon-size":[0,0]},"filters":[{"conditions":[{"key":"zoom","value":15,"op":">="}]}],"styles":[]}]}]}]}]},{"id":99990,"name":"hillshade","min_zoom":0,"max_zoom":12,"label_min_zoom":0,"badge_min_zoom":0,"priority":0,"type":"polygon","delta":99990,"groups":[{"instances":[{"styles":[{"rules":{"hillshade-azimuth-angle":315,"hillshade-altitude":20,"hillshade-z-factor":10,"hillshade-factor":0.45,"hillshade-color-factor":0.6},"filters":[],"styles":[]}]}]}]}]}};

CM.Shaders = {};

CM.Shaders['business_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_maskTexCoord;\nvarying float v_alpha;\nvarying vec4 v_blendColor;\nvarying float v_textureId;\n\nuniform sampler2D u_texture[4];\n\nvoid main()\n{\n    int textureId = int(v_textureId);\n\n    vec4 color;\n    if (textureId == 0) {\n        color = texture2D(u_texture[0], v_texCoord);\n    } else if (textureId == 1) {\n        color = texture2D(u_texture[1], v_texCoord);\n    } else if (textureId == 2) {\n        color = texture2D(u_texture[2], v_texCoord);\n    } else if (textureId == 3) {\n        color = texture2D(u_texture[3], v_texCoord);\n    }\n\n    float outlineMaskAlpha = texture2D(u_texture[0], v_maskTexCoord).r;\n\n    vec4 outlineColor = v_blendColor * outlineMaskAlpha;\n\n    // \'blend the pin with the mask.\n    // color = destination color\n    // v_blendColor = src color;\n    // RGBAs * 1 + RGBAd * (1 - As)\n\n    color = outlineColor + color * (1.0 - outlineColor.a);\n\n    // And now premultiply alpha for our output\n    color *= v_alpha;\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['business_mini_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\n\nuniform sampler2D u_texture;\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_texCoord);\n    color.a *= v_alpha;\n\n    gl_FragColor = color;\n}\n';

CM.Shaders['business_mini_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute float a_alpha;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\n\nuniform mat4 u_mvp;\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    v_alpha = a_alpha;\n\n    gl_Position = u_mvp * vec4(a_position * 0.25, 0.0, 1.0);\n}\n';

CM.Shaders['business_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_maskTexCoord;\nattribute vec4 a_blendColor;\nattribute float a_alpha;\nattribute float a_textureId;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_maskTexCoord;\nvarying float v_alpha;\nvarying vec4 v_blendColor;\nvarying float v_textureId;\n\nuniform mat4 u_mvp;\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    v_maskTexCoord = a_maskTexCoord;\n    v_alpha = a_alpha;\n    v_blendColor = a_blendColor;\n    v_textureId = a_textureId;\n\n    gl_Position = u_mvp * vec4(a_position * 0.25, 0.0, 1.0);\n}\n';

CM.Shaders['debug_frag.glsl'] = 'precision lowp float;\n\nuniform vec4 u_color;\n\nvoid main()\n{\n    //gl_FragColor = u_color;\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\n}';

CM.Shaders['debug_vert.glsl'] = 'attribute vec2 a_position;\n\nuniform mat4 u_mvp;\n\nvoid main()\n{\n    gl_Position = u_mvp * vec4(a_position, 0.0, 1.0);\n}';

CM.Shaders['df_text_frag.glsl'] = 'precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_textSize;\nvarying float v_outlineWidth;\nvarying float v_alpha;\nvarying float v_textureId;\n\nuniform sampler2D u_texture[4];\nuniform float u_baseTextSize;\nuniform vec2 u_atlasSize;\n\n#define OUTLINE_BASE (1.0 / 256.0)\n\nfloat basicSample(sampler2D texture) {\n    return texture2D(texture, v_texCoord).a;\n}\n\nvoid main()\n{\n    float ratio = v_textSize / u_baseTextSize;\n\n    float sdfSample;\n    if (v_textureId == 0.0) {\n        sdfSample = basicSample(u_texture[0]);\n    } else if (v_textureId == 1.0) {\n        sdfSample = basicSample(u_texture[1]);\n    } else if (v_textureId == 2.0) {\n        sdfSample = basicSample(u_texture[2]);\n    } else if (v_textureId == 3.0) {\n        sdfSample = basicSample(u_texture[3]);\n    }\n    float outlineRatio = (OUTLINE_BASE * v_outlineWidth) / ratio;\n\n    float origin = 0.45 - outlineRatio;\n    float smoothing = (1.0 / (v_textSize * 0.75)) * 1.05;\n    vec4 color = v_color;\n    color.a *= v_alpha * smoothstep(origin - smoothing, origin + smoothing, sdfSample);\n    gl_FragColor = color;\n}';

CM.Shaders['df_text_vert.glsl'] = 'attribute vec2 a_position;\n\nuniform mat4 u_mvp;\nuniform vec2 u_size;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_size;\n\nvoid main()\n{\n    v_texCoord = a_position;\n    v_size = u_size;\n    \n    vec2 scaledPosition = (a_position * u_size);\n    gl_Position = u_mvp * vec4(scaledPosition, 0.0, 1.0);\n}';

CM.Shaders['label_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_color;\n\nuniform sampler2D u_texture;\n\nvoid main()\n{\n    float alpha = texture2D(u_texture, v_texCoord).a;\n    gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n\n';

CM.Shaders['label_map_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_offset;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute float a_textSize;\nattribute float a_outlineWidth;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_textSize;\nvarying float v_outlineWidth;\n\nuniform mat4 u_mvp;\nuniform float u_outlinePass;\nuniform vec4 u_mapBounds;\nuniform vec2 u_mapSize;\n\n#define M_PI 3.1415926535897932384626433832795\n#define TO_RADIANS M_PI / 180.0\n\nvec2 project(vec2 position)\n{\n    float x = (position.x - u_mapBounds.x) * (u_mapSize.x / u_mapBounds.z);\n\n    float latitude = position.y * TO_RADIANS;\n    float latSin = sin(latitude);\n\n    float worldMapWidth = ((u_mapSize.x / u_mapBounds.z) * 360.0) / (2.0 * M_PI);\n    float mapOffsetY = (worldMapWidth / 2.0 * log((1.0 + u_mapBounds.y) / (1.0 - u_mapBounds.y)));\n    float y = u_mapSize.y - ((worldMapWidth / 2.0 * log((1.0 + latSin) / (1.0 - latSin))) - mapOffsetY);\n\n    return vec2(x, y);\n}\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    v_color = (a_outlineColor * u_outlinePass) + (a_color * (1.0 - u_outlinePass));\n    v_outlineWidth = a_outlineWidth * u_outlinePass;\n    v_textSize = a_textSize;\n\n    vec2 projPosition = project(a_position) + a_offset * 0.25;\n    //projPosition.y += a_position.y;\n    //projPosition.y += 80.0;\n    gl_Position = u_mvp * vec4(projPosition, 0.0, 1.0);\n}\n\n\n';

CM.Shaders['label_simple_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_textSize;\nvarying float v_outlineWidth;\n\nuniform mat4 u_mvp;\nuniform float u_outlinePass;\nuniform vec2 u_origin;\nuniform vec4 u_color;\nuniform vec4 u_outlineColor;\nuniform float u_textSize;\nuniform float u_outlineWidth;\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    v_color = (u_outlineColor * u_outlinePass) + (u_color * (1.0 - u_outlinePass));\n    v_outlineWidth = u_outlineWidth * u_outlinePass;\n    v_textSize = u_textSize;\n\n    gl_Position = u_mvp * vec4(a_position + u_origin, 0.0, 1.0);\n}\n';

CM.Shaders['label_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute float a_textSize;\nattribute float a_outlineWidth;\nattribute float a_alpha;\nattribute float a_textureId;\nattribute vec2 a_size;\nattribute float a_angle;\nattribute vec2 a_anchor;\nattribute vec2 a_glyphCenter;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_textSize;\nvarying float v_outlineWidth;\nvarying float v_alpha;\nvarying float v_textureId;\n\nuniform mat4 u_mvp;\nuniform float u_outlinePass;\n\nvoid main()\n{\n    vec2 position = a_position * 0.25;\n    vec2 anchorPos = a_anchor * 0.25;\n    float outlineWidth = a_outlineWidth * u_outlinePass * 0.25;\n\n    vec4 color = a_color;\n    float textSize = a_textSize;\n\n    if (u_outlinePass == 1.0) {\n        if (a_outlineWidth == 0.0) {\n            gl_Position = vec4(-1000);\n            return;\n        }\n        color = a_outlineColor;\n        vec2 glyphCenter = a_glyphCenter * 0.25;\n        vec2 normal = normalize(position - glyphCenter);\n        position += normal * outlineWidth;\n    }\n\n    float angle = a_angle * 0.001;\n\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n\n    vec2 rotatedPos;\n    rotatedPos.x = (cosA * position.x) - (sinA * position.y);\n    rotatedPos.y = (sinA * position.x) + (cosA * position.y);\n\n    v_texCoord = a_texCoord;\n    v_color = color;\n    v_outlineWidth = outlineWidth;\n    v_textSize = a_textSize;\n    v_alpha = a_alpha;\n    v_textureId = a_textureId;\n    gl_Position = u_mvp * vec4(anchorPos + rotatedPos, 0.0, 1.0);\n}';

CM.Shaders['line_helper.glsl'] = '';

CM.Shaders['line_pattern_frag.glsl'] = 'precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\nvarying highp float v_segmentLength;\nvarying lowp vec4 v_linePattern;\n\nvoid main()\n{\n    float patternLength = v_linePattern[0] + v_linePattern[1] + v_linePattern[2] + v_linePattern[3];\n\n    float patternPosition = mod(v_segmentLength, patternLength);\n\n    float min1 = 0.0;\n    float max1 = v_linePattern[0];\n\n    float min2 = v_linePattern[0] + v_linePattern[1];\n    float max2 = min2 + v_linePattern[2];\n\n    float killPixel = float((patternPosition >= min1 && patternPosition <= max1) ||\n    (patternPosition >= min2 && patternPosition <= max2));\n\n\n\n    mediump float distance = abs(v_distance);\n    lowp vec4 color = v_color;\n    color.a *= smoothstep(v_min + v_smoothing, v_min - v_smoothing, distance);\n\n    gl_FragColor = color * killPixel;\n    //gl_FragColor = vec4(distance, distance, distance, 1.0);\n\n//    float percent = patternPosition / patternLength;\n//    gl_FragColor = vec4(percent, percent, percent, 1.0);\n}';

CM.Shaders['line_pattern_vert.glsl'] = 'attribute highp vec2 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec4 a_perpSignSize;\nattribute lowp vec4 a_linePattern;\nattribute highp float a_length;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\nvarying highp float v_segmentLength;\nvarying lowp vec4 v_linePattern;\n\nuniform mat4 u_mvp;\nuniform vec2 u_origin;\nuniform highp float u_resolution;\nuniform highp float u_baseResolution;\nuniform highp float u_aaPadding;\n\nconst float MAX_LINE_SIZE = (32767.0 / 255.0);\n\n\nvoid main()\n{\n    lowp vec2 perp = a_perpSignSize.xy * 2.0;\n    lowp float distSign = a_perpSignSize.z;\n    float size = a_perpSignSize.w * MAX_LINE_SIZE;\n\n    highp vec2 finalVector = perp * (size * u_resolution);\n    finalVector += perp * 2.0 * u_aaPadding;\n\n    highp vec2 v2Pos = a_position + finalVector;\n\n    v_min = size / (size + 2.0);\n    v_color = a_color;\n    v_distance = distSign;\n    v_smoothing = 1.0 / (2.0 + 2.0 * size);\n    v_segmentLength = a_length;\n    v_linePattern = a_linePattern * u_baseResolution;\n\n    highp mat4 modelMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        u_origin.x, u_origin.y, 0.0, 1.0\n    );\n\n    gl_Position = (u_mvp * modelMatrix) * vec4(v2Pos.x, v2Pos.y, 0.0, 1.0);\n}';

CM.Shaders['line_solid_frag.glsl'] = 'precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\n\nvoid main()\n{\n    mediump float distance = abs(v_distance);\n    lowp vec4 color = v_color;\n    color.a *= smoothstep(v_min + v_smoothing, v_min - v_smoothing, distance);\n\n    gl_FragColor = color;\n    //gl_FragColor = vec4(distance, distance, distance, 1.0);\n}';

CM.Shaders['line_solid_joint_frag.glsl'] = 'precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying lowp vec2 v_texCoord;\nvarying mediump float v_size;\n\nvoid main()\n{\n    mediump float distance = distance(v_texCoord, vec2(0.5, 0.5));\n    lowp vec4 color = v_color;\n    float maxDistance = 0.5;\n    float minDistance = maxDistance - (0.1 * (1.0 / v_size));\n    color.a = 1.0 - smoothstep(minDistance, maxDistance, distance);\n\n    gl_FragColor = color;\n    //gl_FragColor = vec4(0, 0, 0, 1.0);\n    //gl_FragColor = vec4(color.a, color.a, color.a, 1.0);\n}';

CM.Shaders['line_solid_joint_vert.glsl'] = 'attribute highp vec2 a_position;\nattribute lowp vec4 a_color;\nattribute lowp vec2 a_texCoord;\nattribute mediump float a_size;\n\nvarying lowp vec4 v_color;\nvarying lowp vec2 v_texCoord;\nvarying mediump float v_size;\n\nuniform mat4 u_mvp;\nuniform vec2 u_origin;\nuniform highp float u_resolution;\n\nconst float MAX_LINE_SIZE = (32767.0 / 255.0);\n\nvoid main()\n{\n    v_color = a_color;\n    v_texCoord = a_texCoord;\n\n    float size = a_size * 0.25;// MAX_LINE_SIZE;\n    v_size = size;\n\n    vec2 position = a_position + ((a_texCoord - vec2(0.5, 0.5)) * (u_resolution * size));\n\n    highp mat4 modelMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        u_origin.x, u_origin.y, 0.0, 1.0\n    );\n\n    gl_Position = (u_mvp * modelMatrix) * vec4(position, 0.0, 1.0);\n}';

CM.Shaders['line_solid_vert.glsl'] = 'attribute highp vec2 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec4 a_perpSignSize;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\n\nuniform mat4 u_mvp;\nuniform vec2 u_origin;\nuniform highp float u_resolution;\nuniform highp float u_baseResolution;\nuniform highp float u_aaPadding;\n\nconst float MAX_LINE_SIZE = (32767.0 / 255.0);\n\nvoid main()\n{\n    lowp vec2 perp = a_perpSignSize.xy * 2.0;\n    lowp float distSign = a_perpSignSize.z;\n    float size = a_perpSignSize.w * MAX_LINE_SIZE;\n    highp vec2 finalVector = perp * (size * u_resolution);\n    finalVector += perp * 2.0 * u_aaPadding;\n\n    highp vec2 v2Pos = a_position + finalVector;\n\n    highp mat4 modelMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        u_origin.x, u_origin.y, 0.0, 1.0\n    );\n\n    v_min = size / (size + 2.0);\n    v_color = a_color;\n    v_distance = distSign;\n    v_smoothing = 1.0 / (2.0 + 2.0 * size);\n\n    gl_Position = (u_mvp * modelMatrix) * vec4(v2Pos.x, v2Pos.y, 0.0, 1.0);\n}';

CM.Shaders['polygon_color_elevation_frag.glsl'] = 'precision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_isLandCover;\n\nuniform sampler2D u_elevationTexture;\nuniform float u_hasElevation;\nuniform float u_zenithAngle;\nuniform float u_azimuthAngle;\nuniform float u_zFactor;\nuniform float u_hillshadeFactor;\nuniform float u_colorFactor;\nuniform float u_pixelSize;\nuniform float u_landFactor;\n\nconst float PI = 3.14159265359;\nconst float DBL_PI = 2.0 * PI;\nconst float HALF_PI = PI / 2.0;\nconst vec3 LAND_COVER_BACKUP = vec3(187.0 / 255.0,218.0 / 255.0,205.0 / 255.0);\nconst float HILLSHADE_OFFSET = (87.0 / 255.0);\n\nvoid main()\n{\n    vec2 texCoord = vec2(v_texCoord.x, 1.0 - v_texCoord.y);\n\n    vec4 e = texture2D(u_elevationTexture, texCoord);\n    vec4 finalColor = v_color;\n\n    vec4 landCoverColor = e;\n    if ((e.r + e.g + e.b) == 0.0) {\n        landCoverColor = vec4(LAND_COVER_BACKUP, e.a);\n    }\n\n    if (v_isLandCover != 0.0) {\n        finalColor = (u_landFactor * landCoverColor) + ((1.0 - u_landFactor) * v_color);\n    }\n\n    float a = texture2D(u_elevationTexture, texCoord + vec2(-u_pixelSize, u_pixelSize)).a;\n    float b = texture2D(u_elevationTexture, texCoord + vec2(0.0, u_pixelSize)).a;\n    float c = texture2D(u_elevationTexture, texCoord + vec2(u_pixelSize, u_pixelSize)).a;\n    float d = texture2D(u_elevationTexture, texCoord + vec2(-u_pixelSize, 0.0)).a;\n    float f = texture2D(u_elevationTexture, texCoord + vec2(u_pixelSize, 0.0)).a;\n    float g = texture2D(u_elevationTexture, texCoord + vec2(-u_pixelSize, -u_pixelSize)).a;\n    float h = texture2D(u_elevationTexture, texCoord + vec2(0.0, -u_pixelSize)).a;\n    float i = texture2D(u_elevationTexture, texCoord + vec2(u_pixelSize, -u_pixelSize)).a;\n\n    float dzdx = ((c + (2.0 * f) + i) - (a + (2.0 * d) + g)) / 8.0;\n    float dzdy = ((g + (2.0 * h) + i) - (a + (2.0 * b) + c)) / 8.0;\n\n    float slopeAngle = atan(u_zFactor * sqrt((dzdx * dzdx) + (dzdy * dzdy)));\n\n    float aspect = 0.0;\n    if (dzdx != 0.0) {\n        aspect = atan(dzdy, -dzdx);\n\n        if (aspect < 0.0) {\n            aspect = (DBL_PI) + aspect;\n        }\n    } else {\n        if (dzdy > 0.0) {\n            aspect = HALF_PI;\n        } else if (dzdy < 0.0) {\n            aspect = (DBL_PI) - (HALF_PI);\n        }\n    }\n\n    float hillshade = ((cos(u_zenithAngle) * cos(slopeAngle)) +\n            (sin(u_zenithAngle) * sin(slopeAngle) * cos(u_azimuthAngle - aspect))) - HILLSHADE_OFFSET;\n\n    finalColor = mix(finalColor, finalColor * u_colorFactor, hillshade * u_hillshadeFactor);\n    finalColor.a = 1.0;\n\n    gl_FragColor = finalColor;\n}';

CM.Shaders['polygon_color_frag.glsl'] = 'precision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main()\n{\n    gl_FragColor = v_color;\n}';

CM.Shaders['polygon_color_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec4 a_color;\nattribute float a_layerId;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\nvarying float v_isLandCover;\n\nuniform mat4 u_mvp;\nuniform vec2 u_origin;\nuniform float u_baseResolution;\nuniform float u_tileSize;\nuniform float u_landLayerId;\n\nvoid main()\n{\n    v_color = a_color;\n    v_texCoord = (a_position / u_baseResolution / u_tileSize);\n    v_isLandCover = a_layerId == u_landLayerId ? 1.0 : 0.0;\n\n    highp mat4 modelMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        u_origin.x, u_origin.y, 0.0, 1.0\n    );\n    gl_Position = (u_mvp * modelMatrix) * vec4(a_position.x, a_position.y, 0.0, 1.0);\n}';

CM.Shaders['polygon_texture_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_position;\nvarying vec4 v_color;\nvarying vec4 v_texDimensions;\nvarying vec2 v_texCoord;\n\nuniform sampler2D u_texture;\n\nvoid main()\n{\n    vec2 fraction = fract(v_texCoord);\n    vec2 finalTexCoord = v_texDimensions.xy + fraction * v_texDimensions.zw;\n    vec4 color = texture2D(u_texture, finalTexCoord);\n    color *= v_color;\n    gl_FragColor = color;\n}';

CM.Shaders['polygon_texture_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec4 a_color;\nattribute float a_textureId;\n\nvarying vec4 v_color;\nvarying vec4 v_texDimensions;\nvarying vec2 v_position;\nvarying vec2 v_texCoord;\n\nuniform mat4 u_mvp;\nuniform vec2 u_origin;\nuniform vec4 u_texDimensions[16];\nuniform float u_baseResolution;\nuniform float u_tileSize;\n\nvoid main()\n{\n    v_color = a_color;\n    v_position = a_position;\n    v_texDimensions = u_texDimensions[int(a_textureId)];\n    v_texCoord = (a_position / u_baseResolution / u_tileSize);\n    // flip y for correct uv orientation.\n    v_texCoord.y *= -1.0;\n\n    highp mat4 modelMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        u_origin.x, u_origin.y, 0.0, 1.0\n    );\n    gl_Position = (u_mvp * modelMatrix) * vec4(a_position.x, a_position.y, 0.0, 1.0);\n}';

CM.Shaders['sprite_batch_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_blendColor;\nvarying float v_textureId;\n\nuniform sampler2D u_texture[4];\n\nvoid main()\n{\n    int textureId = int(v_textureId);\n\n    vec4 color;\n    if (textureId == 0) {\n        color = texture2D(u_texture[0], v_texCoord);\n    } else if (textureId == 1) {\n        color = texture2D(u_texture[1], v_texCoord);\n    } else if (textureId == 2) {\n        color = texture2D(u_texture[2], v_texCoord);\n    } else if (textureId == 3) {\n        color = texture2D(u_texture[3], v_texCoord);\n    }\n\n    color *= v_blendColor;\n    color *= v_alpha;\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_batch_frag_src_alpha.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_blendColor;\nvarying float v_textureId;\n\nuniform sampler2D u_texture[4];\n\nvoid main()\n{\n    int textureId = int(v_textureId);\n\n    vec4 color;\n    if (textureId == 0) {\n        color = texture2D(u_texture[0], v_texCoord);\n    } else if (textureId == 1) {\n        color = texture2D(u_texture[1], v_texCoord);\n    } else if (textureId == 2) {\n        color = texture2D(u_texture[2], v_texCoord);\n    } else if (textureId == 3) {\n        color = texture2D(u_texture[3], v_texCoord);\n    }\n\n    color *= v_blendColor;\n    color.a *= v_alpha;\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_batch_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_blendColor;\nattribute float a_alpha;\nattribute float a_textureId;\n\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_blendColor;\nvarying float v_textureId;\n\nuniform mat4 u_mvp;\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    v_alpha = a_alpha;\n    v_blendColor = a_blendColor;\n    v_textureId = a_textureId;\n\n    gl_Position = u_mvp * vec4(a_position * 0.25, 0.0, 1.0);\n}\n';

CM.Shaders['sprite_business_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_size;\n\nuniform sampler2D u_texture;\nuniform float u_cornerRadius;\n\nvoid roundedCornerTest(float r, float d, inout vec4 color)\n{\n    float min = r;\n    float max = r;\n    if (d < min)\n    {\n        color.a *= 1.0;\n    } else if (d > max)\n    {\n        color.a *= 0.0;\n    } else\n    {\n        float interpolated = mix(min, max, d);\n        interpolated = (interpolated + 1.0) / 2.0;\n        color.a *= interpolated;\n    }\n}\n\nvoid applyRoundedCorners(vec2 p, vec2 size, float radius, inout vec4 color) {\n\n    float x1 = radius;\n    float x2 = size.x - radius;\n\n    float y1 = radius;\n    float y2 = size.y - radius;\n\n    if (p.x < x1 && p.y < y1) {\n        vec2 spherePos = vec2(x1, y1);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x > x2 && p.y > y2) {\n        vec2 spherePos = vec2(x2, y2);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x < x1 && p.y > y2) {\n        vec2 spherePos = vec2(x1, y2);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x > x2 && p.y < y1) {\n        vec2 spherePos = vec2(x2, y1);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n}\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_texCoord);\n\n    applyRoundedCorners(v_texCoord * v_size, v_size, u_cornerRadius, color);\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_business_lanczos_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_size;\n\nuniform sampler2D u_texture;\nuniform float u_cornerRadius;\nuniform vec2 u_inSize;\nuniform vec2 u_outSize;\n\n#define PI 3.14159265359\n#define WIDTH 3.0\n#define WIDTH_1 (WIDTH + 1.0)\n#define FLT_EPSILON 0.00001\n\nfloat sinc(float x) {\n    return sin(x) / x;\n}\n\nfloat lanczos(float x) {\n    if (x <= -WIDTH || x >= WIDTH) {\n        return 0.0;  // Outside of the window.\n    }\n    if (x > -FLT_EPSILON && x < FLT_EPSILON) {\n        return 1.0;  // Special case the discontinuity at the origin.\n    }\n\n    float xpi = x * PI;\n    return sinc(xpi) * sinc(xpi / WIDTH);\n}\n\nvoid roundedCornerTest(float r, float d, inout vec4 color)\n{\n    float min = r;\n    float max = r;\n    if (d < min)\n    {\n        color.a *= 1.0;\n    } else if (d > max)\n    {\n        color.a *= 0.0;\n    } else\n    {\n        float interpolated = mix(min, max, d);\n        interpolated = (interpolated + 1.0) / 2.0;\n        color.a *= interpolated;\n    }\n}\n\nvoid applyRoundedCorners(vec2 p, vec2 size, float radius, inout vec4 color) {\n\n    float x1 = radius;\n    float x2 = size.x - radius;\n\n    float y1 = radius;\n    float y2 = size.y - radius;\n\n    if (p.x < x1 && p.y < y1) {\n        vec2 spherePos = vec2(x1, y1);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x > x2 && p.y > y2) {\n        vec2 spherePos = vec2(x2, y2);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x < x1 && p.y > y2) {\n        vec2 spherePos = vec2(x1, y2);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n\n    if (p.x > x2 && p.y < y1) {\n        vec2 spherePos = vec2(x2, y1);\n        float d = distance(spherePos, p);\n\n        roundedCornerTest(radius, d, color);\n        return;\n    }\n}\n\nvoid applyLanczosFilter(inout vec4 color) {\n    vec2 coord = floor(v_texCoord * u_inSize);\n\n    vec2 ratio = u_outSize / u_inSize;\n\n    vec2 texelSize = 1.0 / u_inSize;\n\n    float weight = 0.0;\n    vec4 finalColor = vec4(0);\n\n    for (float i = -WIDTH_1; i < WIDTH; i++) {\n       for (float j = -WIDTH_1; j < WIDTH; j++) {\n            vec2 texCoord = vec2(i + coord.x, j + coord.y) * texelSize;\n            vec4 tColor = texture2D(u_texture, texCoord);\n            float w = lanczos(i * -1.0 * ratio.x) * lanczos(j * -1.0 * ratio.y);\n            finalColor += tColor * w;\n            weight += w;\n       }\n    }\n\n    color = finalColor / weight;\n}\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_texCoord);\n\n    applyLanczosFilter(color);\n\n    applyRoundedCorners(v_texCoord * v_size, v_size, u_cornerRadius, color);\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_alpha;\nuniform vec4 u_blendColor;\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_texCoord);\n    color.a *= u_alpha;\n    color *= u_blendColor;\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_lanczos_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\n\nuniform sampler2D u_texture;\nuniform float u_alpha;\nuniform vec4 u_blendColor;\nuniform vec2 u_inSize;\nuniform vec2 u_outSize;\n\n#define ONE_OVER_255 1.0 / 255.0\n#define PI 3.14159265359\n#define WIDTH 3.0\n#define WIDTH_1 (WIDTH + 1.0)\n#define FLT_EPSILON 0.00001\n\nfloat sinc(float x) {\n    return sin(x) / x;\n}\n\nfloat lanczos(float x) {\n    if (x <= -WIDTH || x >= WIDTH) {\n        return 0.0;  // Outside of the window.\n    }\n    if (x > -FLT_EPSILON && x < FLT_EPSILON) {\n        return 0.0;  // Special case the discontinuity at the origin.\n    }\n\n    float xpi = x * PI;\n    return sinc(xpi) * sinc(xpi / WIDTH);\n}\n\nvoid main()\n{\n    vec2 coord = floor(v_texCoord * u_inSize);\n\n    vec2 ratio = u_outSize / u_inSize;\n\n    vec2 texelSize = 1.0 / u_inSize;\n\n    float weight = 0.0;\n    vec4 color = vec4(0);\n\n    for (float i = -WIDTH_1; i < WIDTH; i++) {\n       for (float j = -WIDTH_1; j < WIDTH; j++) {\n            vec2 texCoord = vec2(i + coord.x, j + coord.y) * texelSize;\n            vec4 tColor = texture2D(u_texture, texCoord);\n            float w = lanczos(i * -1.0 * ratio.x) * lanczos(j * -1.0 * ratio.y);\n            color += tColor * w;\n            weight += w;\n       }\n    }\n\n    color /= weight;\n\n    color.a *= u_alpha;\n    color *= u_blendColor;\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_mask_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_size;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_alphaMaskTexture;\nuniform float u_alpha;\nuniform vec4 u_blendColor;\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_texCoord);\n    color *= u_alpha;\n    color *= u_blendColor;\n\n    color.a = 1.0 - texture2D(u_alphaMaskTexture, v_texCoord).r;\n\n    gl_FragColor = color;\n}\n\n';

CM.Shaders['sprite_vert.glsl'] = 'attribute vec2 a_coords;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_size;\n\nuniform mat4 u_mvp;\nuniform vec4 u_dimensions;\nuniform vec4 u_textureDimensions;\nuniform vec2 u_anchorPoint;\nuniform vec2 u_rotation;\n\nvoid main()\n{\n    vec2 modelCoords = a_coords * u_dimensions.zw;\n    modelCoords -= u_anchorPoint.xy * u_dimensions.zw;\n    \n    vec2 baseCoords;\n    baseCoords.x = (modelCoords[0] * u_rotation[1]) - (modelCoords[1] * u_rotation[0]);\n    baseCoords.y = (modelCoords[0] * u_rotation[0]) + (modelCoords[1] * u_rotation[1]);\n    baseCoords = modelCoords;\n    baseCoords += u_dimensions.xy;\n    \n    v_texCoord = u_textureDimensions.xy + (a_coords * u_textureDimensions.zw);\n    v_size = u_dimensions.zw;\n\n    gl_Position = u_mvp * vec4(baseCoords, 0.0, 1.0);\n}\n';

CM.Shaders['vector_df_frag.glsl'] = 'precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\nvarying highp float v_segmentLength;\nvarying lowp vec4 v_linePattern;\n\nvoid main()\n{\n    float patternLength = v_linePattern[0] + v_linePattern[1] + v_linePattern[2] + v_linePattern[3];\n    float killPixel = 1.0;\n\n    if (patternLength > 0.0) {\n        float patternPosition = mod(v_segmentLength, patternLength);\n\n        float min1 = 0.0;\n        float max1 = v_linePattern[0];\n\n        float min2 = v_linePattern[0] + v_linePattern[1];\n        float max2 = min2 + v_linePattern[2];\n\n        killPixel = float((patternPosition >= min1 && patternPosition <= max1) ||\n        (patternPosition >= min2 && patternPosition <= max2));\n\n        //float ratio = patternPosition / patternLength;\n        //gl_FragColor = vec4(killPixel, killPixel, killPixel, 1.0);\n\n        //return;\n    }\n\n\n    mediump float distance = abs(v_distance);\n    lowp vec4 color = v_color;\n    color.a *= smoothstep(v_min + v_smoothing, v_min - v_smoothing, distance);\n\n    gl_FragColor = color * killPixel;\n    //gl_FragColor = vec4(distance, distance, distance, 1.0);\n}';

CM.Shaders['vector_df_vert.glsl'] = 'attribute highp vec2 a_position;\nattribute lowp vec3 a_perp_distSign;\nattribute mediump float a_size;\nattribute lowp vec4 a_color;\nattribute highp float a_length;\nattribute lowp vec4 a_linePattern;\n\nvarying lowp vec4 v_color;\nvarying mediump float v_distance;\nvarying mediump float v_min;\nvarying mediump float v_smoothing;\nvarying highp float v_segmentLength;\nvarying lowp vec4 v_linePattern;\n\nuniform mat4 u_mvp;\nuniform highp float u_resolution;\nuniform highp float u_baseResolution;\nuniform highp float u_aaPadding;\n\nvoid main()\n{\n    lowp vec2 perp = a_perp_distSign.xy;\n    lowp float distSign = a_perp_distSign.z;\n\n    highp vec2 finalVector = perp * (a_size * u_resolution);\n    finalVector += perp * 3.0 * u_aaPadding;\n\n    highp vec2 v2Pos = a_position + finalVector;\n\n    v_min = a_size / (a_size + 3.0);\n    v_color = a_color;\n    v_distance = distSign;\n    v_smoothing = 1.0 / (2.0 + 4.0 * a_size);\n    v_segmentLength = a_length;\n    v_linePattern = a_linePattern * u_baseResolution;\n\n    gl_Position = u_mvp * vec4(v2Pos.x, v2Pos.y, 0.0, 1.0);\n}';

CM.Shaders['vector_pass_frag.glsl'] = 'precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = vec4(v_color.xyz * v_color.a, v_color.a);\n}\n';

CM.Shaders['vector_pass_vert.glsl'] = 'attribute vec4 a_posAndPerp;\nattribute vec2 a_layerAndU;\n\nvarying vec4 v_color;\n\nuniform mat4 u_mvp;\nuniform vec4 u_colors[75];\nuniform float u_widths[75];\n\nvoid main()\n{\n    int layerIdInt = int(a_layerAndU.x);\n    float width = u_widths[layerIdInt];\n    v_color = u_colors[layerIdInt];\n    \n    vec2 v2Pos = a_posAndPerp.xy + (a_posAndPerp.zw * width);\n    gl_Position = u_mvp * vec4(v2Pos.x, v2Pos.y, 0.0, 1.0);\n}';

CM.Shaders['vector_texture_frag.glsl'] = 'precision highp float;\n\nvarying vec2 v_texCoord;\n\nuniform sampler2D u_texture;\n\nvoid main()\n{\n    //gl_FragColor = texture2D(u_texture, v_texCoord);\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}\n\n';

CM.Shaders['vector_texture_vert.glsl'] = 'attribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nvarying vec2 v_texCoord;\n\nuniform mat4 u_mvp;\n\nvoid main()\n{\n    v_texCoord = a_texCoord;\n    \n    gl_Position = u_mvp * vec4(a_position, 0.0, 1.0);\n}\n';

CM.Keys = {};

CM.Keys['pk-APKAIPPUPIOAVQKJIX6A.cer'] = '-----BEGIN RSA PRIVATE KEY-----\r\nMIIEpAIBAAKCAQEApIXej3SC/TE/QeR34uKdf7FYgIVvYGBLQM4ZcgcR0mTxcsnj\r\nx6IK8l1Rq5+Kyu7bsQQc43KejA5Th8aGqVAFM8h/WQIw5NfzZ1/qLmeDmyGdzxjj\r\nputzbZS85TNE3XvyJf1L4E+dV+OyCePdux2U1izhdbkJfU5wVqPB4wVmls1vbKaP\r\nO2k7/AQWhx7YHHzU0Io5ztAV5E8KpMS+nabUvDOCzRQYFQgBb88z995BajRraljA\r\nT5BZp59i6BzGkWY5FTegbI037cjl/zD7Y9UvaaHK+tZRdFJzNex2vI9jzx9tUH/i\r\nvNRcHou0QLwWesKoOswuZfSrvYoqBg8a0FIvwwIDAQABAoIBAQCUkcdPqJl5Z3WG\r\nXXjdzGMKIu6W8OiJEawjU3qq/DNd2YYocKRfbLeR8i+EWkiNxXFiwyILS0BdnbpU\r\nzDRixT5NauuFR3M71L+bRIRHb3brKkpF8GX0IH9WH5ENMWUo1XrwT3Krl3mxGo92\r\nWu2qwaXcWx8mnfgxzhmoQ60dA42G837CI/TWWAU8xPLuNEHWkNGVsRUc2pNsmspa\r\nCK2gmDM6jYzv0rr3Fb3duHq1vi1yMBd853CZmbHFzBJPHNonBcgKqUhCBRwY+02B\r\ne9oETtYfX3BOwTwgNPT0tEsHY+OIguLW+PMFipXbu9+WxUjwJlzqkjv6D9blT/80\r\nTqreB8BxAoGBANHNpsyTgxxOXeiiOeFKgxPvUpByAH16nEcLu7zgUh1wD0mJemrw\r\nBrnpAWshjwUDdCtdWm5fXproutCpA5oLYTgEyLeELzArOcBxD+EPP1Guhg024A7P\r\n6LIzxL3ixRGcVz9WjCl1iib4sYGzFf0Wno0EiHc8yTqppGqij5I1I+R/AoGBAMi/\r\n0aUTac6CM5yXRR1BGTM/WV9Dvaj5mBaItuPr+IC2l5UBQ4PNBu7nuzVXLNVUFWFT\r\n8ny9g4uwIms3JsSskecm1ZZ9bnwKnA+afqjyMNNzx8yeb0d9R1e/8QejqfhPUhnh\r\nS/vvOLeiO6GQUXt26tbAF3qnCbcCeoNFBTDYNoK9AoGAUKZ2jUPTbckuTmQ2TcWf\r\n98TS/1XjnFjKxIDdLXEp/8j5B3LCzWLxovvQIMeou+uk95qOTcl5i6EVV2rxSIFB\r\nYRBtvCYjIagsLi8IRKLg21x0iZXjsa34rLA73CbVTLzFyUJS5QkbD3ogelRGiqDs\r\nWBc7AmMqk9NssdVFzZWB868CgYArC97De/8zNf4lNNawKDZkI9BhOiBgLG0tX9F/\r\n3CikSQMGA4hbqcozzmL5VCEb+XTAMwULNIQRnwoyXVgl0i9TFqO0Kl9Xn9rJCcLh\r\nLVXE8c3FFbAc70MuEM15auHWigO74vCtLCXIUrRgt5aRV/WRaQ1f0pOlt5VXsqQj\r\nTimaLQKBgQClY3GrMdDhXZcPI571ny9JK3WWQydSJWODn9WTODBqom3NduK6A1Q3\r\n4bNy2bRUUwvrR6jwSXSzms724aYAXrub2T1Avj6bqW0TH6U0yx78mCvrCoEor+3x\r\nxb1YW81ILJDQ10AAClWAcoJrzfucbeuIOO+VFl+PLvlgzFC+R2VSyg==\r\n-----END RSA PRIVATE KEY-----\r\n';

CM.Keys['rsa-APKAIPPUPIOAVQKJIX6A.cer'] = '-----BEGIN PUBLIC KEY-----\r\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApIXej3SC/TE/QeR34uKd\r\nf7FYgIVvYGBLQM4ZcgcR0mTxcsnjx6IK8l1Rq5+Kyu7bsQQc43KejA5Th8aGqVAF\r\nM8h/WQIw5NfzZ1/qLmeDmyGdzxjjputzbZS85TNE3XvyJf1L4E+dV+OyCePdux2U\r\n1izhdbkJfU5wVqPB4wVmls1vbKaPO2k7/AQWhx7YHHzU0Io5ztAV5E8KpMS+nabU\r\nvDOCzRQYFQgBb88z995BajRraljAT5BZp59i6BzGkWY5FTegbI037cjl/zD7Y9Uv\r\naaHK+tZRdFJzNex2vI9jzx9tUH/ivNRcHou0QLwWesKoOswuZfSrvYoqBg8a0FIv\r\nwwIDAQAB\r\n-----END PUBLIC KEY-----\r\n';


/*
 Copyright (c) 2010, Linden Research, Inc.
 Copyright (c) 2014, Joshua Bell

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 $/LicenseInfo$
 */

// Original can be found at:
//   https://bitbucket.org/lindenlab/llsd
// Modifications by Joshua Bell inexorabletash@gmail.com
//   https://github.com/inexorabletash/polyfill

// ES3/ES5 implementation of the Krhonos Typed Array Specification
//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/
//   Date: 2011-02-01
//
// Variations:
//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])
//  * Gradually migrating structure from Khronos spec to ES6 spec

if (!self.ArrayBuffer) {
  (function (global) {
    'use strict';
    var undefined = (void 0); // Paranoia

    // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
    // create, and consume so much memory, that the browser appears frozen.
    var MAX_ARRAY_LENGTH = 1e5;

    // Approximations of internal ECMAScript conversion functions
    function Type(v) {
      switch (typeof v) {
        case 'undefined':
          return 'undefined';
        case 'boolean':
          return 'boolean';
        case 'number':
          return 'number';
        case 'string':
          return 'string';
        default:
          return v === null ? 'null' : 'object';
      }
    }

    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
    function Class(v) {
      return Object.prototype.toString.call(v).replace(/^\[object *|\]$/g, '');
    }

    function IsCallable(o) {
      return typeof o === 'function';
    }

    function ToObject(v) {
      if (v === null || v === undefined) throw TypeError();
      return Object(v);
    }

    function ToInt32(v) {
      return v >> 0;
    }

    function ToUint32(v) {
      return v >>> 0;
    }

    // Snapshot intrinsics
    var LN2 = Math.LN2,
        abs = Math.abs,
        floor = Math.floor,
        log = Math.log,
        max = Math.max,
        min = Math.min,
        pow = Math.pow,
        round = Math.round;

    // emulate ES5 getter/setter API using legacy APIs
    // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
    // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
    // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)

    (function () {
      var orig = Object.defineProperty;
      var dom_only = !(function () {
        try {
          return Object.defineProperty({}, 'x', {});
        } catch (_) {
          return false;
        }
      }());

      if (!orig || dom_only) {
        Object.defineProperty = function (o, prop, desc) {
          // In IE8 try built-in implementation for defining properties on DOM prototypes.
          if (orig)
            try {
              return orig(o, prop, desc);
            } catch (_) {
            }
          if (o !== Object(o))
            throw TypeError('Object.defineProperty called on non-object');
          if (Object.prototype.__defineGetter__ && ('get' in desc))
            Object.prototype.__defineGetter__.call(o, prop, desc.get);
          if (Object.prototype.__defineSetter__ && ('set' in desc))
            Object.prototype.__defineSetter__.call(o, prop, desc.set);
          if ('value' in desc)
            o[prop] = desc.value;
          return o;
        };
      }
    }());

    // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
    // for index in 0 ... obj.length
    function makeArrayAccessors(obj) {
      if (obj.length > MAX_ARRAY_LENGTH) throw RangeError('Array too large for polyfill');

      function makeArrayAccessor(index) {
        Object.defineProperty(obj, index, {
          'get': function () {
            return obj._getter(index);
          },
          'set': function (v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }

      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }

    // Internal conversion functions:
    //    pack<Type>()   - take a number (interpreted as Type), output a byte array
    //    unpack<Type>() - take a byte array, output a Type-like number

    function as_signed(value, bits) {
      var s = 32 - bits;
      return (value << s) >> s;
    }

    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return (value << s) >>> s;
    }

    function packI8(n) {
      return [n & 0xff];
    }

    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }

    function packU8(n) {
      return [n & 0xff];
    }

    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }

    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff];
    }

    function packI16(n) {
      return [n & 0xff, (n >> 8) & 0xff];
    }

    function unpackI16(bytes) {
      return as_signed(bytes[1] << 8 | bytes[0], 16);
    }

    function packU16(n) {
      return [n & 0xff, (n >> 8) & 0xff];
    }

    function unpackU16(bytes) {
      return as_unsigned(bytes[1] << 8 | bytes[0], 16);
    }

    function packI32(n) {
      return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff];
    }

    function unpackI32(bytes) {
      return as_signed(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32);
    }

    function packU32(n) {
      return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff];
    }

    function unpackU32(bytes) {
      return as_unsigned(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32);
    }

    function packIEEE754(v, ebits, fbits) {

      var bias = (1 << (ebits - 1)) - 1,
          s, e, f, ln,
          i, bits, str, bytes;

      function roundToEven(n) {
        var w = floor(n), f = n - w;
        if (f < 0.5)
          return w;
        if (f > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }

      // Compute sign, exponent, fraction
      if (v !== v) {
        // NaN
        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = (v < 0) ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = (1 / v === -Infinity) ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);

        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          var significand = v / pow(2, e);
          if (significand < 1) {
            e -= 1;
            significand *= 2;
          }
          if (significand >= 2) {
            e += 1;
            significand /= 2;
          }
          f = roundToEven(significand * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            // Overflow
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            // Normalized
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          // Denormalized
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }

      // Pack sign, exponent, fraction
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join('');

      // Bits to bytes
      bytes = [];
      while (str.length) {
        bytes.unshift(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }

    function unpackIEEE754(bytes, ebits, fbits) {
      // Bytes to bits
      var bits = [], i, j, b, str,
          bias, s, e, f;

      for (i = 0; i < bytes.length; ++i) {
        b = bytes[i];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join('');

      // Unpack sign, exponent, fraction
      bias = (1 << (ebits - 1)) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);

      // Produce number
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        // Normalized
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        // Denormalized
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }

    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }

    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }

    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }

    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }

    //
    // 3 The ArrayBuffer Type
    //

    (function () {

      function ArrayBuffer(length) {
        length = ToInt32(length);
        if (length < 0) throw RangeError('ArrayBuffer size is not a small enough positive integer.');
        Object.defineProperty(this, 'byteLength', {value: length});
        Object.defineProperty(this, '_bytes', {value: Array(length)});

        for (var i = 0; i < length; i += 1)
          this._bytes[i] = 0;
      }

      global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;

      //
      // 5 The Typed Array View Types
      //

      function $TypedArray$() {

        // %TypedArray% ( length )
        if (!arguments.length || typeof arguments[0] !== 'object') {
          return (function (length) {
            length = ToInt32(length);
            if (length < 0) throw RangeError('length is not a small enough positive integer.');
            Object.defineProperty(this, 'length', {value: length});
            Object.defineProperty(this, 'byteLength', {value: length * this.BYTES_PER_ELEMENT});
            Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(this.byteLength)});
            Object.defineProperty(this, 'byteOffset', {value: 0});

          }).apply(this, arguments);
        }

        // %TypedArray% ( typedArray )
        if (arguments.length >= 1 &&
            Type(arguments[0]) === 'object' &&
            arguments[0] instanceof $TypedArray$) {
          return (function (typedArray) {
            if (this.constructor !== typedArray.constructor) throw TypeError();

            var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;
            Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});
            Object.defineProperty(this, 'byteLength', {value: byteLength});
            Object.defineProperty(this, 'byteOffset', {value: 0});
            Object.defineProperty(this, 'length', {value: typedArray.length});

            for (var i = 0; i < this.length; i += 1)
              this._setter(i, typedArray._getter(i));

          }).apply(this, arguments);
        }

        // %TypedArray% ( array )
        if (arguments.length >= 1 &&
            Type(arguments[0]) === 'object' && !(arguments[0] instanceof $TypedArray$) && !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {
          return (function (array) {

            var byteLength = array.length * this.BYTES_PER_ELEMENT;
            Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});
            Object.defineProperty(this, 'byteLength', {value: byteLength});
            Object.defineProperty(this, 'byteOffset', {value: 0});
            Object.defineProperty(this, 'length', {value: array.length});

            for (var i = 0; i < this.length; i += 1) {
              var s = array[i];
              this._setter(i, Number(s));
            }
          }).apply(this, arguments);
        }

        // %TypedArray% ( buffer, byteOffset=0, length=undefined )
        if (arguments.length >= 1 &&
            Type(arguments[0]) === 'object' &&
            (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {
          return (function (buffer, byteOffset, length) {

            byteOffset = ToUint32(byteOffset);
            if (byteOffset > buffer.byteLength)
              throw RangeError('byteOffset out of range');

            // The given byteOffset must be a multiple of the element
            // size of the specific type, otherwise an exception is raised.
            if (byteOffset % this.BYTES_PER_ELEMENT)
              throw RangeError('buffer length minus the byteOffset is not a multiple of the element size.');

            if (length === undefined) {
              var byteLength = buffer.byteLength - byteOffset;
              if (byteLength % this.BYTES_PER_ELEMENT)
                throw RangeError('length of buffer minus byteOffset not a multiple of the element size');
              length = byteLength / this.BYTES_PER_ELEMENT;

            } else {
              length = ToUint32(length);
              byteLength = length * this.BYTES_PER_ELEMENT;
            }

            if ((byteOffset + byteLength) > buffer.byteLength)
              throw RangeError('byteOffset and length reference an area beyond the end of the buffer');

            Object.defineProperty(this, 'buffer', {value: buffer});
            Object.defineProperty(this, 'byteLength', {value: byteLength});
            Object.defineProperty(this, 'byteOffset', {value: byteOffset});
            Object.defineProperty(this, 'length', {value: length});

          }).apply(this, arguments);
        }

        // %TypedArray% ( all other argument combinations )
        throw TypeError();
      }

      // Properties of the %TypedArray Instrinsic Object

      // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )
      Object.defineProperty($TypedArray$, 'from', {
        value: function (iterable) {
          return new this(iterable);
        }
      });

      // %TypedArray%.of ( ...items )
      Object.defineProperty($TypedArray$, 'of', {
        value: function (/*...items*/) {
          return new this(arguments);
        }
      });

      // %TypedArray%.prototype
      var $TypedArrayPrototype$ = {};
      $TypedArray$.prototype = $TypedArrayPrototype$;

      // WebIDL: getter type (unsigned long index);
      Object.defineProperty($TypedArray$.prototype, '_getter', {
        value: function (index) {
          if (arguments.length < 1) throw SyntaxError('Not enough arguments');

          index = ToUint32(index);
          if (index >= this.length)
            return undefined;

          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        }
      });

      // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
      Object.defineProperty($TypedArray$.prototype, 'get', {value: $TypedArray$.prototype._getter});

      // WebIDL: setter void (unsigned long index, type value);
      Object.defineProperty($TypedArray$.prototype, '_setter', {
        value: function (index, value) {
          if (arguments.length < 2) throw SyntaxError('Not enough arguments');

          index = ToUint32(index);
          if (index >= this.length)
            return;

          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        }
      });

      // get %TypedArray%.prototype.buffer
      // get %TypedArray%.prototype.byteLength
      // get %TypedArray%.prototype.byteOffset
      // -- applied directly to the object in the constructor

      // %TypedArray%.prototype.constructor
      Object.defineProperty($TypedArray$.prototype, 'constructor', {value: $TypedArray$});

      // %TypedArray%.prototype.copyWithin (target, start, end = this.length )
      Object.defineProperty($TypedArray$.prototype, 'copyWithin', {
        value: function (target, start) {
          var end = arguments[2];

          var o = ToObject(this);
          var lenVal = o.length;
          var len = ToUint32(lenVal);
          len = max(len, 0);
          var relativeTarget = ToInt32(target);
          var to;
          if (relativeTarget < 0)
            to = max(len + relativeTarget, 0);
          else
            to = min(relativeTarget, len);
          var relativeStart = ToInt32(start);
          var from;
          if (relativeStart < 0)
            from = max(len + relativeStart, 0);
          else
            from = min(relativeStart, len);
          var relativeEnd;
          if (end === undefined)
            relativeEnd = len;
          else
            relativeEnd = ToInt32(end);
          var final;
          if (relativeEnd < 0)
            final = max(len + relativeEnd, 0);
          else
            final = min(relativeEnd, len);
          var count = min(final - from, len - to);
          var direction;
          if (from < to && to < from + count) {
            direction = -1;
            from = from + count - 1;
            to = to + count - 1;
          } else {
            direction = 1;
          }
          while (count > 0) {
            o._setter(to, o._getter(from));
            from = from + direction;
            to = to + direction;
            count = count - 1;
          }
          return o;
        }
      });

      // %TypedArray%.prototype.entries ( )
      // -- defined in es6.js to shim browsers w/ native TypedArrays

      // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'every', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          var thisArg = arguments[1];
          for (var i = 0; i < len; i++) {
            if (!callbackfn.call(thisArg, t._getter(i), i, t))
              return false;
          }
          return true;
        }
      });

      // %TypedArray%.prototype.fill (value, start = 0, end = this.length )
      Object.defineProperty($TypedArray$.prototype, 'fill', {
        value: function (value) {
          var start = arguments[1],
              end = arguments[2];

          var o = ToObject(this);
          var lenVal = o.length;
          var len = ToUint32(lenVal);
          len = max(len, 0);
          var relativeStart = ToInt32(start);
          var k;
          if (relativeStart < 0)
            k = max((len + relativeStart), 0);
          else
            k = min(relativeStart, len);
          var relativeEnd;
          if (end === undefined)
            relativeEnd = len;
          else
            relativeEnd = ToInt32(end);
          var final;
          if (relativeEnd < 0)
            final = max((len + relativeEnd), 0);
          else
            final = min(relativeEnd, len);
          while (k < final) {
            o._setter(k, value);
            k += 1;
          }
          return o;
        }
      });

      // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'filter', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          var res = [];
          var thisp = arguments[1];
          for (var i = 0; i < len; i++) {
            var val = t._getter(i); // in case fun mutates this
            if (callbackfn.call(thisp, val, i, t))
              res.push(val);
          }
          return new this.constructor(res);
        }
      });

      // %TypedArray%.prototype.find (predicate, thisArg = undefined)
      Object.defineProperty($TypedArray$.prototype, 'find', {
        value: function (predicate) {
          var o = ToObject(this);
          var lenValue = o.length;
          var len = ToUint32(lenValue);
          if (!IsCallable(predicate)) throw TypeError();
          var t = arguments.length > 1 ? arguments[1] : undefined;
          var k = 0;
          while (k < len) {
            var kValue = o._getter(k);
            var testResult = predicate.call(t, kValue, k, o);
            if (Boolean(testResult))
              return kValue;
            ++k;
          }
          return undefined;
        }
      });

      // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'findIndex', {
        value: function (predicate) {
          var o = ToObject(this);
          var lenValue = o.length;
          var len = ToUint32(lenValue);
          if (!IsCallable(predicate)) throw TypeError();
          var t = arguments.length > 1 ? arguments[1] : undefined;
          var k = 0;
          while (k < len) {
            var kValue = o._getter(k);
            var testResult = predicate.call(t, kValue, k, o);
            if (Boolean(testResult))
              return k;
            ++k;
          }
          return -1;
        }
      });

      // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'forEach', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          var thisp = arguments[1];
          for (var i = 0; i < len; i++)
            callbackfn.call(thisp, t._getter(i), i, t);
        }
      });

      // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )
      Object.defineProperty($TypedArray$.prototype, 'indexOf', {
        value: function (searchElement) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (len === 0) return -1;
          var n = 0;
          if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n !== n) {
              n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
              n = (n > 0 || -1) * floor(abs(n));
            }
          }
          if (n >= len) return -1;
          var k = n >= 0 ? n : max(len - abs(n), 0);
          for (; k < len; k++) {
            if (t._getter(k) === searchElement) {
              return k;
            }
          }
          return -1;
        }
      });

      // %TypedArray%.prototype.join ( separator )
      Object.defineProperty($TypedArray$.prototype, 'join', {
        value: function (separator) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          var tmp = Array(len);
          for (var i = 0; i < len; ++i)
            tmp[i] = t._getter(i);
          return tmp.join(separator === undefined ? ',' : separator); // Hack for IE7
        }
      });

      // %TypedArray%.prototype.keys ( )
      // -- defined in es6.js to shim browsers w/ native TypedArrays

      // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )
      Object.defineProperty($TypedArray$.prototype, 'lastIndexOf', {
        value: function (searchElement) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (len === 0) return -1;
          var n = len;
          if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n !== n) {
              n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
              n = (n > 0 || -1) * floor(abs(n));
            }
          }
          var k = n >= 0 ? min(n, len - 1) : len - abs(n);
          for (; k >= 0; k--) {
            if (t._getter(k) === searchElement)
              return k;
          }
          return -1;
        }
      });

      // get %TypedArray%.prototype.length
      // -- applied directly to the object in the constructor

      // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'map', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          var res = [];
          res.length = len;
          var thisp = arguments[1];
          for (var i = 0; i < len; i++)
            res[i] = callbackfn.call(thisp, t._getter(i), i, t);
          return new this.constructor(res);
        }
      });

      // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )
      Object.defineProperty($TypedArray$.prototype, 'reduce', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          // no value to return if no initial value and an empty array
          if (len === 0 && arguments.length === 1) throw TypeError();
          var k = 0;
          var accumulator;
          if (arguments.length >= 2) {
            accumulator = arguments[1];
          } else {
            accumulator = t._getter(k++);
          }
          while (k < len) {
            accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);
            k++;
          }
          return accumulator;
        }
      });

      // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )
      Object.defineProperty($TypedArray$.prototype, 'reduceRight', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          // no value to return if no initial value, empty array
          if (len === 0 && arguments.length === 1) throw TypeError();
          var k = len - 1;
          var accumulator;
          if (arguments.length >= 2) {
            accumulator = arguments[1];
          } else {
            accumulator = t._getter(k--);
          }
          while (k >= 0) {
            accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);
            k--;
          }
          return accumulator;
        }
      });

      // %TypedArray%.prototype.reverse ( )
      Object.defineProperty($TypedArray$.prototype, 'reverse', {
        value: function () {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          var half = floor(len / 2);
          for (var i = 0, j = len - 1; i < half; ++i, --j) {
            var tmp = t._getter(i);
            t._setter(i, t._getter(j));
            t._setter(j, tmp);
          }
          return t;
        }
      });

      // %TypedArray%.prototype.set(array, offset = 0 )
      // %TypedArray%.prototype.set(typedArray, offset = 0 )
      // WebIDL: void set(TypedArray array, optional unsigned long offset);
      // WebIDL: void set(sequence<type> array, optional unsigned long offset);
      Object.defineProperty($TypedArray$.prototype, 'set', {
        value: function (index, value) {
          if (arguments.length < 1) throw SyntaxError('Not enough arguments');
          var array, sequence, offset, len,
              i, s, d,
              byteOffset, byteLength, tmp;

          if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
            // void set(TypedArray array, optional unsigned long offset);
            array = arguments[0];
            offset = ToUint32(arguments[1]);

            if (offset + array.length > this.length) {
              throw RangeError('Offset plus length of array is out of range');
            }

            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;

            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset;
                   i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
            // void set(sequence<type> array, optional unsigned long offset);
            sequence = arguments[0];
            len = ToUint32(sequence.length);
            offset = ToUint32(arguments[1]);

            if (offset + len > this.length) {
              throw RangeError('Offset plus length of array is out of range');
            }

            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw TypeError('Unexpected argument type(s)');
          }
        }
      });

      // %TypedArray%.prototype.slice ( start, end )
      Object.defineProperty($TypedArray$.prototype, 'slice', {
        value: function (start, end) {
          var o = ToObject(this);
          var lenVal = o.length;
          var len = ToUint32(lenVal);
          var relativeStart = ToInt32(start);
          var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);
          var relativeEnd = (end === undefined) ? len : ToInt32(end);
          var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);
          var count = final - k;
          var c = o.constructor;
          var a = new c(count);
          var n = 0;
          while (k < final) {
            var kValue = o._getter(k);
            a._setter(n, kValue);
            ++k;
            ++n;
          }
          return a;
        }
      });

      // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )
      Object.defineProperty($TypedArray$.prototype, 'some', {
        value: function (callbackfn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          if (!IsCallable(callbackfn)) throw TypeError();
          var thisp = arguments[1];
          for (var i = 0; i < len; i++) {
            if (callbackfn.call(thisp, t._getter(i), i, t)) {
              return true;
            }
          }
          return false;
        }
      });

      // %TypedArray%.prototype.sort ( comparefn )
      Object.defineProperty($TypedArray$.prototype, 'sort', {
        value: function (comparefn) {
          if (this === undefined || this === null) throw TypeError();
          var t = Object(this);
          var len = ToUint32(t.length);
          var tmp = Array(len);
          for (var i = 0; i < len; ++i)
            tmp[i] = t._getter(i);
          if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9
          for (i = 0; i < len; ++i)
            t._setter(i, tmp[i]);
          return t;
        }
      });

      // %TypedArray%.prototype.subarray(begin = 0, end = this.length )
      // WebIDL: TypedArray subarray(long begin, optional long end);
      Object.defineProperty($TypedArray$.prototype, 'subarray', {
        value: function (start, end) {
          function clamp(v, min, max) {
            return v < min ? min : v > max ? max : v;
          }

          start = ToInt32(start);
          end = ToInt32(end);

          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }

          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }

          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);

          var len = end - start;
          if (len < 0) {
            len = 0;
          }

          return new this.constructor(
              this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
        }
      });

      // %TypedArray%.prototype.toLocaleString ( )
      // %TypedArray%.prototype.toString ( )
      // %TypedArray%.prototype.values ( )
      // %TypedArray%.prototype [ @@iterator ] ( )
      // get %TypedArray%.prototype [ @@toStringTag ]
      // -- defined in es6.js to shim browsers w/ native TypedArrays

      function makeTypedArray(elementSize, pack, unpack) {
        // Each TypedArray type requires a distinct constructor instance with
        // identical logic, which this produces.
        var TypedArray = function () {
          Object.defineProperty(this, 'constructor', {value: TypedArray});
          $TypedArray$.apply(this, arguments);
          makeArrayAccessors(this);
        };
        if ('__proto__' in TypedArray) {
          TypedArray.__proto__ = $TypedArray$;
        } else {
          TypedArray.from = $TypedArray$.from;
          TypedArray.of = $TypedArray$.of;
        }

        TypedArray.BYTES_PER_ELEMENT = elementSize;

        var TypedArrayPrototype = function () {
        };
        TypedArrayPrototype.prototype = $TypedArrayPrototype$;

        TypedArray.prototype = new TypedArrayPrototype();

        Object.defineProperty(TypedArray.prototype, 'BYTES_PER_ELEMENT', {value: elementSize});
        Object.defineProperty(TypedArray.prototype, '_pack', {value: pack});
        Object.defineProperty(TypedArray.prototype, '_unpack', {value: unpack});

        return TypedArray;
      }

      var Int8Array = makeTypedArray(1, packI8, unpackI8);
      var Uint8Array = makeTypedArray(1, packU8, unpackU8);
      var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);
      var Int16Array = makeTypedArray(2, packI16, unpackI16);
      var Uint16Array = makeTypedArray(2, packU16, unpackU16);
      var Int32Array = makeTypedArray(4, packI32, unpackI32);
      var Uint32Array = makeTypedArray(4, packU32, unpackU32);
      var Float32Array = makeTypedArray(4, packF32, unpackF32);
      var Float64Array = makeTypedArray(8, packF64, unpackF64);

      global.Int8Array = global.Int8Array || Int8Array;
      global.Uint8Array = global.Uint8Array || Uint8Array;
      global.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;
      global.Int16Array = global.Int16Array || Int16Array;
      global.Uint16Array = global.Uint16Array || Uint16Array;
      global.Int32Array = global.Int32Array || Int32Array;
      global.Uint32Array = global.Uint32Array || Uint32Array;
      global.Float32Array = global.Float32Array || Float32Array;
      global.Float64Array = global.Float64Array || Float64Array;
    }());

    //
    // 6 The DataView View Type
    //

    (function () {
      function r(array, index) {
        return IsCallable(array.get) ? array.get(index) : array[index];
      }

      var IS_BIG_ENDIAN = (function () {
        var u16array = new Uint16Array([0x1234]),
            u8array = new Uint8Array(u16array.buffer);
        return r(u8array, 0) === 0x12;
      }());

      // DataView(buffer, byteOffset=0, byteLength=undefined)
      // WebIDL: Constructor(ArrayBuffer buffer,
      //                     optional unsigned long byteOffset,
      //                     optional unsigned long byteLength)
      function DataView(buffer, byteOffset, byteLength) {
        if (!(buffer instanceof ArrayBuffer || Class(buffer) === 'ArrayBuffer')) throw TypeError();

        byteOffset = ToUint32(byteOffset);
        if (byteOffset > buffer.byteLength)
          throw RangeError('byteOffset out of range');

        if (byteLength === undefined)
          byteLength = buffer.byteLength - byteOffset;
        else
          byteLength = ToUint32(byteLength);

        if ((byteOffset + byteLength) > buffer.byteLength)
          throw RangeError('byteOffset and length reference an area beyond the end of the buffer');

        Object.defineProperty(this, 'buffer', {value: buffer});
        Object.defineProperty(this, 'byteLength', {value: byteLength});
        Object.defineProperty(this, 'byteOffset', {value: byteOffset});
      };

      // get DataView.prototype.buffer
      // get DataView.prototype.byteLength
      // get DataView.prototype.byteOffset
      // -- applied directly to instances by the constructor

      function makeGetter(arrayType) {
        return function GetViewValue(byteOffset, littleEndian) {
          byteOffset = ToUint32(byteOffset);

          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
            throw RangeError('Array index out of range');

          byteOffset += this.byteOffset;

          var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
              bytes = [];
          for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
            bytes.push(r(uint8Array, i));

          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))
            bytes.reverse();

          return r(new arrayType(new Uint8Array(bytes).buffer), 0);
        };
      }

      Object.defineProperty(DataView.prototype, 'getUint8', {value: makeGetter(Uint8Array)});
      Object.defineProperty(DataView.prototype, 'getInt8', {value: makeGetter(Int8Array)});
      Object.defineProperty(DataView.prototype, 'getUint16', {value: makeGetter(Uint16Array)});
      Object.defineProperty(DataView.prototype, 'getInt16', {value: makeGetter(Int16Array)});
      Object.defineProperty(DataView.prototype, 'getUint32', {value: makeGetter(Uint32Array)});
      Object.defineProperty(DataView.prototype, 'getInt32', {value: makeGetter(Int32Array)});
      Object.defineProperty(DataView.prototype, 'getFloat32', {value: makeGetter(Float32Array)});
      Object.defineProperty(DataView.prototype, 'getFloat64', {value: makeGetter(Float64Array)});

      function makeSetter(arrayType) {
        return function SetViewValue(byteOffset, value, littleEndian) {
          byteOffset = ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
            throw RangeError('Array index out of range');

          // Get bytes
          var typeArray = new arrayType([value]),
              byteArray = new Uint8Array(typeArray.buffer),
              bytes = [], i, byteView;

          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
            bytes.push(r(byteArray, i));

          // Flip if necessary
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))
            bytes.reverse();

          // Write them
          byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }

      Object.defineProperty(DataView.prototype, 'setUint8', {value: makeSetter(Uint8Array)});
      Object.defineProperty(DataView.prototype, 'setInt8', {value: makeSetter(Int8Array)});
      Object.defineProperty(DataView.prototype, 'setUint16', {value: makeSetter(Uint16Array)});
      Object.defineProperty(DataView.prototype, 'setInt16', {value: makeSetter(Int16Array)});
      Object.defineProperty(DataView.prototype, 'setUint32', {value: makeSetter(Uint32Array)});
      Object.defineProperty(DataView.prototype, 'setInt32', {value: makeSetter(Int32Array)});
      Object.defineProperty(DataView.prototype, 'setFloat32', {value: makeSetter(Float32Array)});
      Object.defineProperty(DataView.prototype, 'setFloat64', {value: makeSetter(Float64Array)});

      global.DataView = global.DataView || DataView;

    }());

  }(this));
}

/*
    json2.js
    2015-05-03

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse. This file is provides the ES5 JSON capability to ES3 systems.
    If a project might run on IE8 or earlier, then this file should be included.
    This file does nothing on ES5 systems.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 
                            ? '0' + n 
                            : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date 
                    ? 'Date(' + this[key] + ')' 
                    : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint 
    eval, for, this 
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';
    
    var rx_one = /^[\],:{}\s]*$/,
        rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
        rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        rx_four = /(?:^|:|,)(?:\s*\[)+/g,
        rx_escapable = /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 
            ? '0' + n 
            : n;
    }
    
    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + '-' +
                        f(this.getUTCMonth() + 1) + '-' +
                        f(this.getUTCDate()) + 'T' +
                        f(this.getUTCHours()) + ':' +
                        f(this.getUTCMinutes()) + ':' +
                        f(this.getUTCSeconds()) + 'Z'
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap,
        indent,
        meta,
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string) 
            ? '"' + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string'
                    ? c
                    : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' 
            : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) 
                ? String(value) 
                : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                        ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                        : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap 
                                    ? ': ' 
                                    : ':'
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap 
                                    ? ': ' 
                                    : ':'
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                    ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                    : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return '\\u' +
                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, '@')
                        .replace(rx_three, ']')
                        .replace(rx_four, '')
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

if (!self.btoa) {
    var Base64 = {
        // private property
        _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

        // public method for encoding
        encode : function (input, utf8) {
            var output = "";
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
            var i = 0;

            if (utf8) {
                input = Base64._utf8_encode(input);
            }

            while (i < input.length) {

                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output +
                    Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
                    Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);

            }

            return output;
        },

        // public method for decoding
        decode : function (input, utf8) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            while (i < input.length) {

                enc1 = Base64._keyStr.indexOf(input.charAt(i++));
                enc2 = Base64._keyStr.indexOf(input.charAt(i++));
                enc3 = Base64._keyStr.indexOf(input.charAt(i++));
                enc4 = Base64._keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }

            }

            if (utf8) {
                output = Base64._utf8_decode(output);
            }


            return output;

        },

// private method for UTF-8 encoding
        _utf8_encode : function (string) {
            string = string.replace(/\r\n/g,"\n");
            var utftext = "";

            for (var n = 0; n < string.length; n++) {

                var c = string.charCodeAt(n);

                if (c < 128) {
                    utftext += String.fromCharCode(c);
                }
                else if((c > 127) && (c < 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c & 63) | 128);
                }
                else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                    utftext += String.fromCharCode((c & 63) | 128);
                }

            }

            return utftext;
        },

        // private method for UTF-8 decoding
        _utf8_decode : function (utftext) {
            var string = "";
            var i = 0;
            var c = c1 = c2 = 0;

            while ( i < utftext.length ) {

                c = utftext.charCodeAt(i);

                if (c < 128) {
                    string += String.fromCharCode(c);
                    i++;
                }
                else if((c > 191) && (c < 224)) {
                    c2 = utftext.charCodeAt(i+1);
                    string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                    i += 2;
                }
                else {
                    c2 = utftext.charCodeAt(i+1);
                    c3 = utftext.charCodeAt(i+2);
                    string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                    i += 3;
                }

            }
            return string;
        }
    }

    self.btoa = Base64.encode;
    self.atob = Base64.decode;
}
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.PriorityQueue=t()}}(function(){return function t(e,i,r){function o(n,s){if(!i[n]){if(!e[n]){var u="function"==typeof require&&require;if(!s&&u)return u(n,!0);if(a)return a(n,!0);var h=new Error("Cannot find module '"+n+"'");throw h.code="MODULE_NOT_FOUND",h}var p=i[n]={exports:{}};e[n][0].call(p.exports,function(t){var i=e[n][1][t];return o(i?i:t)},p,p.exports,t,e,i,r)}return i[n].exports}for(var a="function"==typeof require&&require,n=0;n<r.length;n++)o(r[n]);return o}({1:[function(t,e,i){var r,o,a,n,s,u={}.hasOwnProperty,h=function(t,e){function i(){this.constructor=t}for(var r in e)u.call(e,r)&&(t[r]=e[r]);return i.prototype=e.prototype,t.prototype=new i,t.__super__=e.prototype,t};r=t("./PriorityQueue/AbstractPriorityQueue"),o=t("./PriorityQueue/ArrayStrategy"),n=t("./PriorityQueue/BinaryHeapStrategy"),a=t("./PriorityQueue/BHeapStrategy"),s=function(t){function e(t){t||(t={}),t.strategy||(t.strategy=n),t.comparator||(t.comparator=function(t,e){return(t||0)-(e||0)}),e.__super__.constructor.call(this,t)}return h(e,t),e}(r),s.ArrayStrategy=o,s.BinaryHeapStrategy=n,s.BHeapStrategy=a,e.exports=s},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(t,e,i){var r;e.exports=r=function(){function t(t){if(null==(null!=t?t.strategy:void 0))throw"Must pass options.strategy, a strategy";if(null==(null!=t?t.comparator:void 0))throw"Must pass options.comparator, a comparator";this.priv=new t.strategy(t),this.length=0}return t.prototype.queue=function(t){return this.length++,void this.priv.queue(t)},t.prototype.dequeue=function(t){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},t.prototype.peek=function(t){if(!this.length)throw"Empty queue";return this.priv.peek()},t.prototype.clear=function(){return this.length=0,this.priv.clear()},t}()},{}],3:[function(t,e,i){var r,o;o=function(t,e,i){var r,o,a;for(o=0,r=t.length;r>o;)a=o+r>>>1,i(t[a],e)>=0?o=a+1:r=a;return o},e.exports=r=function(){function t(t){var e;this.options=t,this.comparator=this.options.comparator,this.data=(null!=(e=this.options.initialValues)?e.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return t.prototype.queue=function(t){var e;return e=o(this.data,t,this.comparator),void this.data.splice(e,0,t)},t.prototype.dequeue=function(){return this.data.pop()},t.prototype.peek=function(){return this.data[this.data.length-1]},t.prototype.clear=function(){return void(this.data.length=0)},t}()},{}],4:[function(t,e,i){var r;e.exports=r=function(){function t(t){var e,i,r,o,a,n,s,u,h;for(this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.pageSize=(null!=t?t.pageSize:void 0)||512,this.length=0,r=0;1<<r<this.pageSize;)r+=1;if(1<<r!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=r,this._emptyMemoryPageTemplate=e=[],i=a=0,u=this.pageSize;u>=0?u>a:a>u;i=u>=0?++a:--a)e.push(null);if(this._memory=[],this._mask=this.pageSize-1,t.initialValues)for(h=t.initialValues,n=0,s=h.length;s>n;n++)o=h[n],this.queue(o)}return t.prototype.queue=function(t){return this.length+=1,this._write(this.length,t),void this._bubbleUp(this.length,t)},t.prototype.dequeue=function(){var t,e;return t=this._read(1),e=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,e),this._bubbleDown(1,e)),t},t.prototype.peek=function(){return this._read(1)},t.prototype.clear=function(){return this.length=0,void(this._memory.length=0)},t.prototype._write=function(t,e){var i;for(i=t>>this._shift;i>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[i][t&this._mask]=e},t.prototype._read=function(t){return this._memory[t>>this._shift][t&this._mask]},t.prototype._bubbleUp=function(t,e){var i,r,o,a;for(i=this.comparator;t>1&&(r=t&this._mask,t<this.pageSize||r>3?o=t&~this._mask|r>>1:2>r?(o=t-this.pageSize>>this._shift,o+=o&~(this._mask>>1),o|=this.pageSize>>1):o=t-2,a=this._read(o),!(i(a,e)<0));)this._write(o,e),this._write(t,a),t=o;return void 0},t.prototype._bubbleDown=function(t,e){var i,r,o,a,n;for(n=this.comparator;t<this.length;)if(t>this._mask&&!(t&this._mask-1)?i=r=t+2:t&this.pageSize>>1?(i=(t&~this._mask)>>1,i|=t&this._mask>>1,i=i+1<<this._shift,r=i+1):(i=t+(t&this._mask),r=i+1),i!==r&&r<=this.length)if(o=this._read(i),a=this._read(r),n(o,e)<0&&n(o,a)<=0)this._write(i,e),this._write(t,o),t=i;else{if(!(n(a,e)<0))break;this._write(r,e),this._write(t,a),t=r}else{if(!(i<=this.length))break;if(o=this._read(i),!(n(o,e)<0))break;this._write(i,e),this._write(t,o),t=i}return void 0},t}()},{}],5:[function(t,e,i){var r;e.exports=r=function(){function t(t){var e;this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.length=0,this.data=(null!=(e=t.initialValues)?e.slice(0):void 0)||[],this._heapify()}return t.prototype._heapify=function(){var t,e,i;if(this.data.length>0)for(t=e=1,i=this.data.length;i>=1?i>e:e>i;t=i>=1?++e:--e)this._bubbleUp(t);return void 0},t.prototype.queue=function(t){return this.data.push(t),void this._bubbleUp(this.data.length-1)},t.prototype.dequeue=function(){var t,e;return e=this.data[0],t=this.data.pop(),this.data.length>0&&(this.data[0]=t,this._bubbleDown(0)),e},t.prototype.peek=function(){return this.data[0]},t.prototype.clear=function(){return this.length=0,void(this.data.length=0)},t.prototype._bubbleUp=function(t){for(var e,i;t>0&&(e=t-1>>>1,this.comparator(this.data[t],this.data[e])<0);)i=this.data[e],this.data[e]=this.data[t],this.data[t]=i,t=e;return void 0},t.prototype._bubbleDown=function(t){var e,i,r,o,a;for(e=this.data.length-1;;){if(i=(t<<1)+1,o=i+1,r=t,e>=i&&this.comparator(this.data[i],this.data[r])<0&&(r=i),e>=o&&this.comparator(this.data[o],this.data[r])<0&&(r=o),r===t)break;a=this.data[r],this.data[r]=this.data[t],this.data[t]=a,t=r}return void 0},t}()},{}]},{},[1])(1)});
/*
 Leaflet 0.8-dev (8f3a353), a JS library for interactive maps. http://leafletjs.com
 (c) 2010-2015 Vladimir Agafonkin, (c) 2010-2011 CloudMade
*/
(function (window, document, undefined) {
var L = {
	version: '0.8-dev'
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	// extend an object with properties of one or more other objects
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// create an object from a given prototype
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// bind a function to be called with a given context
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// return unique ID of an object
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	lastId: 0,

	// return a function that won't be called more often than the given interval
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// wrap the given number to lie within a certain range (used for wrapping longitude)
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// do nothing (used as a noop throughout the code)
	falseFn: function () { return false; },

	// round a given number to a given precision
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// trim whitespace from both sides of a string
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// split a string into words
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// set options to an object, inheriting parent's options as well
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// make a URL with GET parameters out of a set of properties/values
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// super-simple templating facility, used for TileLayer URLs
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_]+) *\}/g,

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// minimal image URI, set to an image when disposing to flush memory
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Evented is a base class that Leaflet classes inherit from to handle custom events.
 */

L.Evented = L.Class.extend({

	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {

		var events = this._events = this._events || {},
		    contextId = context && context !== this && L.stamp(context);

		if (contextId) {
			// store listeners with custom context in a separate hash (if it has an id);
			// gives a major performance boost when firing and removing events (e.g. on map object)

			var indexKey = type + '_idx',
			    indexLenKey = type + '_len',
			    typeIndex = events[indexKey] = events[indexKey] || {},
			    id = L.stamp(fn) + '_' + contextId;

			if (!typeIndex[id]) {
				typeIndex[id] = {fn: fn, ctx: context};

				// keep track of the number of keys in the index to quickly check if it's empty
				events[indexLenKey] = (events[indexLenKey] || 0) + 1;
			}

		} else {
			// individual layers mostly use "this" for context and don't fire listeners too often
			// so simple array makes the memory footprint better while not degrading performance

			events[type] = events[type] || [];
			events[type].push({fn: fn});
		}
	},

	_off: function (type, fn, context) {
		var events = this._events,
		    indexKey = type + '_idx',
		    indexLenKey = type + '_len';

		if (!events) { return; }

		if (!fn) {
			// clear all listeners for a type if function isn't specified
			delete events[type];
			delete events[indexKey];
			delete events[indexLenKey];
			return;
		}

		var contextId = context && context !== this && L.stamp(context),
		    listeners, i, len, listener, id;

		if (contextId) {
			id = L.stamp(fn) + '_' + contextId;
			listeners = events[indexKey];

			if (listeners && listeners[id]) {
				listener = listeners[id];
				delete listeners[id];
				events[indexLenKey]--;
			}

		} else {
			listeners = events[type];

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					if (listeners[i].fn === fn) {
						listener = listeners[i];
						listeners.splice(i, 1);
						break;
					}
				}
			}
		}

		// set the removed listener to noop so that's not called if remove happens in fire
		if (listener) {
			listener.fn = L.Util.falseFn;
		}
	},

	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this}),
		    events = this._events;

		if (events) {
			var typeIndex = events[type + '_idx'],
			    i, len, listeners, id;

			if (events[type]) {
				// make sure adding/removing listeners inside other listeners won't cause infinite loop
				listeners = events[type].slice();

				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn.call(this, event);
				}
			}

			// fire event for the context-indexed listeners as well
			for (id in typeIndex) {
				typeIndex[id].fn.call(typeIndex[id].ctx, event);
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	listens: function (type, propagate) {
		var events = this._events;

		if (events && (events[type] || events[type + '_len'])) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// adds a parent to propagate events to (when you fire with true as a 3rd argument)
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually
proto.addEventListener = proto.on;
proto.removeEventListener = proto.clearAllEventListeners = proto.off;
proto.addOneTimeEventListener = proto.once;
proto.fireEvent = proto.fire;
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !window.PointerEvent,
	    pointer = (window.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints) || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;

	var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {
		ie: ie,
		ielt9: ie && !document.addEventListener,
		webkit: webkit,
		gecko: gecko,
		android: ua.indexOf('android') !== -1,
		android23: android23,
		chrome: chrome,
		safari: !chrome && ua.indexOf('safari') !== -1,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera12: opera12,
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,
		mobileGecko: mobile && gecko,

		touch: !!touch,
		msPointer: !!msPointer,
		pointer: !!pointer,

		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			'translate3d(' + pos.x + 'px,' + pos.y + 'px' + ',0)' + (scale ? ' scale(' + scale + ')' : '');
	},

	setPosition: function (el, point, no3d) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d && !no3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos;
	}
};


(function () {
	// prefix style property names

	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';


	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	L.DomUtil.preventOutline = function (element) {
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = +lat;
	this.lng = +lng;

	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
				lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	}
};


// constructs LatLng with different signatures
// (LatLng) or ([Number, Number]) or (Number, Number) or (Object)

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};


/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {

	R: 6378137,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = 1 - 1E-15,
		    sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};


/*
 * L.CRS is the base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	// converts geo coords to pixel ones
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// converts pixel coords to geo coords
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// converts geo coords to projection-specific coords (e.g. in meters)
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// converts projected coords to geo coords
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// defines how the world scales with zoom
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// returns the bounds of the world in projected coords if applicable
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// whether a coordinate axis wraps in a given range (e.g. longitude from -180 to 180); depends on CRS
	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// if true, the coordinate space will be unbounded (infinite in all directions)
	// infinite: false,

	// wraps geo coords in certain ranges if applicable
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});


/*
 * L.CRS.Earth is the base class for all CRS representing Earth.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	R: 6378137,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Evented.extend({

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: true,
		trackResize: true,
		markerZoomAnimation: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),
		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	fitBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {

		this._initEvents(true);

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			this.fire('unload');
		}

		return this;
	},

	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding).floor();
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	getScaleZoom: function (scale, fromZoom) {
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return fromZoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		this._mapPane = this.createPane('mapPane', this._container);

		this.createPane('tilePane');
		this.createPane('shadowPane');
		this.createPane('overlayPane');
		this.createPane('markerPane');
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		}

		this._pixelOrigin = this._getNewPixelOrigin(center);

		var loading = !this._loaded;
		this._loaded = true;

		this.fire('viewreset', {hard: !preserveMapOffset});

		if (loading) {
			this.fire('load');
		}

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};

		var onOff = remove ? 'off' : 'on';

		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_findEventTarget: function (src) {
		while (src) {
			var target = this._targets[L.stamp(src)];
			if (target) {
				return target;
			}
			if (src === this._container) {
				break;
			}
			src = src.parentNode;
		}
		return null;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		// find the layer the event is propagating from
		var target = this._findEventTarget(e.target || e.srcElement),
			type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		// special case for map mouseover/mouseout events so that they're actually mouseenter/mouseleave
		if (!target && (type === 'mouseover' || type === 'mouseout') &&
				!L.DomEvent._checkMouse(this._container, e)) { return; }

		// prevents outline when clicking on keyboard-focusable element
		if (type === 'mousedown') {
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(target || this, e, type);
	},

	_fireDOMEvent: function (target, e, type) {
		if (!target.listens(type, true) && (type !== 'click' || !target.listens('preclick', true))) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		// prevents firing click after you just dragged an object
		if (e.type === 'click' && !e._simulated && this._draggableMoved(target)) { return; }

		var data = {
			originalEvent: e
		};
		if (e.type !== 'keypress') {
			data.containerPoint = target instanceof L.Marker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = this.layerPointToLatLng(data.layerPoint);
		}
		if (type === 'click') {
			target.fire('preclick', data, true);
		}
		target.fire(type, data, true);
	},

	_draggableMoved: function (obj) {
		obj = obj.options.draggable ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};



L.Layer = L.Evented.extend({

	options: {
		pane: 'overlayPane'
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		if (this.getEvents) {
			map.on(this.getEvents(), this);
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});


L.Map.include({
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return layer; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		if (layer.getEvents) {
			this.off(layer.getEvents(), layer);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};


/*
 * L.CRS.EPSG3857 (World Mercator) CRS implementation.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.GridLayer is used as base class for grid-like layers like TileLayer.
 */

L.GridLayer = L.Layer.extend({

	options: {
		pane: 'tilePane',

		tileSize: 256,
		opacity: 1,

		updateWhenIdle: L.Browser.mobile,
		updateInterval: 200,

		attribution: null,
		zIndex: null,
		bounds: null,

		minZoom: 0
		// maxZoom: <Number>
	},

	initialize: function (options) {
		options = L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._viewReset();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	isLoading: function () {
		return this._loading;
	},

	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewreset: this._viewReset,
			moveend: this._move
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			events.move = L.Util.throttle(this._move, this.options.updateInterval, this);
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	createTile: function () {
		return document.createElement('div');
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }
		var opacity = this.options.opacity;

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (!L.Browser.ielt9 && !this._map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, opacity);
			return;
		}

		var now = +new Date(),
			nextFrame = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded || tile.active) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);
			if (fade < 1) {
				L.DomUtil.setOpacity(tile.el, opacity * fade);
				nextFrame = true;
			} else {
				L.DomUtil.setOpacity(tile.el, opacity);
				tile.active = true;
				this._pruneTiles();
			}
		}

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer');
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {
		var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom;

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		var key, tile;

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
			y2 = Math.floor(y / 2),
			z2 = z - 1;

		var key = x2 + ':' + y2 + ':' + z2,
			tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var key = i + ':' + j + ':' + (z + 1),
					tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_viewReset: function (e) {
		this._reset(this._map.getCenter(), this._map.getZoom(), e && e.hard);
	},

	_animateZoom: function (e) {
		this._reset(e.center, e.zoom, false, true, e.noUpdate);
	},

	_reset: function (center, zoom, hard, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom),
			tileZoomChanged = this._tileZoom !== tileZoom;

		if (!noUpdate && (hard || tileZoomChanged)) {

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._tileZoom = tileZoom;
			this._updateLevels();
			this._resetGrid();

			if (!L.Browser.mobileWebkit) {
				this._update(center, tileZoom);
			}

			if (!noPrune) {
				this._pruneTiles();
			}
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		L.DomUtil.setTransform(level.el, translate, scale);
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this._getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize)
		];
		this._wrapY = crs.wrapLat && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize)
		];
	},

	_getTileSize: function () {
		return this.options.tileSize;
	},

	_move: function () {
		this._update();
		this._pruneTiles();
	},

	_update: function (center, zoom) {
		var map = this._map;
		if (!map) { return; }

		// TODO move to reset
		// var zoom = this._map.getZoom();

		// if (zoom > this.options.maxZoom ||
		//     zoom < this.options.minZoom) { return; }

		if (center === undefined) { center = map.getCenter(); }
		if (zoom === undefined) { zoom = Math.round(map.getZoom()); }

		var pixelBounds = map.getPixelBounds(center, zoom),
			tileRange = this._pxBoundsToTileRange(pixelBounds),
			tileCenter = tileRange.getCenter(),
			queue = [];

		for (var key in this._tiles) {
			this._tiles[key].current = false;
		}

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = zoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if its the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).intersects(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this._getTileSize(),

		    nwPoint = coords.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),
		    se = map.wrapLatLng(map.unproject(sePoint, coords.z));

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
			coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		tile.style.width = this._tileSize + 'px';
		tile.style.height = this._tileSize + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			setTimeout(L.bind(this._tileReady, this, coords, null, tile), 0);
		}

		// we prefer top/left over translate3d so that we don't create a HW-accelerated layer from each tile
		// which is slow, and it also fixes gaps between tiles in Safari
		L.DomUtil.setPosition(tile, tilePos, true);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

		this.fire('tileload', {
			tile: tile.el,
			coords: coords
		});

		if (this._noTilesToLoad()) {
			this._loading = false;
			this.fire('load');
		}
	},

	_getTilePos: function (coords) {
		return coords.multiplyBy(this._tileSize).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		return new L.Bounds(
			bounds.min.divideBy(this._tileSize).floor(),
			bounds.max.divideBy(this._tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

L.gridLayer = function (options) {
	return new L.GridLayer(options);
};


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.GridLayer.extend({

	options: {
		maxZoom: 18,

		subdomains: 'abc',
		errorTileUrl: '',
		zoomOffset: 0,

		maxNativeZoom: null, // Number
		tms: false,
		zoomReverse: false,
		detectRetina: false,
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			options.minZoom = Math.max(0, options.minZoom);
			options.maxZoom--;
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	createTile: function (coords, done) {
		var tile = document.createElement('img');

		tile.onload = L.bind(this._tileOnLoad, this, done, tile);
		tile.onerror = L.bind(this._tileOnError, this, done, tile);

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	getTileUrl: function (coords) {
		return L.Util.template(this._url, L.extend({
			r: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: this.options.tms ? this._globalTileRange.max.y - coords.y : coords.y,
			z: this._getZoomForUrl()
		}, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_getTileSize: function () {
		var map = this._map,
		    options = this.options,
		    zoom = this._tileZoom + options.zoomOffset,
		    zoomN = options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				Math.round(options.tileSize / map.getZoomScale(zoomN, zoom)) :
				options.tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			tile = this._tiles[i].el;

			tile.onload = L.Util.falseFn;
			tile.onerror = L.Util.falseFn;

			if (!tile.complete) {
				tile.src = L.Util.emptyImageUrl;
				L.DomUtil.remove(tile);
			}
		}
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for WMS tile layers.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	options: {
		crs: null,
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Layer.extend({

	options: {
		opacity: 1,
		alt: '',
		interactive: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');
		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var bounds = new L.Bounds(
			this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center),
		    this._map._latLngToNewLayerPoint(this._bounds.getSouthEast(), e.zoom, e.center));

		var offset = bounds.min.add(bounds.getSize()._multiplyBy((1 - 1 / e.scale) / 2));

		L.DomUtil.setTransform(this._image, offset, e.scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	/*
	options: {
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		className: (String)
	},
	*/

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;

		if (src.match(leafletRe)) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Layer.extend({

	options: {
		pane: 'markerPane',

		icon: new L.Icon.Default(),
		// title: '',
		// alt: '',
		interactive: true,
		// draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		// riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		this._initIcon();
		this.update();
	},

	onRemove: function () {
		if (this.dragging && this.dragging.enabled()) {
			this.dragging.removeHooks();
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		var events = {viewreset: this.update};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;
		this._initInteraction();

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
			    mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			div.style.backgroundPosition = (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Layer.extend({

	options: {
		pane: 'popupPane',

		minWidth: 50,
		maxWidth: 300,
		// maxHeight: <Number>,
		offset: [0, 7],

		autoPan: true,
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: <Point>,
		// autoPanPaddingBottomRight: <Point>,

		closeButton: true,
		autoClose: true,
		// keepInView: false,
		// className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this}, true);
		}
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this}, true);
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {viewreset: this._updatePosition},
		    options = this.options;

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		if ('closeOnClick' in options ? options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (options.keepInView) {
			events.moveend = this._adjustPan;
		}
		return events;
	},

	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset);

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos);
		} else {
			offset = offset.add(pos);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._zoomAnimated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});


/*
 * Adds popup-related methods to all layers.
 */

L.Layer.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			this._popup.options.offset = this._popupAnchor(layer);
			this._popup._source = layer;
			this._popup.update();
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_popupAnchor: function (layer) {
		var anchor = layer._getPopupAnchor ? layer._getPopupAnchor() : [0, 0];
		return L.point(anchor).add(L.Popup.prototype.options.offset);
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function() {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		return this.fire('layerremove', {layer: layer});
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Renderer is a base class for renderer implementations (SVG, Canvas);
 * handles renderer container, bounds and zoom animation.
 */

L.Renderer = L.Layer.extend({

	options: {
		// how much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction; defaults to clip with the map view
		padding: 0
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	_animateZoom: function (e) {
		var origin = e.origin.subtract(this._map._getCenterLayerPoint()),
		    offset = this._bounds.min.add(origin.multiplyBy(1 - e.scale)).add(e.offset).round();

		L.DomUtil.setTransform(this._container, offset, e.scale);
	},

	_update: function () {
		// update pixel bounds of renderer container (for positioning/sizing/clipping later)
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
	}
});


L.Map.include({
	// used by each vector layer to decide which renderer to use
	getRenderer: function (layer) {
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = (L.SVG && L.svg()) || (L.Canvas && L.canvas());
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});


/*
 * L.Path is the base class for all Leaflet vector layers like polygons and circles.
 */

L.Path = L.Layer.extend({

	options: {
		stroke: true,
		color: '#3388ff',
		weight: 3,
		opacity: 1,
		lineCap: 'round',
		lineJoin: 'round',
		// dashArray: null
		// dashOffset: null

		// fill: false
		// fillColor: same as color by default
		fillOpacity: 0.2,
		fillRule: 'evenodd',

		// className: ''
		interactive: true
	},

	onAdd: function () {
		this._renderer = this._map.getRenderer(this);
		this._renderer._initPath(this);

		// defined in children classes
		this._project();
		this._update();

		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	getEvents: function () {
		return {
			viewreset: this._project,
			moveend: this._update
		};
	},

	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline implements polyline vector layer (a set of points connected with lines)
 */

L.Polyline = L.Path.extend({

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0
		// noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	getLatLngs: function () {
		// TODO rings
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		// TODO rings
		latlng = L.latLng(latlng);
		this._latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	spliceLatLngs: function () {
		// TODO rings
		var removed = [].splice.apply(this._latlngs, arguments);
		this._setLatLngs(this._latlngs);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getCenter: function () {
		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	getBounds: function () {
		return this._bounds;
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = this._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_flat: function (latlngs) {
		// true if it's a flat array of latlngs; false if nested
		return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object';
	},

	_project: function () {
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings);

		// project bounds as well to use later for Canvas hit detection/etc.
		var w = this._clickTolerance(),
			p = new L.Point(w, -w);

		if (this._latlngs.length) {
			this._pxBounds = new L.Bounds(
				this._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p),
				this._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p));
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result) {

		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    bounds = this._renderer._bounds,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
			tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon implements polygon vector layer (closed polyline with a fill inside).
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	getCenter: function () {
		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Path.extend({

	options: {
		fill: true,
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	getLatLng: function () {
		return this._latlng;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion)
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, radius, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._mRadius;
	},

	getBounds: function () {
		var half = [this._radius, this._radiusY];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.SVG renders vector layers with SVG. All SVG-specific code goes here.
 */

L.SVG = L.Renderer.extend({

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		L.DomUtil.setPosition(container, b.min);

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._container.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
			options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}

		path.setAttribute('pointer-events', options.pointerEvents || (options.interactive ? 'visiblePainted' : 'none'));
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


L.extend(L.SVG, {
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// generates SVG path string for multiple rings, with each ring turning into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
			i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);

L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};


/*
 * Vector rendering for IE7-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');

		this._paths = {};
		this._initEvents();
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);
		this._paths[L.stamp(container)] = layer;
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		delete this._paths[L.stamp(container)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}


/*
 * L.Canvas handles Canvas vector layers rendering and mouse events handling. All Canvas-specific code goes here.
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// redraw vectors since canvas is cleared upon removal
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', this._onMouseMove, this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);
	},

	_initPath: function (layer) {
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._requestRedraw(layer);
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min).extend(layer._pxBounds.max);

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!this._redrawBounds || layer._pxBounds.intersects(this._redrawBounds)) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e);

		for (var id in this._layers) {
			if (this._layers[id]._containsPoint(point)) {
				L.DomEvent._fakeStop(e);
				this._fireEvent(this._layers[id], e);
			}
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);

		// TODO don't do on each move event, throttle since it's expensive
		for (var id in this._layers) {
			this._handleHover(this._layers[id], e, point);
		}
	},

	_handleHover: function (layer, e, point) {
		if (!layer.options.interactive) { return; }

		if (layer._containsPoint(point)) {
			// if we just got inside the layer, fire mouseover
			if (!layer._mouseInside) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent(layer, e, 'mouseover');
				layer._mouseInside = true;
			}
			// fire mousemove
			this._fireEvent(layer, e);

		} else if (layer._mouseInside) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent(layer, e, 'mouseout');
			layer._mouseInside = false;
		}
	},

	_fireEvent: function (layer, e, type) {
		this._map._fireDOMEvent(layer, e, type || e.type);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = layer.defaultOptions;
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.prototype.toGeoJSON = function () {
	var multi = !this._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

L.Polygon.prototype.toGeoJSON = function () {
	var holes = !this._flat(this._latlngs),
	    multi = holes && !this._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
			jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 * Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
 */

var eventsKey = '_leaflet_events';

L.DomEvent = {

	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._checkMouse(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel MozMousePixelScroll', L.DomEvent.stopPropagation);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

L.DomEvent.addListener = L.DomEvent.on;
L.DomEvent.removeListener = L.DomEvent.off;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Evented.extend({

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag', e);
	},

	_onUp: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove, this)
			    .off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDown: function () {
		this._map.stop();
	},

	_onDragStart: function () {
		var map = this._map;

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onViewReset: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    zoom = e.originalEvent.shiftKey ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true,
	wheelDebounceTime: 40
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, {
			mousewheel: this._onWheelScroll,
			MozMousePixelScroll: L.DomEvent.preventDefault
		}, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, {
			mousewheel: this._onWheelScroll,
			MozMousePixelScroll: L.DomEvent.preventDefault
		}, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);
		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		map.stop(); // stop panning and fly animations if any

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
						prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);
		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchend = obj[pre + this._touchend + id];

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		obj.removeEventListener(this._touchend, touchend, false);

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			L.DomEvent.preventDefault(e);

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		map.stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (!map.options.bounceAtZoomLimits) {
			var currentZoom = map.getScaleZoom(this._scale);
			if ((currentZoom <= map.getMinZoom() && this._scale < 1) ||
		     (currentZoom >= map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map;

		if (map.options.touchZoom === 'center') {
			this._center = map.getCenter();
		} else {
			this._center = map.layerPointToLatLng(this._getTargetCenter());
		}

		this._zoom = map.getScaleZoom(this._scale);

		if (this._scale !== 1 || this._delta.x !== 0 || this._delta.y !== 0) {
			map._animateZoom(this._center, this._zoom, false, true);
		}
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var map = this._map,
		    oldZoom = map.getZoom(),
		    zoomDelta = this._zoom - oldZoom,
		    finalZoom = map._limitZoom(zoomDelta > 0 ? Math.ceil(this._zoom) : Math.floor(this._zoom));

		map._animateZoom(this._center, finalZoom, true, true);
	},

	_getTargetCenter: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._moved = false;

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;

		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled) {
			this._map.zoomIn(e.shiftKey ? 3 : 1);
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled) {
			this._map.zoomOut(e.shiftKey ? 3 : 1);
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};


/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true
		// updateWhenIdle: false
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = L.CRS.Earth.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true,
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function () {
		this._initLayout();
		this._update();

		return this._container;
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return this._update();
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return this._update();
	},

	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		delete this._layers[L.stamp(layer)];
		return this._update();
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this._expand,
					mouseleave: this._collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var overlay = this._layers[L.stamp(e.target)].overlay;

		var type = overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, e.target);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = 0, len = inputs.length; i < len; i++) {
			input = inputs[i];
			layer = this._layers[input.layerId].layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation powers Leaflet pan animations internally.
 */

L.PosAnimation = L.Evented.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this.stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}
		//If we pan too far then chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return (options && options.animate) !== false;
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
				transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
				z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    .fire('movestart')
			    .fire('zoomstart')
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			scale: this.getZoomScale(zoom),
			origin: this.latLngToLayerPoint(center),
			offset: this._getCenterOffset(center).multiplyBy(-1),
			noUpdate: noUpdate
		});
	},

	_onZoomTransitionEnd: function () {

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._resetView(this._animateToCenter, this._animateToZoom, true, true);
	}
});



L.Map.include({
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this.stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = to.distanceTo(from),
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
			return Math.log(Math.sqrt(b * b + 1) - b);
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._resetView(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom), true, true);

			} else {
				this._resetView(targetCenter, targetZoom, true, true);
			}
		}

		this.fire('zoomstart');
		frame.call(this);
		return this;
	},

	flyToBounds: function(bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s=Math.PI/180;i.toRadian=function(e){return e*s};var o={};o.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},o.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},o.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},o.set=function(e,t,n){return e[0]=t,e[1]=n,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},o.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},o.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},o.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),o.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=o);var u={};u.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},u.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},u.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},u.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},u.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},u.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},u.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.rotateX=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0],s[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),s[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateY=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateZ=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),s[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),s[2]=i[2],e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),u.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=u);var a={};a.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},a.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},a.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},a.sub=a.subtract,a.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},a.mul=a.multiply,a.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},a.div=a.divide,a.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},a.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},a.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},a.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},a.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},a.dist=a.distance,a.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},a.sqrDist=a.squaredDistance,a.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},a.len=a.length,a.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},a.sqrLen=a.squaredLength,a.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},a.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},a.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},a.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},a.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),a.normalize(e,e),a.scale(e,e,t),e},a.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},a.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},a.forEach=function(){var e=a.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),a.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=a);var f={};f.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},f.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},f.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+s*a,e[1]=i*u+o*a,e[2]=r*f+s*l,e[3]=i*f+o*l,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+s*u,e[1]=i*a+o*u,e[2]=r*-u+s*a,e[3]=i*-u+o*a,e},f.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*u,e[2]=s*a,e[3]=o*a,e},f.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},f.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2))},f.LDU=function(e,t,n,r){return e[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-e[2]*n[1],[e,t,n]},typeof e!="undefined"&&(e.mat2=f);var l={};l.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},l.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+s*l,e[1]=i*f+o*l,e[2]=r*c+s*h,e[3]=i*c+o*h,e[4]=r*p+s*d+u,e[5]=i*p+o*d+a,e},l.mul=l.multiply,l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+s*f,e[1]=i*l+o*f,e[2]=r*-f+s*l,e[3]=i*-f+o*l,e[4]=u,e[5]=a,e},l.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r*f,e[1]=i*f,e[2]=s*l,e[3]=o*l,e[4]=u,e[5]=a,e},l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=r*f+s*l+u,e[5]=i*f+o*l+a,e},l.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},l.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+1)},typeof e!="undefined"&&(e.mat2d=l);var c={};c.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},c.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},c.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},c.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[3]=l-g,e[6]=h+m,e[1]=l+g,e[4]=1-f-d,e[7]=p-v,e[2]=h-m,e[5]=p+v,e[8]=1-f-c,e},c.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},c.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},c.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2))},typeof e!="undefined"&&(e.mat3=c);var h={};h.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},h.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},h.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},h.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},h.mul=h.multiply,h.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},h.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},h.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},h.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},h.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},h.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},h.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[1]=l+g,e[2]=h-m,e[3]=0,e[4]=l-g,e[5]=1-f-d,e[6]=p+v,e[7]=0,e[8]=h+m,e[9]=p-v,e[10]=1-f-c,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},h.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},h.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},h.lookAt=function(e,n,r,i){var s,o,u,a,f,l,c,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?h.identity(e):(c=m-S,p=g-x,d=y-T,v=1/Math.sqrt(c*c+p*p+d*d),c*=v,p*=v,d*=v,s=w*d-E*p,o=E*c-b*d,u=b*p-w*c,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-c*u,l=c*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=c,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(c*m+p*g+d*y),e[15]=1,e)},h.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},h.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2)+Math.pow(e[9],2)+Math.pow(e[10],2)+Math.pow(e[11],2)+Math.pow(e[12],2)+Math.pow(e[13],2)+Math.pow(e[14],2)+Math.pow(e[15],2))},typeof e!="undefined"&&(e.mat4=h);var p={};p.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.rotationTo=function(){var e=u.create(),t=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,i,s){var o=u.dot(i,s);return o<-0.999999?(u.cross(e,t,i),u.length(e)<1e-6&&u.cross(e,n,i),u.normalize(e,e),p.setAxisAngle(r,e,Math.PI),r):o>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+o,p.normalize(r,r))}}(),p.setAxes=function(){var e=c.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],p.normalize(t,p.fromMat3(t,e))}}(),p.clone=a.clone,p.fromValues=a.fromValues,p.copy=a.copy,p.set=a.set,p.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},p.add=a.add,p.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},p.mul=p.multiply,p.scale=a.scale,p.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},p.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},p.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},p.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},p.dot=a.dot,p.lerp=a.lerp,p.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},p.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},p.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},p.length=a.length,p.len=p.length,p.squaredLength=a.squaredLength,p.sqrLen=p.squaredLength,p.normalize=a.normalize,p.fromMat3=function(e,t){var n=t[0]+t[4]+t[8],r;if(n>0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[7]-t[5])*r,e[1]=(t[2]-t[6])*r,e[2]=(t[3]-t[1])*r;else{var i=0;t[4]>t[0]&&(i=1),t[8]>t[i*3+i]&&(i=2);var s=(i+1)%3,o=(i+2)%3;r=Math.sqrt(t[i*3+i]-t[s*3+s]-t[o*3+o]+1),e[i]=.5*r,r=.5/r,e[3]=(t[o*3+s]-t[s*3+o])*r,e[s]=(t[s*3+i]+t[i*3+s])*r,e[o]=(t[o*3+i]+t[i*3+o])*r}return e},p.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=p)}(t.exports)})(this);

/* @preserve
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Petka Antonov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
/**
 * bluebird build version 3.4.1
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
 */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.Promise=t()}}(function(){var t,e,n;return function r(t,e,n){function i(s,a){if(!e[s]){if(!t[s]){var c="function"==typeof _dereq_&&_dereq_;if(!a&&c)return c(s,!0);if(o)return o(s,!0);var l=new Error("Cannot find module '"+s+"'");throw l.code="MODULE_NOT_FOUND",l}var u=e[s]={exports:{}};t[s][0].call(u.exports,function(e){var n=t[s][1][e];return i(n?n:e)},u,u.exports,r,t,e,n)}return e[s].exports}for(var o="function"==typeof _dereq_&&_dereq_,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(t,e,n){"use strict";e.exports=function(t){function e(t){var e=new n(t),r=e.promise();return e.setHowMany(1),e.setUnwrap(),e.init(),r}var n=t._SomePromiseArray;t.any=function(t){return e(t)},t.prototype.any=function(){return e(this)}}},{}],2:[function(t,e,n){"use strict";function r(){this._customScheduler=!1,this._isTickUsed=!1,this._lateQueue=new u(16),this._normalQueue=new u(16),this._haveDrainedQueues=!1,this._trampolineEnabled=!0;var t=this;this.drainQueues=function(){t._drainQueues()},this._schedule=l}function i(t,e,n){this._lateQueue.push(t,e,n),this._queueTick()}function o(t,e,n){this._normalQueue.push(t,e,n),this._queueTick()}function s(t){this._normalQueue._pushOne(t),this._queueTick()}var a;try{throw new Error}catch(c){a=c}var l=t("./schedule"),u=t("./queue"),p=t("./util");r.prototype.setScheduler=function(t){var e=this._schedule;return this._schedule=t,this._customScheduler=!0,e},r.prototype.hasCustomScheduler=function(){return this._customScheduler},r.prototype.enableTrampoline=function(){this._trampolineEnabled=!0},r.prototype.disableTrampolineIfNecessary=function(){p.hasDevTools&&(this._trampolineEnabled=!1)},r.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues},r.prototype.fatalError=function(t,e){e?(process.stderr.write("Fatal "+(t instanceof Error?t.stack:t)+"\n"),process.exit(2)):this.throwLater(t)},r.prototype.throwLater=function(t,e){if(1===arguments.length&&(e=t,t=function(){throw e}),"undefined"!=typeof setTimeout)setTimeout(function(){t(e)},0);else try{this._schedule(function(){t(e)})}catch(n){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}},p.hasDevTools?(r.prototype.invokeLater=function(t,e,n){this._trampolineEnabled?i.call(this,t,e,n):this._schedule(function(){setTimeout(function(){t.call(e,n)},100)})},r.prototype.invoke=function(t,e,n){this._trampolineEnabled?o.call(this,t,e,n):this._schedule(function(){t.call(e,n)})},r.prototype.settlePromises=function(t){this._trampolineEnabled?s.call(this,t):this._schedule(function(){t._settlePromises()})}):(r.prototype.invokeLater=i,r.prototype.invoke=o,r.prototype.settlePromises=s),r.prototype.invokeFirst=function(t,e,n){this._normalQueue.unshift(t,e,n),this._queueTick()},r.prototype._drainQueue=function(t){for(;t.length()>0;){var e=t.shift();if("function"==typeof e){var n=t.shift(),r=t.shift();e.call(n,r)}else e._settlePromises()}},r.prototype._drainQueues=function(){this._drainQueue(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,this._drainQueue(this._lateQueue)},r.prototype._queueTick=function(){this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues))},r.prototype._reset=function(){this._isTickUsed=!1},e.exports=r,e.exports.firstLineError=a},{"./queue":26,"./schedule":29,"./util":36}],3:[function(t,e,n){"use strict";e.exports=function(t,e,n,r){var i=!1,o=function(t,e){this._reject(e)},s=function(t,e){e.promiseRejectionQueued=!0,e.bindingPromise._then(o,o,null,this,t)},a=function(t,e){0===(50397184&this._bitField)&&this._resolveCallback(e.target)},c=function(t,e){e.promiseRejectionQueued||this._reject(t)};t.prototype.bind=function(o){i||(i=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());var l=n(o),u=new t(e);u._propagateFrom(this,1);var p=this._target();if(u._setBoundTo(l),l instanceof t){var h={promiseRejectionQueued:!1,promise:u,target:p,bindingPromise:l};p._then(e,s,void 0,u,h),l._then(a,c,void 0,u,h),u._setOnCancel(l)}else u._resolveCallback(p);return u},t.prototype._setBoundTo=function(t){void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=-2097153&this._bitField},t.prototype._isBound=function(){return 2097152===(2097152&this._bitField)},t.bind=function(e,n){return t.resolve(n).bind(e)}}},{}],4:[function(t,e,n){"use strict";function r(){try{Promise===o&&(Promise=i)}catch(t){}return o}var i;"undefined"!=typeof Promise&&(i=Promise);var o=t("./promise")();o.noConflict=r,e.exports=o},{"./promise":22}],5:[function(t,e,n){"use strict";var r=Object.create;if(r){var i=r(null),o=r(null);i[" size"]=o[" size"]=0}e.exports=function(e){function n(t,n){var r;if(null!=t&&(r=t[n]),"function"!=typeof r){var i="Object "+a.classString(t)+" has no method '"+a.toString(n)+"'";throw new e.TypeError(i)}return r}function r(t){var e=this.pop(),r=n(t,e);return r.apply(t,this)}function i(t){return t[this]}function o(t){var e=+this;return 0>e&&(e=Math.max(0,e+t.length)),t[e]}var s,a=t("./util"),c=a.canEvaluate;a.isIdentifier;e.prototype.call=function(t){var e=[].slice.call(arguments,1);return e.push(t),this._then(r,void 0,void 0,e,void 0)},e.prototype.get=function(t){var e,n="number"==typeof t;if(n)e=o;else if(c){var r=s(t);e=null!==r?r:i}else e=i;return this._then(e,void 0,void 0,t,void 0)}}},{"./util":36}],6:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){var o=t("./util"),s=o.tryCatch,a=o.errorObj,c=e._async;e.prototype["break"]=e.prototype.cancel=function(){if(!i.cancellation())return this._warn("cancellation is disabled");for(var t=this,e=t;t.isCancellable();){if(!t._cancelBy(e)){e._isFollowing()?e._followee().cancel():e._cancelBranched();break}var n=t._cancellationParent;if(null==n||!n.isCancellable()){t._isFollowing()?t._followee().cancel():t._cancelBranched();break}t._isFollowing()&&t._followee().cancel(),e=t,t=n}},e.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--},e.prototype._enoughBranchesHaveCancelled=function(){return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel<=0},e.prototype._cancelBy=function(t){return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),this._enoughBranchesHaveCancelled()?(this._invokeOnCancel(),!0):!1)},e.prototype._cancelBranched=function(){this._enoughBranchesHaveCancelled()&&this._cancel()},e.prototype._cancel=function(){this.isCancellable()&&(this._setCancelled(),c.invoke(this._cancelPromises,this,void 0))},e.prototype._cancelPromises=function(){this._length()>0&&this._settlePromises()},e.prototype._unsetOnCancel=function(){this._onCancelField=void 0},e.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled()},e.prototype._doInvokeOnCancel=function(t,e){if(o.isArray(t))for(var n=0;n<t.length;++n)this._doInvokeOnCancel(t[n],e);else if(void 0!==t)if("function"==typeof t){if(!e){var r=s(t).call(this._boundValue());r===a&&(this._attachExtraTrace(r.e),c.throwLater(r.e))}}else t._resultCancelled(this)},e.prototype._invokeOnCancel=function(){var t=this._onCancel();this._unsetOnCancel(),c.invoke(this._doInvokeOnCancel,this,t)},e.prototype._invokeInternalOnCancel=function(){this.isCancellable()&&(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel())},e.prototype._resultCancelled=function(){this.cancel()}}},{"./util":36}],7:[function(t,e,n){"use strict";e.exports=function(e){function n(t,n,a){return function(c){var l=a._boundValue();t:for(var u=0;u<t.length;++u){var p=t[u];if(p===Error||null!=p&&p.prototype instanceof Error){if(c instanceof p)return o(n).call(l,c)}else if("function"==typeof p){var h=o(p).call(l,c);if(h===s)return h;if(h)return o(n).call(l,c)}else if(r.isObject(c)){for(var f=i(p),_=0;_<f.length;++_){var d=f[_];if(p[d]!=c[d])continue t}return o(n).call(l,c)}}return e}}var r=t("./util"),i=t("./es5").keys,o=r.tryCatch,s=r.errorObj;return n}},{"./es5":13,"./util":36}],8:[function(t,e,n){"use strict";e.exports=function(t){function e(){this._trace=new e.CapturedTrace(r())}function n(){return i?new e:void 0}function r(){var t=o.length-1;return t>=0?o[t]:void 0}var i=!1,o=[];return t.prototype._promiseCreated=function(){},t.prototype._pushContext=function(){},t.prototype._popContext=function(){return null},t._peekContext=t.prototype._peekContext=function(){},e.prototype._pushContext=function(){void 0!==this._trace&&(this._trace._promiseCreated=null,o.push(this._trace))},e.prototype._popContext=function(){if(void 0!==this._trace){var t=o.pop(),e=t._promiseCreated;return t._promiseCreated=null,e}return null},e.CapturedTrace=null,e.create=n,e.deactivateLongStackTraces=function(){},e.activateLongStackTraces=function(){var n=t.prototype._pushContext,o=t.prototype._popContext,s=t._peekContext,a=t.prototype._peekContext,c=t.prototype._promiseCreated;e.deactivateLongStackTraces=function(){t.prototype._pushContext=n,t.prototype._popContext=o,t._peekContext=s,t.prototype._peekContext=a,t.prototype._promiseCreated=c,i=!1},i=!0,t.prototype._pushContext=e.prototype._pushContext,t.prototype._popContext=e.prototype._popContext,t._peekContext=t.prototype._peekContext=r,t.prototype._promiseCreated=function(){var t=this._peekContext();t&&null==t._promiseCreated&&(t._promiseCreated=this)}},e}},{}],9:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,e){return{promise:e}}function i(){return!1}function o(t,e,n){var r=this;try{t(e,n,function(t){if("function"!=typeof t)throw new TypeError("onCancel must be a function, got: "+H.toString(t));r._attachCancellationCallback(t)})}catch(i){return i}}function s(t){if(!this.isCancellable())return this;var e=this._onCancel();void 0!==e?H.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t)}function a(){return this._onCancelField}function c(t){this._onCancelField=t}function l(){this._cancellationParent=void 0,this._onCancelField=void 0}function u(t,e){if(0!==(1&e)){this._cancellationParent=t;var n=t._branchesRemainingToCancel;void 0===n&&(n=0),t._branchesRemainingToCancel=n+1}0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function p(t,e){0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function h(){var t=this._boundTo;return void 0!==t&&t instanceof e?t.isFulfilled()?t.value():void 0:t}function f(){this._trace=new S(this._peekContext())}function _(t,e){if(N(t)){var n=this._trace;if(void 0!==n&&e&&(n=n._parent),void 0!==n)n.attachExtraTrace(t);else if(!t.__stackCleaned__){var r=j(t);H.notEnumerableProp(t,"stack",r.message+"\n"+r.stack.join("\n")),H.notEnumerableProp(t,"__stackCleaned__",!0)}}}function d(t,e,n,r,i){if(void 0===t&&null!==e&&z){if(void 0!==i&&i._returnedNonUndefined())return;if(0===(65535&r._bitField))return;n&&(n+=" ");var o="a promise was created in a "+n+"handler but was not returned from it";r._warn(o,!0,e)}}function v(t,e){var n=t+" is deprecated and will be removed in a future version.";return e&&(n+=" Use "+e+" instead."),y(n)}function y(t,n,r){if(rt.warnings){var i,o=new L(t);if(n)r._attachExtraTrace(o);else if(rt.longStackTraces&&(i=e._peekContext()))i.attachExtraTrace(o);else{var s=j(o);o.stack=s.message+"\n"+s.stack.join("\n")}Y("warning",o)||k(o,"",!0)}}function m(t,e){for(var n=0;n<e.length-1;++n)e[n].push("From previous event:"),e[n]=e[n].join("\n");return n<e.length&&(e[n]=e[n].join("\n")),t+"\n"+e.join("\n")}function g(t){for(var e=0;e<t.length;++e)(0===t[e].length||e+1<t.length&&t[e][0]===t[e+1][0])&&(t.splice(e,1),e--)}function b(t){for(var e=t[0],n=1;n<t.length;++n){for(var r=t[n],i=e.length-1,o=e[i],s=-1,a=r.length-1;a>=0;--a)if(r[a]===o){s=a;break}for(var a=s;a>=0;--a){var c=r[a];if(e[i]!==c)break;e.pop(),i--}e=r}}function w(t){for(var e=[],n=0;n<t.length;++n){var r=t[n],i="    (No stack trace)"===r||B.test(r),o=i&&tt(r);i&&!o&&(q&&" "!==r.charAt(0)&&(r="    "+r),e.push(r))}return e}function C(t){for(var e=t.stack.replace(/\s+$/g,"").split("\n"),n=0;n<e.length;++n){var r=e[n];if("    (No stack trace)"===r||B.test(r))break}return n>0&&(e=e.slice(n)),e}function j(t){var e=t.stack,n=t.toString();return e="string"==typeof e&&e.length>0?C(t):["    (No stack trace)"],{message:n,stack:w(e)}}function k(t,e,n){if("undefined"!=typeof console){var r;if(H.isObject(t)){var i=t.stack;r=e+M(i,t)}else r=e+String(t);"function"==typeof D?D(r,n):("function"==typeof console.log||"object"==typeof console.log)&&console.log(r)}}function E(t,e,n,r){var i=!1;try{"function"==typeof e&&(i=!0,"rejectionHandled"===t?e(r):e(n,r))}catch(o){I.throwLater(o)}"unhandledRejection"===t?Y(t,n,r)||i||k(n,"Unhandled rejection "):Y(t,r)}function F(t){var e;if("function"==typeof t)e="[function "+(t.name||"anonymous")+"]";else{e=t&&"function"==typeof t.toString?t.toString():H.toString(t);var n=/\[object [a-zA-Z0-9$_]+\]/;if(n.test(e))try{var r=JSON.stringify(t);e=r}catch(i){}0===e.length&&(e="(empty array)")}return"(<"+x(e)+">, no stack trace)"}function x(t){var e=41;return t.length<e?t:t.substr(0,e-3)+"..."}function T(){return"function"==typeof nt}function P(t){var e=t.match(et);return e?{fileName:e[1],line:parseInt(e[2],10)}:void 0}function R(t,e){if(T()){for(var n,r,i=t.stack.split("\n"),o=e.stack.split("\n"),s=-1,a=-1,c=0;c<i.length;++c){var l=P(i[c]);if(l){n=l.fileName,s=l.line;break}}for(var c=0;c<o.length;++c){var l=P(o[c]);if(l){r=l.fileName,a=l.line;break}}0>s||0>a||!n||!r||n!==r||s>=a||(tt=function(t){if(U.test(t))return!0;var e=P(t);return e&&e.fileName===n&&s<=e.line&&e.line<=a?!0:!1})}}function S(t){this._parent=t,this._promisesCreated=0;var e=this._length=1+(void 0===t?0:t._length);nt(this,S),e>32&&this.uncycle()}var O,A,D,V=e._getDomain,I=e._async,L=t("./errors").Warning,H=t("./util"),N=H.canAttachTrace,U=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,B=null,M=null,q=!1,Q=!(0==H.env("BLUEBIRD_DEBUG")||!H.env("BLUEBIRD_DEBUG")&&"development"!==H.env("NODE_ENV")),$=!(0==H.env("BLUEBIRD_WARNINGS")||!Q&&!H.env("BLUEBIRD_WARNINGS")),G=!(0==H.env("BLUEBIRD_LONG_STACK_TRACES")||!Q&&!H.env("BLUEBIRD_LONG_STACK_TRACES")),z=0!=H.env("BLUEBIRD_W_FORGOTTEN_RETURN")&&($||!!H.env("BLUEBIRD_W_FORGOTTEN_RETURN"));e.prototype.suppressUnhandledRejections=function(){var t=this._target();t._bitField=-1048577&t._bitField|524288},e.prototype._ensurePossibleRejectionHandled=function(){0===(524288&this._bitField)&&(this._setRejectionIsUnhandled(),I.invokeLater(this._notifyUnhandledRejection,this,void 0))},e.prototype._notifyUnhandledRejectionIsHandled=function(){E("rejectionHandled",O,void 0,this)},e.prototype._setReturnedNonUndefined=function(){this._bitField=268435456|this._bitField},e.prototype._returnedNonUndefined=function(){return 0!==(268435456&this._bitField)},e.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var t=this._settledValue();this._setUnhandledRejectionIsNotified(),E("unhandledRejection",A,t,this)}},e.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=262144|this._bitField},e.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=-262145&this._bitField},e.prototype._isUnhandledRejectionNotified=function(){return(262144&this._bitField)>0},e.prototype._setRejectionIsUnhandled=function(){this._bitField=1048576|this._bitField},e.prototype._unsetRejectionIsUnhandled=function(){this._bitField=-1048577&this._bitField,this._isUnhandledRejectionNotified()&&(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled())},e.prototype._isRejectionUnhandled=function(){return(1048576&this._bitField)>0},e.prototype._warn=function(t,e,n){return y(t,e,n||this)},e.onPossiblyUnhandledRejection=function(t){var e=V();A="function"==typeof t?null===e?t:e.bind(t):void 0},e.onUnhandledRejectionHandled=function(t){var e=V();O="function"==typeof t?null===e?t:e.bind(t):void 0};var X=function(){};e.longStackTraces=function(){if(I.haveItemsQueued()&&!rt.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");if(!rt.longStackTraces&&T()){var t=e.prototype._captureStackTrace,r=e.prototype._attachExtraTrace;rt.longStackTraces=!0,X=function(){if(I.haveItemsQueued()&&!rt.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");e.prototype._captureStackTrace=t,e.prototype._attachExtraTrace=r,n.deactivateLongStackTraces(),I.enableTrampoline(),rt.longStackTraces=!1},e.prototype._captureStackTrace=f,e.prototype._attachExtraTrace=_,n.activateLongStackTraces(),I.disableTrampolineIfNecessary()}},e.hasLongStackTraces=function(){return rt.longStackTraces&&T()};var W=function(){try{var t=document.createEvent("CustomEvent");return t.initCustomEvent("testingtheevent",!1,!0,{}),H.global.dispatchEvent(t),function(t,e){var n=document.createEvent("CustomEvent");return n.initCustomEvent(t.toLowerCase(),!1,!0,e),!H.global.dispatchEvent(n)}}catch(e){}return function(){return!1}}(),K=function(){return H.isNode?function(){return process.emit.apply(process,arguments)}:H.global?function(t){var e="on"+t.toLowerCase(),n=H.global[e];return n?(n.apply(H.global,[].slice.call(arguments,1)),!0):!1}:function(){return!1}}(),J={promiseCreated:r,promiseFulfilled:r,promiseRejected:r,promiseResolved:r,promiseCancelled:r,promiseChained:function(t,e,n){return{promise:e,child:n}},warning:function(t,e){return{warning:e}},unhandledRejection:function(t,e,n){return{reason:e,promise:n}},rejectionHandled:r},Y=function(t){var e=!1;try{e=K.apply(null,arguments)}catch(n){I.throwLater(n),e=!0}var r=!1;try{r=W(t,J[t].apply(null,arguments))}catch(n){I.throwLater(n),r=!0}return r||e};e.config=function(t){if(t=Object(t),"longStackTraces"in t&&(t.longStackTraces?e.longStackTraces():!t.longStackTraces&&e.hasLongStackTraces()&&X()),"warnings"in t){var n=t.warnings;rt.warnings=!!n,z=rt.warnings,H.isObject(n)&&"wForgottenReturn"in n&&(z=!!n.wForgottenReturn)}if("cancellation"in t&&t.cancellation&&!rt.cancellation){if(I.haveItemsQueued())throw new Error("cannot enable cancellation after promises are in use");e.prototype._clearCancellationData=l,e.prototype._propagateFrom=u,e.prototype._onCancel=a,e.prototype._setOnCancel=c,e.prototype._attachCancellationCallback=s,e.prototype._execute=o,Z=u,rt.cancellation=!0}"monitoring"in t&&(t.monitoring&&!rt.monitoring?(rt.monitoring=!0,e.prototype._fireEvent=Y):!t.monitoring&&rt.monitoring&&(rt.monitoring=!1,e.prototype._fireEvent=i))},e.prototype._fireEvent=i,e.prototype._execute=function(t,e,n){try{t(e,n)}catch(r){return r}},e.prototype._onCancel=function(){},e.prototype._setOnCancel=function(t){},e.prototype._attachCancellationCallback=function(t){},e.prototype._captureStackTrace=function(){},e.prototype._attachExtraTrace=function(){},e.prototype._clearCancellationData=function(){},e.prototype._propagateFrom=function(t,e){};var Z=p,tt=function(){return!1},et=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;H.inherits(S,Error),n.CapturedTrace=S,S.prototype.uncycle=function(){var t=this._length;if(!(2>t)){for(var e=[],n={},r=0,i=this;void 0!==i;++r)e.push(i),i=i._parent;t=this._length=r;for(var r=t-1;r>=0;--r){var o=e[r].stack;void 0===n[o]&&(n[o]=r)}for(var r=0;t>r;++r){var s=e[r].stack,a=n[s];if(void 0!==a&&a!==r){a>0&&(e[a-1]._parent=void 0,e[a-1]._length=1),e[r]._parent=void 0,e[r]._length=1;var c=r>0?e[r-1]:this;t-1>a?(c._parent=e[a+1],c._parent.uncycle(),c._length=c._parent._length+1):(c._parent=void 0,c._length=1);for(var l=c._length+1,u=r-2;u>=0;--u)e[u]._length=l,l++;return}}}},S.prototype.attachExtraTrace=function(t){if(!t.__stackCleaned__){this.uncycle();for(var e=j(t),n=e.message,r=[e.stack],i=this;void 0!==i;)r.push(w(i.stack.split("\n"))),i=i._parent;b(r),g(r),H.notEnumerableProp(t,"stack",m(n,r)),H.notEnumerableProp(t,"__stackCleaned__",!0)}};var nt=function(){var t=/^\s*at\s*/,e=function(t,e){return"string"==typeof t?t:void 0!==e.name&&void 0!==e.message?e.toString():F(e)};if("number"==typeof Error.stackTraceLimit&&"function"==typeof Error.captureStackTrace){Error.stackTraceLimit+=6,B=t,M=e;var n=Error.captureStackTrace;return tt=function(t){return U.test(t)},function(t,e){Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6}}var r=new Error;if("string"==typeof r.stack&&r.stack.split("\n")[0].indexOf("stackDetection@")>=0)return B=/@/,M=e,q=!0,function(t){t.stack=(new Error).stack};var i;try{throw new Error}catch(o){i="stack"in o}return"stack"in r||!i||"number"!=typeof Error.stackTraceLimit?(M=function(t,e){return"string"==typeof t?t:"object"!=typeof e&&"function"!=typeof e||void 0===e.name||void 0===e.message?F(e):e.toString()},null):(B=t,M=e,function(t){Error.stackTraceLimit+=6;try{throw new Error}catch(e){t.stack=e.stack}Error.stackTraceLimit-=6})}([]);"undefined"!=typeof console&&"undefined"!=typeof console.warn&&(D=function(t){console.warn(t)},H.isNode&&process.stderr.isTTY?D=function(t,e){var n=e?"[33m":"[31m";console.warn(n+t+"[0m\n")}:H.isNode||"string"!=typeof(new Error).stack||(D=function(t,e){console.warn("%c"+t,e?"color: darkorange":"color: red")}));var rt={warnings:$,longStackTraces:!1,cancellation:!1,monitoring:!1};return G&&e.longStackTraces(),{longStackTraces:function(){return rt.longStackTraces},warnings:function(){return rt.warnings},cancellation:function(){return rt.cancellation},monitoring:function(){return rt.monitoring},propagateFromFunction:function(){return Z},boundValueFunction:function(){return h},checkForgottenReturns:d,setBounds:R,warn:y,deprecated:v,CapturedTrace:S,fireDomEvent:W,fireGlobalEvent:K}}},{"./errors":12,"./util":36}],10:[function(t,e,n){"use strict";e.exports=function(t){function e(){return this.value}function n(){throw this.reason}t.prototype["return"]=t.prototype.thenReturn=function(n){return n instanceof t&&n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},t.prototype["throw"]=t.prototype.thenThrow=function(t){return this._then(n,void 0,void 0,{reason:t},void 0)},t.prototype.catchThrow=function(t){if(arguments.length<=1)return this._then(void 0,n,void 0,{reason:t},void 0);var e=arguments[1],r=function(){throw e};return this.caught(t,r)},t.prototype.catchReturn=function(n){if(arguments.length<=1)return n instanceof t&&n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);var r=arguments[1];r instanceof t&&r.suppressUnhandledRejections();var i=function(){return r};return this.caught(n,i)}}},{}],11:[function(t,e,n){"use strict";e.exports=function(t,e){function n(){return o(this)}function r(t,n){return i(t,n,e,e)}var i=t.reduce,o=t.all;t.prototype.each=function(t){return this.mapSeries(t)._then(n,void 0,void 0,this,void 0)},t.prototype.mapSeries=function(t){return i(this,t,e,e)},t.each=function(t,e){return r(t,e)._then(n,void 0,void 0,t,void 0)},t.mapSeries=r}},{}],12:[function(t,e,n){"use strict";function r(t,e){function n(r){return this instanceof n?(p(this,"message","string"==typeof r?r:e),p(this,"name",t),void(Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this))):new n(r)}return u(n,Error),n}function i(t){return this instanceof i?(p(this,"name","OperationalError"),p(this,"message",t),this.cause=t,this.isOperational=!0,void(t instanceof Error?(p(this,"message",t.message),p(this,"stack",t.stack)):Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor))):new i(t)}var o,s,a=t("./es5"),c=a.freeze,l=t("./util"),u=l.inherits,p=l.notEnumerableProp,h=r("Warning","warning"),f=r("CancellationError","cancellation error"),_=r("TimeoutError","timeout error"),d=r("AggregateError","aggregate error");try{o=TypeError,s=RangeError}catch(v){o=r("TypeError","type error"),s=r("RangeError","range error")}for(var y="join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "),m=0;m<y.length;++m)"function"==typeof Array.prototype[y[m]]&&(d.prototype[y[m]]=Array.prototype[y[m]]);a.defineProperty(d.prototype,"length",{value:0,configurable:!1,writable:!0,enumerable:!0}),d.prototype.isOperational=!0;var g=0;d.prototype.toString=function(){var t=Array(4*g+1).join(" "),e="\n"+t+"AggregateError of:\n";g++,t=Array(4*g+1).join(" ");for(var n=0;n<this.length;++n){for(var r=this[n]===this?"[Circular AggregateError]":this[n]+"",i=r.split("\n"),o=0;o<i.length;++o)i[o]=t+i[o];r=i.join("\n"),e+=r+"\n"}return g--,e},u(i,Error);var b=Error.__BluebirdErrorTypes__;b||(b=c({CancellationError:f,TimeoutError:_,OperationalError:i,RejectionError:i,AggregateError:d}),a.defineProperty(Error,"__BluebirdErrorTypes__",{value:b,writable:!1,enumerable:!1,configurable:!1})),e.exports={Error:Error,TypeError:o,RangeError:s,CancellationError:b.CancellationError,OperationalError:b.OperationalError,TimeoutError:b.TimeoutError,AggregateError:b.AggregateError,Warning:h}},{"./es5":13,"./util":36}],13:[function(t,e,n){var r=function(){"use strict";return void 0===this}();if(r)e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:function(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return!(n&&!n.writable&&!n.set)}};else{var i={}.hasOwnProperty,o={}.toString,s={}.constructor.prototype,a=function(t){var e=[];for(var n in t)i.call(t,n)&&e.push(n);return e},c=function(t,e){return{value:t[e]}},l=function(t,e,n){return t[e]=n.value,t},u=function(t){return t},p=function(t){try{return Object(t).constructor.prototype}catch(e){return s}},h=function(t){try{return"[object Array]"===o.call(t)}catch(e){return!1}};e.exports={isArray:h,keys:a,names:a,defineProperty:l,getDescriptor:c,freeze:u,getPrototypeOf:p,isES5:r,propertyIsWritable:function(){return!0}}}},{}],14:[function(t,e,n){"use strict";e.exports=function(t,e){var n=t.map;t.prototype.filter=function(t,r){return n(this,t,r,e)},t.filter=function(t,r,i){return n(t,r,i,e)}}},{}],15:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,e,n){this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null}function i(t){this.finallyHandler=t}function o(t,e){return null!=t.cancelPromise?(arguments.length>1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0):!1}function s(){return c.call(this,this.promise._target()._settledValue())}function a(t){return o(this,t)?void 0:(p.e=t,p)}function c(t){var r=this.promise,c=this.handler;if(!this.called){this.called=!0;var l=this.isFinallyHandler()?c.call(r._boundValue()):c.call(r._boundValue(),t);if(void 0!==l){r._setReturnedNonUndefined();var h=n(l,r);if(h instanceof e){if(null!=this.cancelPromise){if(h.isCancelled()){var f=new u("late cancellation observer");return r._attachExtraTrace(f),p.e=f,p}h.isPending()&&h._attachCancellationCallback(new i(this))}return h._then(s,a,void 0,this,void 0)}}}return r.isRejected()?(o(this),p.e=t,p):(o(this),t)}var l=t("./util"),u=e.CancellationError,p=l.errorObj;return r.prototype.isFinallyHandler=function(){return 0===this.type},i.prototype._resultCancelled=function(){o(this.finallyHandler)},e.prototype._passThrough=function(t,e,n,i){return"function"!=typeof t?this.then():this._then(n,i,void 0,new r(this,e,t),void 0)},e.prototype.lastly=e.prototype["finally"]=function(t){return this._passThrough(t,0,c,c)},e.prototype.tap=function(t){return this._passThrough(t,1,c)},r}},{"./util":36}],16:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,n,r){for(var o=0;o<n.length;++o){r._pushContext();var s=f(n[o])(t);if(r._popContext(),s===h){r._pushContext();var a=e.reject(h.e);return r._popContext(),a}var c=i(s,r);if(c instanceof e)return c}return null}function c(t,n,i,o){if(s.cancellation()){var a=new e(r),c=this._finallyPromise=new e(r);this._promise=a.lastly(function(){return c}),a._captureStackTrace(),a._setOnCancel(this)}else{var l=this._promise=new e(r);l._captureStackTrace()}this._stack=o,this._generatorFunction=t,this._receiver=n,this._generator=void 0,this._yieldHandlers="function"==typeof i?[i].concat(_):_,this._yieldedPromise=null,this._cancellationPhase=!1}var l=t("./errors"),u=l.TypeError,p=t("./util"),h=p.errorObj,f=p.tryCatch,_=[];p.inherits(c,o),c.prototype._isResolved=function(){return null===this._promise},c.prototype._cleanup=function(){this._promise=this._generator=null,s.cancellation()&&null!==this._finallyPromise&&(this._finallyPromise._fulfill(),this._finallyPromise=null)},c.prototype._promiseCancelled=function(){if(!this._isResolved()){var t,n="undefined"!=typeof this._generator["return"];if(n)this._promise._pushContext(),t=f(this._generator["return"]).call(this._generator,void 0),this._promise._popContext();else{var r=new e.CancellationError("generator .return() sentinel");e.coroutine.returnSentinel=r,this._promise._attachExtraTrace(r),this._promise._pushContext(),t=f(this._generator["throw"]).call(this._generator,r),this._promise._popContext()}this._cancellationPhase=!0,this._yieldedPromise=null,this._continue(t)}},c.prototype._promiseFulfilled=function(t){this._yieldedPromise=null,this._promise._pushContext();var e=f(this._generator.next).call(this._generator,t);this._promise._popContext(),this._continue(e)},c.prototype._promiseRejected=function(t){this._yieldedPromise=null,this._promise._attachExtraTrace(t),this._promise._pushContext();var e=f(this._generator["throw"]).call(this._generator,t);this._promise._popContext(),this._continue(e)},c.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof e){var t=this._yieldedPromise;this._yieldedPromise=null,t.cancel()}},c.prototype.promise=function(){return this._promise},c.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver),this._receiver=this._generatorFunction=void 0,this._promiseFulfilled(void 0)},c.prototype._continue=function(t){var n=this._promise;if(t===h)return this._cleanup(),this._cancellationPhase?n.cancel():n._rejectCallback(t.e,!1);var r=t.value;if(t.done===!0)return this._cleanup(),this._cancellationPhase?n.cancel():n._resolveCallback(r);var o=i(r,this._promise);if(!(o instanceof e)&&(o=a(o,this._yieldHandlers,this._promise),null===o))return void this._promiseRejected(new u("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",r)+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));o=o._target();var s=o._bitField;0===(50397184&s)?(this._yieldedPromise=o,o._proxy(this,null)):0!==(33554432&s)?this._promiseFulfilled(o._value()):0!==(16777216&s)?this._promiseRejected(o._reason()):this._promiseCancelled()},e.coroutine=function(t,e){if("function"!=typeof t)throw new u("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var n=Object(e).yieldHandler,r=c,i=(new Error).stack;return function(){var e=t.apply(this,arguments),o=new r(void 0,void 0,n,i),s=o.promise();return o._generator=e,o._promiseFulfilled(void 0),s}},e.coroutine.addYieldHandler=function(t){if("function"!=typeof t)throw new u("expecting a function but got "+p.classString(t));_.push(t)},e.spawn=function(t){if(s.deprecated("Promise.spawn()","Promise.coroutine()"),"function"!=typeof t)return n("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var r=new c(t,this),i=r.promise();return r._run(e.spawn),i}}},{"./errors":12,"./util":36}],17:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){var o=t("./util");o.canEvaluate,o.tryCatch,o.errorObj;e.join=function(){var t,e=arguments.length-1;if(e>0&&"function"==typeof arguments[e]){t=arguments[e];var r}var i=[].slice.call(arguments);t&&i.pop();var r=new n(i).promise();return void 0!==t?r.spread(t):r}}},{"./util":36}],18:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,e,n,r){this.constructor$(t),this._promise._captureStackTrace();var i=l();this._callback=null===i?e:i.bind(e),
  this._preservedValues=r===o?new Array(this.length()):null,this._limit=n,this._inFlight=0,this._queue=n>=1?[]:f,this._init$(void 0,-2)}function c(t,n,i,o){if("function"!=typeof n)return r("expecting a function but got "+u.classString(n));var s=0;if(void 0!==i){if("object"!=typeof i||null===i)return e.reject(new TypeError("options argument must be an object but it is "+u.classString(i)));if("number"!=typeof i.concurrency)return e.reject(new TypeError("'concurrency' must be a number but it is "+u.classString(i.concurrency)));s=i.concurrency}return s="number"==typeof s&&isFinite(s)&&s>=1?s:0,new a(t,n,s,o).promise()}var l=e._getDomain,u=t("./util"),p=u.tryCatch,h=u.errorObj,f=[];u.inherits(a,n),a.prototype._init=function(){},a.prototype._promiseFulfilled=function(t,n){var r=this._values,o=this.length(),a=this._preservedValues,c=this._limit;if(0>n){if(n=-1*n-1,r[n]=t,c>=1&&(this._inFlight--,this._drainQueue(),this._isResolved()))return!0}else{if(c>=1&&this._inFlight>=c)return r[n]=t,this._queue.push(n),!1;null!==a&&(a[n]=t);var l=this._promise,u=this._callback,f=l._boundValue();l._pushContext();var _=p(u).call(f,t,n,o),d=l._popContext();if(s.checkForgottenReturns(_,d,null!==a?"Promise.filter":"Promise.map",l),_===h)return this._reject(_.e),!0;var v=i(_,this._promise);if(v instanceof e){v=v._target();var y=v._bitField;if(0===(50397184&y))return c>=1&&this._inFlight++,r[n]=v,v._proxy(this,-1*(n+1)),!1;if(0===(33554432&y))return 0!==(16777216&y)?(this._reject(v._reason()),!0):(this._cancel(),!0);_=v._value()}r[n]=_}var m=++this._totalResolved;return m>=o?(null!==a?this._filter(r,a):this._resolve(r),!0):!1},a.prototype._drainQueue=function(){for(var t=this._queue,e=this._limit,n=this._values;t.length>0&&this._inFlight<e;){if(this._isResolved())return;var r=t.pop();this._promiseFulfilled(n[r],r)}},a.prototype._filter=function(t,e){for(var n=e.length,r=new Array(n),i=0,o=0;n>o;++o)t[o]&&(r[i++]=e[o]);r.length=i,this._resolve(r)},a.prototype.preservedValues=function(){return this._preservedValues},e.prototype.map=function(t,e){return c(this,t,e,null)},e.map=function(t,e,n,r){return c(t,e,n,r)}}},{"./util":36}],19:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){var s=t("./util"),a=s.tryCatch;e.method=function(t){if("function"!=typeof t)throw new e.TypeError("expecting a function but got "+s.classString(t));return function(){var r=new e(n);r._captureStackTrace(),r._pushContext();var i=a(t).apply(this,arguments),s=r._popContext();return o.checkForgottenReturns(i,s,"Promise.method",r),r._resolveFromSyncValue(i),r}},e.attempt=e["try"]=function(t){if("function"!=typeof t)return i("expecting a function but got "+s.classString(t));var r=new e(n);r._captureStackTrace(),r._pushContext();var c;if(arguments.length>1){o.deprecated("calling Promise.try with more than 1 argument");var l=arguments[1],u=arguments[2];c=s.isArray(l)?a(t).apply(u,l):a(t).call(u,l)}else c=a(t)();var p=r._popContext();return o.checkForgottenReturns(c,p,"Promise.try",r),r._resolveFromSyncValue(c),r},e.prototype._resolveFromSyncValue=function(t){t===s.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0)}}},{"./util":36}],20:[function(t,e,n){"use strict";function r(t){return t instanceof Error&&u.getPrototypeOf(t)===Error.prototype}function i(t){var e;if(r(t)){e=new l(t),e.name=t.name,e.message=t.message,e.stack=t.stack;for(var n=u.keys(t),i=0;i<n.length;++i){var o=n[i];p.test(o)||(e[o]=t[o])}return e}return s.markAsOriginatingFromRejection(t),t}function o(t,e){return function(n,r){if(null!==t){if(n){var o=i(a(n));t._attachExtraTrace(o),t._reject(o)}else if(e){var s=[].slice.call(arguments,1);t._fulfill(s)}else t._fulfill(r);t=null}}}var s=t("./util"),a=s.maybeWrapAsError,c=t("./errors"),l=c.OperationalError,u=t("./es5"),p=/^(?:name|message|stack|cause)$/;e.exports=o},{"./errors":12,"./es5":13,"./util":36}],21:[function(t,e,n){"use strict";e.exports=function(e){function n(t,e){var n=this;if(!o.isArray(t))return r.call(n,t,e);var i=a(e).apply(n._boundValue(),[null].concat(t));i===c&&s.throwLater(i.e)}function r(t,e){var n=this,r=n._boundValue(),i=void 0===t?a(e).call(r,null):a(e).call(r,null,t);i===c&&s.throwLater(i.e)}function i(t,e){var n=this;if(!t){var r=new Error(t+"");r.cause=t,t=r}var i=a(e).call(n._boundValue(),t);i===c&&s.throwLater(i.e)}var o=t("./util"),s=e._async,a=o.tryCatch,c=o.errorObj;e.prototype.asCallback=e.prototype.nodeify=function(t,e){if("function"==typeof t){var o=r;void 0!==e&&Object(e).spread&&(o=n),this._then(o,i,void 0,this,t)}return this}}},{"./util":36}],22:[function(t,e,n){"use strict";e.exports=function(){function n(){}function r(t,e){if("function"!=typeof e)throw new m("expecting a function but got "+f.classString(e));if(t.constructor!==i)throw new m("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n")}function i(t){this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,t!==b&&(r(this,t),this._resolveFromExecutor(t)),this._promiseCreated(),this._fireEvent("promiseCreated",this)}function o(t){this.promise._resolveCallback(t)}function s(t){this.promise._rejectCallback(t,!1)}function a(t){var e=new i(b);e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t}var c,l=function(){return new m("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")},u=function(){return new i.PromiseInspection(this._target())},p=function(t){return i.reject(new m(t))},h={},f=t("./util");c=f.isNode?function(){var t=process.domain;return void 0===t&&(t=null),t}:function(){return null},f.notEnumerableProp(i,"_getDomain",c);var _=t("./es5"),d=t("./async"),v=new d;_.defineProperty(i,"_async",{value:v});var y=t("./errors"),m=i.TypeError=y.TypeError;i.RangeError=y.RangeError;var g=i.CancellationError=y.CancellationError;i.TimeoutError=y.TimeoutError,i.OperationalError=y.OperationalError,i.RejectionError=y.OperationalError,i.AggregateError=y.AggregateError;var b=function(){},w={},C={},j=t("./thenables")(i,b),k=t("./promise_array")(i,b,j,p,n),E=t("./context")(i),F=E.create,x=t("./debuggability")(i,E),T=(x.CapturedTrace,t("./finally")(i,j)),P=t("./catch_filter")(C),R=t("./nodeback"),S=f.errorObj,O=f.tryCatch;return i.prototype.toString=function(){return"[object Promise]"},i.prototype.caught=i.prototype["catch"]=function(t){var e=arguments.length;if(e>1){var n,r=new Array(e-1),i=0;for(n=0;e-1>n;++n){var o=arguments[n];if(!f.isObject(o))return p("expecting an object but got "+f.classString(o));r[i++]=o}return r.length=i,t=arguments[n],this.then(void 0,P(r,t,this))}return this.then(void 0,t)},i.prototype.reflect=function(){return this._then(u,u,void 0,this,void 0)},i.prototype.then=function(t,e){if(x.warnings()&&arguments.length>0&&"function"!=typeof t&&"function"!=typeof e){var n=".then() only accepts functions but was passed: "+f.classString(t);arguments.length>1&&(n+=", "+f.classString(e)),this._warn(n)}return this._then(t,e,void 0,void 0,void 0)},i.prototype.done=function(t,e){var n=this._then(t,e,void 0,void 0,void 0);n._setIsFinal()},i.prototype.spread=function(t){return"function"!=typeof t?p("expecting a function but got "+f.classString(t)):this.all()._then(t,void 0,void 0,w,void 0)},i.prototype.toJSON=function(){var t={isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&&(t.rejectionReason=this.reason(),t.isRejected=!0),t},i.prototype.all=function(){return arguments.length>0&&this._warn(".all() was passed arguments but it does not take any"),new k(this).promise()},i.prototype.error=function(t){return this.caught(f.originatesFromRejection,t)},i.getNewLibraryCopy=e.exports,i.is=function(t){return t instanceof i},i.fromNode=i.fromCallback=function(t){var e=new i(b);e._captureStackTrace();var n=arguments.length>1?!!Object(arguments[1]).multiArgs:!1,r=O(t)(R(e,n));return r===S&&e._rejectCallback(r.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},i.all=function(t){return new k(t).promise()},i.cast=function(t){var e=j(t);return e instanceof i||(e=new i(b),e._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},i.resolve=i.fulfilled=i.cast,i.reject=i.rejected=function(t){var e=new i(b);return e._captureStackTrace(),e._rejectCallback(t,!0),e},i.setScheduler=function(t){if("function"!=typeof t)throw new m("expecting a function but got "+f.classString(t));return v.setScheduler(t)},i.prototype._then=function(t,e,n,r,o){var s=void 0!==o,a=s?o:new i(b),l=this._target(),u=l._bitField;s||(a._propagateFrom(this,3),a._captureStackTrace(),void 0===r&&0!==(2097152&this._bitField)&&(r=0!==(50397184&u)?this._boundValue():l===this?void 0:this._boundTo),this._fireEvent("promiseChained",this,a));var p=c();if(0!==(50397184&u)){var h,f,_=l._settlePromiseCtx;0!==(33554432&u)?(f=l._rejectionHandler0,h=t):0!==(16777216&u)?(f=l._fulfillmentHandler0,h=e,l._unsetRejectionIsUnhandled()):(_=l._settlePromiseLateCancellationObserver,f=new g("late cancellation observer"),l._attachExtraTrace(f),h=e),v.invoke(_,l,{handler:null===p?h:"function"==typeof h&&p.bind(h),promise:a,receiver:r,value:f})}else l._addCallbacks(t,e,a,r,p);return a},i.prototype._length=function(){return 65535&this._bitField},i.prototype._isFateSealed=function(){return 0!==(117506048&this._bitField)},i.prototype._isFollowing=function(){return 67108864===(67108864&this._bitField)},i.prototype._setLength=function(t){this._bitField=-65536&this._bitField|65535&t},i.prototype._setFulfilled=function(){this._bitField=33554432|this._bitField,this._fireEvent("promiseFulfilled",this)},i.prototype._setRejected=function(){this._bitField=16777216|this._bitField,this._fireEvent("promiseRejected",this)},i.prototype._setFollowing=function(){this._bitField=67108864|this._bitField,this._fireEvent("promiseResolved",this)},i.prototype._setIsFinal=function(){this._bitField=4194304|this._bitField},i.prototype._isFinal=function(){return(4194304&this._bitField)>0},i.prototype._unsetCancelled=function(){this._bitField=-65537&this._bitField},i.prototype._setCancelled=function(){this._bitField=65536|this._bitField,this._fireEvent("promiseCancelled",this)},i.prototype._setAsyncGuaranteed=function(){v.hasCustomScheduler()||(this._bitField=134217728|this._bitField)},i.prototype._receiverAt=function(t){var e=0===t?this._receiver0:this[4*t-4+3];return e===h?void 0:void 0===e&&this._isBound()?this._boundValue():e},i.prototype._promiseAt=function(t){return this[4*t-4+2]},i.prototype._fulfillmentHandlerAt=function(t){return this[4*t-4+0]},i.prototype._rejectionHandlerAt=function(t){return this[4*t-4+1]},i.prototype._boundValue=function(){},i.prototype._migrateCallback0=function(t){var e=(t._bitField,t._fulfillmentHandler0),n=t._rejectionHandler0,r=t._promise0,i=t._receiverAt(0);void 0===i&&(i=h),this._addCallbacks(e,n,r,i,null)},i.prototype._migrateCallbackAt=function(t,e){var n=t._fulfillmentHandlerAt(e),r=t._rejectionHandlerAt(e),i=t._promiseAt(e),o=t._receiverAt(e);void 0===o&&(o=h),this._addCallbacks(n,r,i,o,null)},i.prototype._addCallbacks=function(t,e,n,r,i){var o=this._length();if(o>=65531&&(o=0,this._setLength(0)),0===o)this._promise0=n,this._receiver0=r,"function"==typeof t&&(this._fulfillmentHandler0=null===i?t:i.bind(t)),"function"==typeof e&&(this._rejectionHandler0=null===i?e:i.bind(e));else{var s=4*o-4;this[s+2]=n,this[s+3]=r,"function"==typeof t&&(this[s+0]=null===i?t:i.bind(t)),"function"==typeof e&&(this[s+1]=null===i?e:i.bind(e))}return this._setLength(o+1),o},i.prototype._proxy=function(t,e){this._addCallbacks(void 0,void 0,e,t,null)},i.prototype._resolveCallback=function(t,e){if(0===(117506048&this._bitField)){if(t===this)return this._rejectCallback(l(),!1);var n=j(t,this);if(!(n instanceof i))return this._fulfill(t);e&&this._propagateFrom(n,2);var r=n._target();if(r===this)return void this._reject(l());var o=r._bitField;if(0===(50397184&o)){var s=this._length();s>0&&r._migrateCallback0(this);for(var a=1;s>a;++a)r._migrateCallbackAt(this,a);this._setFollowing(),this._setLength(0),this._setFollowee(r)}else if(0!==(33554432&o))this._fulfill(r._value());else if(0!==(16777216&o))this._reject(r._reason());else{var c=new g("late cancellation observer");r._attachExtraTrace(c),this._reject(c)}}},i.prototype._rejectCallback=function(t,e,n){var r=f.ensureErrorObject(t),i=r===t;if(!i&&!n&&x.warnings()){var o="a promise was rejected with a non-error: "+f.classString(t);this._warn(o,!0)}this._attachExtraTrace(r,e?i:!1),this._reject(t)},i.prototype._resolveFromExecutor=function(t){var e=this;this._captureStackTrace(),this._pushContext();var n=!0,r=this._execute(t,function(t){e._resolveCallback(t)},function(t){e._rejectCallback(t,n)});n=!1,this._popContext(),void 0!==r&&e._rejectCallback(r,!0)},i.prototype._settlePromiseFromHandler=function(t,e,n,r){var i=r._bitField;if(0===(65536&i)){r._pushContext();var o;e===w?n&&"number"==typeof n.length?o=O(t).apply(this._boundValue(),n):(o=S,o.e=new m("cannot .spread() a non-array: "+f.classString(n))):o=O(t).call(e,n);var s=r._popContext();i=r._bitField,0===(65536&i)&&(o===C?r._reject(n):o===S?r._rejectCallback(o.e,!1):(x.checkForgottenReturns(o,s,"",r,this),r._resolveCallback(o)))}},i.prototype._target=function(){for(var t=this;t._isFollowing();)t=t._followee();return t},i.prototype._followee=function(){return this._rejectionHandler0},i.prototype._setFollowee=function(t){this._rejectionHandler0=t},i.prototype._settlePromise=function(t,e,r,o){var s=t instanceof i,a=this._bitField,c=0!==(134217728&a);0!==(65536&a)?(s&&t._invokeInternalOnCancel(),r instanceof T&&r.isFinallyHandler()?(r.cancelPromise=t,O(e).call(r,o)===S&&t._reject(S.e)):e===u?t._fulfill(u.call(r)):r instanceof n?r._promiseCancelled(t):s||t instanceof k?t._cancel():r.cancel()):"function"==typeof e?s?(c&&t._setAsyncGuaranteed(),this._settlePromiseFromHandler(e,r,o,t)):e.call(r,o,t):r instanceof n?r._isResolved()||(0!==(33554432&a)?r._promiseFulfilled(o,t):r._promiseRejected(o,t)):s&&(c&&t._setAsyncGuaranteed(),0!==(33554432&a)?t._fulfill(o):t._reject(o))},i.prototype._settlePromiseLateCancellationObserver=function(t){var e=t.handler,n=t.promise,r=t.receiver,o=t.value;"function"==typeof e?n instanceof i?this._settlePromiseFromHandler(e,r,o,n):e.call(r,o,n):n instanceof i&&n._reject(o)},i.prototype._settlePromiseCtx=function(t){this._settlePromise(t.promise,t.handler,t.receiver,t.value)},i.prototype._settlePromise0=function(t,e,n){var r=this._promise0,i=this._receiverAt(0);this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,i,e)},i.prototype._clearCallbackDataAtIndex=function(t){var e=4*t-4;this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0},i.prototype._fulfill=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(t===this){var n=l();return this._attachExtraTrace(n),this._reject(n)}this._setFulfilled(),this._rejectionHandler0=t,(65535&e)>0&&(0!==(134217728&e)?this._settlePromises():v.settlePromises(this))}},i.prototype._reject=function(t){var e=this._bitField;if(!((117506048&e)>>>16))return this._setRejected(),this._fulfillmentHandler0=t,this._isFinal()?v.fatalError(t,f.isNode):void((65535&e)>0?v.settlePromises(this):this._ensurePossibleRejectionHandled())},i.prototype._fulfillPromises=function(t,e){for(var n=1;t>n;n++){var r=this._fulfillmentHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},i.prototype._rejectPromises=function(t,e){for(var n=1;t>n;n++){var r=this._rejectionHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},i.prototype._settlePromises=function(){var t=this._bitField,e=65535&t;if(e>0){if(0!==(16842752&t)){var n=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n)}else{var r=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r)}this._setLength(0)}this._clearCancellationData()},i.prototype._settledValue=function(){var t=this._bitField;return 0!==(33554432&t)?this._rejectionHandler0:0!==(16777216&t)?this._fulfillmentHandler0:void 0},i.defer=i.pending=function(){x.deprecated("Promise.defer","new Promise");var t=new i(b);return{promise:t,resolve:o,reject:s}},f.notEnumerableProp(i,"_makeSelfResolutionError",l),t("./method")(i,b,j,p,x),t("./bind")(i,b,j,x),t("./cancel")(i,k,p,x),t("./direct_resolve")(i),t("./synchronous_inspection")(i),t("./join")(i,k,j,b,x),i.Promise=i,i.version="3.4.0",t("./map.js")(i,k,p,j,b,x),t("./call_get.js")(i),t("./using.js")(i,p,j,F,b,x),t("./timers.js")(i,b,x),t("./generators.js")(i,p,b,j,n,x),t("./nodeify.js")(i),t("./promisify.js")(i,b),t("./props.js")(i,k,j,p),t("./race.js")(i,b,j,p),t("./reduce.js")(i,k,p,j,b,x),t("./settle.js")(i,k,x),t("./some.js")(i,k,p),t("./filter.js")(i,b),t("./each.js")(i,b),t("./any.js")(i),f.toFastProperties(i),f.toFastProperties(i.prototype),a({a:1}),a({b:2}),a({c:3}),a(1),a(function(){}),a(void 0),a(!1),a(new i(b)),x.setBounds(d.firstLineError,f.lastLineError),i}},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){function s(t){switch(t){case-2:return[];case-3:return{}}}function a(t){var r=this._promise=new e(n);t instanceof e&&r._propagateFrom(t,3),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2)}var c=t("./util");c.isArray;return c.inherits(a,o),a.prototype.length=function(){return this._length},a.prototype.promise=function(){return this._promise},a.prototype._init=function l(t,n){var o=r(this._values,this._promise);if(o instanceof e){o=o._target();var a=o._bitField;if(this._values=o,0===(50397184&a))return this._promise._setAsyncGuaranteed(),o._then(l,this._reject,void 0,this,n);if(0===(33554432&a))return 0!==(16777216&a)?this._reject(o._reason()):this._cancel();o=o._value()}if(o=c.asArray(o),null===o){var u=i("expecting an array or an iterable object but got "+c.classString(o)).reason();return void this._promise._rejectCallback(u,!1)}return 0===o.length?void(-5===n?this._resolveEmptyArray():this._resolve(s(n))):void this._iterate(o)},a.prototype._iterate=function(t){var n=this.getActualLength(t.length);this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;for(var i=this._promise,o=!1,s=null,a=0;n>a;++a){var c=r(t[a],i);c instanceof e?(c=c._target(),s=c._bitField):s=null,o?null!==s&&c.suppressUnhandledRejections():null!==s?0===(50397184&s)?(c._proxy(this,a),this._values[a]=c):o=0!==(33554432&s)?this._promiseFulfilled(c._value(),a):0!==(16777216&s)?this._promiseRejected(c._reason(),a):this._promiseCancelled(a):o=this._promiseFulfilled(c,a)}o||i._setAsyncGuaranteed()},a.prototype._isResolved=function(){return null===this._values},a.prototype._resolve=function(t){this._values=null,this._promise._fulfill(t)},a.prototype._cancel=function(){!this._isResolved()&&this._promise.isCancellable()&&(this._values=null,this._promise._cancel())},a.prototype._reject=function(t){this._values=null,this._promise._rejectCallback(t,!1)},a.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;return n>=this._length?(this._resolve(this._values),!0):!1},a.prototype._promiseCancelled=function(){return this._cancel(),!0},a.prototype._promiseRejected=function(t){return this._totalResolved++,this._reject(t),!0},a.prototype._resultCancelled=function(){if(!this._isResolved()){var t=this._values;if(this._cancel(),t instanceof e)t.cancel();else for(var n=0;n<t.length;++n)t[n]instanceof e&&t[n].cancel()}},a.prototype.shouldCopyValues=function(){return!0},a.prototype.getActualLength=function(t){return t},a}},{"./util":36}],24:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t){return!C.test(t)}function i(t){try{return t.__isPromisified__===!0}catch(e){return!1}}function o(t,e,n){var r=f.getDataPropertyOrDefault(t,e+n,b);return r?i(r):!1}function s(t,e,n){for(var r=0;r<t.length;r+=2){var i=t[r];if(n.test(i))for(var o=i.replace(n,""),s=0;s<t.length;s+=2)if(t[s]===o)throw new m("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",e))}}function a(t,e,n,r){for(var a=f.inheritedDataKeys(t),c=[],l=0;l<a.length;++l){var u=a[l],p=t[u],h=r===j?!0:j(u,p,t);"function"!=typeof p||i(p)||o(t,u,e)||!r(u,p,t,h)||c.push(u,p)}return s(c,e,n),c}function c(t,r,i,o,s,a){function c(){var i=r;r===h&&(i=this);var o=new e(n);o._captureStackTrace();var s="string"==typeof u&&this!==l?this[u]:t,c=_(o,a);try{s.apply(i,d(arguments,c))}catch(p){o._rejectCallback(v(p),!0,!0)}return o._isFateSealed()||o._setAsyncGuaranteed(),o}var l=function(){return this}(),u=t;return"string"==typeof u&&(t=o),f.notEnumerableProp(c,"__isPromisified__",!0),c}function l(t,e,n,r,i){for(var o=new RegExp(k(e)+"$"),s=a(t,e,o,n),c=0,l=s.length;l>c;c+=2){var u=s[c],p=s[c+1],_=u+e;if(r===E)t[_]=E(u,h,u,p,e,i);else{var d=r(p,function(){return E(u,h,u,p,e,i)});f.notEnumerableProp(d,"__isPromisified__",!0),t[_]=d}}return f.toFastProperties(t),t}function u(t,e,n){return E(t,e,void 0,t,null,n)}var p,h={},f=t("./util"),_=t("./nodeback"),d=f.withAppended,v=f.maybeWrapAsError,y=f.canEvaluate,m=t("./errors").TypeError,g="Async",b={__isPromisified__:!0},w=["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"],C=new RegExp("^(?:"+w.join("|")+")$"),j=function(t){return f.isIdentifier(t)&&"_"!==t.charAt(0)&&"constructor"!==t},k=function(t){return t.replace(/([$])/,"\\$")},E=y?p:c;e.promisify=function(t,e){if("function"!=typeof t)throw new m("expecting a function but got "+f.classString(t));if(i(t))return t;e=Object(e);var n=void 0===e.context?h:e.context,o=!!e.multiArgs,s=u(t,n,o);return f.copyDescriptors(t,s,r),s},e.promisifyAll=function(t,e){if("function"!=typeof t&&"object"!=typeof t)throw new m("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");e=Object(e);var n=!!e.multiArgs,r=e.suffix;"string"!=typeof r&&(r=g);var i=e.filter;"function"!=typeof i&&(i=j);var o=e.promisifier;if("function"!=typeof o&&(o=E),!f.isIdentifier(r))throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");for(var s=f.inheritedDataKeys(t),a=0;a<s.length;++a){var c=t[s[a]];"constructor"!==s[a]&&f.isClass(c)&&(l(c.prototype,r,i,o,n),l(c,r,i,o,n))}return l(t,r,i,o,n)}}},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){function o(t){var e,n=!1;if(void 0!==a&&t instanceof a)e=p(t),n=!0;else{var r=u.keys(t),i=r.length;e=new Array(2*i);for(var o=0;i>o;++o){var s=r[o];e[o]=t[s],e[o+i]=s}}this.constructor$(e),this._isMap=n,this._init$(void 0,-3)}function s(t){var n,s=r(t);return l(s)?(n=s instanceof e?s._then(e.props,void 0,void 0,void 0,void 0):new o(s).promise(),s instanceof e&&n._propagateFrom(s,2),n):i("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n")}var a,c=t("./util"),l=c.isObject,u=t("./es5");"function"==typeof Map&&(a=Map);var p=function(){function t(t,r){this[e]=t,this[e+n]=r,e++}var e=0,n=0;return function(r){n=r.size,e=0;var i=new Array(2*r.size);return r.forEach(t,i),i}}(),h=function(t){for(var e=new a,n=t.length/2|0,r=0;n>r;++r){var i=t[n+r],o=t[r];e.set(i,o)}return e};c.inherits(o,n),o.prototype._init=function(){},o.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;if(n>=this._length){var r;if(this._isMap)r=h(this._values);else{r={};for(var i=this.length(),o=0,s=this.length();s>o;++o)r[this._values[o+i]]=this._values[o]}return this._resolve(r),!0}return!1},o.prototype.shouldCopyValues=function(){return!1},o.prototype.getActualLength=function(t){return t>>1},e.prototype.props=function(){return s(this)},e.props=function(t){return s(t)}}},{"./es5":13,"./util":36}],26:[function(t,e,n){"use strict";function r(t,e,n,r,i){for(var o=0;i>o;++o)n[o+r]=t[o+e],t[o+e]=void 0}function i(t){this._capacity=t,this._length=0,this._front=0}i.prototype._willBeOverCapacity=function(t){return this._capacity<t},i.prototype._pushOne=function(t){var e=this.length();this._checkCapacity(e+1);var n=this._front+e&this._capacity-1;this[n]=t,this._length=e+1},i.prototype._unshiftOne=function(t){var e=this._capacity;this._checkCapacity(this.length()+1);var n=this._front,r=(n-1&e-1^e)-e;this[r]=t,this._front=r,this._length=this.length()+1},i.prototype.unshift=function(t,e,n){this._unshiftOne(n),this._unshiftOne(e),this._unshiftOne(t)},i.prototype.push=function(t,e,n){var r=this.length()+3;if(this._willBeOverCapacity(r))return this._pushOne(t),this._pushOne(e),void this._pushOne(n);var i=this._front+r-3;this._checkCapacity(r);var o=this._capacity-1;this[i+0&o]=t,this[i+1&o]=e,this[i+2&o]=n,this._length=r},i.prototype.shift=function(){var t=this._front,e=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length--,e},i.prototype.length=function(){return this._length},i.prototype._checkCapacity=function(t){this._capacity<t&&this._resizeTo(this._capacity<<1)},i.prototype._resizeTo=function(t){var e=this._capacity;this._capacity=t;var n=this._front,i=this._length,o=n+i&e-1;r(this,0,this,e,o)},e.exports=i},{}],27:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){function o(t,o){var c=r(t);if(c instanceof e)return a(c);if(t=s.asArray(t),null===t)return i("expecting an array or an iterable object but got "+s.classString(t));var l=new e(n);void 0!==o&&l._propagateFrom(o,3);for(var u=l._fulfill,p=l._reject,h=0,f=t.length;f>h;++h){var _=t[h];(void 0!==_||h in t)&&e.cast(_)._then(u,p,void 0,l,null)}return l}var s=t("./util"),a=function(t){return t.then(function(e){return o(e,t)})};e.race=function(t){return o(t,void 0)},e.prototype.race=function(){return o(this,void 0)}}},{"./util":36}],28:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,n,r,i){this.constructor$(t);var s=h();this._fn=null===s?n:s.bind(n),void 0!==r&&(r=e.resolve(r),r._attachCancellationCallback(this)),this._initialValue=r,this._currentCancellable=null,this._eachValues=i===o?[]:void 0,this._promise._captureStackTrace(),this._init$(void 0,-5)}function c(t,e){this.isFulfilled()?e._resolve(t):e._reject(t)}function l(t,e,n,i){if("function"!=typeof e)return r("expecting a function but got "+f.classString(e));var o=new a(t,e,n,i);return o.promise()}function u(t){this.accum=t,this.array._gotAccum(t);var n=i(this.value,this.array._promise);return n instanceof e?(this.array._currentCancellable=n,n._then(p,void 0,void 0,this,void 0)):p.call(this,n)}function p(t){var n=this.array,r=n._promise,i=_(n._fn);r._pushContext();var o;o=void 0!==n._eachValues?i.call(r._boundValue(),t,this.index,this.length):i.call(r._boundValue(),this.accum,t,this.index,this.length),o instanceof e&&(n._currentCancellable=o);var a=r._popContext();return s.checkForgottenReturns(o,a,void 0!==n._eachValues?"Promise.each":"Promise.reduce",r),o}var h=e._getDomain,f=t("./util"),_=f.tryCatch;f.inherits(a,n),a.prototype._gotAccum=function(t){void 0!==this._eachValues&&t!==o&&this._eachValues.push(t)},a.prototype._eachComplete=function(t){return this._eachValues.push(t),this._eachValues},a.prototype._init=function(){},a.prototype._resolveEmptyArray=function(){this._resolve(void 0!==this._eachValues?this._eachValues:this._initialValue)},a.prototype.shouldCopyValues=function(){return!1},a.prototype._resolve=function(t){this._promise._resolveCallback(t),this._values=null},a.prototype._resultCancelled=function(t){return t===this._initialValue?this._cancel():void(this._isResolved()||(this._resultCancelled$(),this._currentCancellable instanceof e&&this._currentCancellable.cancel(),this._initialValue instanceof e&&this._initialValue.cancel()))},a.prototype._iterate=function(t){this._values=t;var n,r,i=t.length;if(void 0!==this._initialValue?(n=this._initialValue,r=0):(n=e.resolve(t[0]),r=1),this._currentCancellable=n,!n.isRejected())for(;i>r;++r){var o={accum:null,value:t[r],index:r,length:i,array:this};n=n._then(u,void 0,void 0,o,void 0)}void 0!==this._eachValues&&(n=n._then(this._eachComplete,void 0,void 0,this,void 0)),n._then(c,c,void 0,n,this)},e.prototype.reduce=function(t,e){return l(this,t,e,null)},e.reduce=function(t,e,n,r){return l(t,e,n,r)}}},{"./util":36}],29:[function(t,e,n){"use strict";var r,i=t("./util"),o=function(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")},s=i.getNativePromise();if(i.isNode&&"undefined"==typeof MutationObserver){var a=global.setImmediate,c=process.nextTick;r=i.isRecentNode?function(t){a.call(global,t)}:function(t){c.call(process,t)}}else if("function"==typeof s){var l=s.resolve();r=function(t){l.then(t)}}else r="undefined"==typeof MutationObserver||"undefined"!=typeof window&&window.navigator&&window.navigator.standalone?"undefined"!=typeof setImmediate?function(t){setImmediate(t)}:"undefined"!=typeof setTimeout?function(t){setTimeout(t,0)}:o:function(){var t=document.createElement("div"),e={attributes:!0},n=!1,r=document.createElement("div"),i=new MutationObserver(function(){t.classList.toggle("foo"),n=!1});i.observe(r,e);var o=function(){n||(n=!0,r.classList.toggle("foo"))};return function(n){var r=new MutationObserver(function(){r.disconnect(),n()});r.observe(t,e),o()}}();e.exports=r},{"./util":36}],30:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){this.constructor$(t)}var o=e.PromiseInspection,s=t("./util");s.inherits(i,n),i.prototype._promiseResolved=function(t,e){this._values[t]=e;var n=++this._totalResolved;return n>=this._length?(this._resolve(this._values),!0):!1},i.prototype._promiseFulfilled=function(t,e){var n=new o;return n._bitField=33554432,n._settledValueField=t,this._promiseResolved(e,n)},i.prototype._promiseRejected=function(t,e){var n=new o;return n._bitField=16777216,n._settledValueField=t,this._promiseResolved(e,n)},e.settle=function(t){return r.deprecated(".settle()",".reflect()"),new i(t).promise()},e.prototype.settle=function(){return e.settle(this)}}},{"./util":36}],31:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){this.constructor$(t),this._howMany=0,this._unwrap=!1,this._initialized=!1}function o(t,e){if((0|e)!==e||0>e)return r("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");var n=new i(t),o=n.promise();return n.setHowMany(e),n.init(),o}var s=t("./util"),a=t("./errors").RangeError,c=t("./errors").AggregateError,l=s.isArray,u={};s.inherits(i,n),i.prototype._init=function(){if(this._initialized){if(0===this._howMany)return void this._resolve([]);this._init$(void 0,-5);var t=l(this._values);!this._isResolved()&&t&&this._howMany>this._canPossiblyFulfill()&&this._reject(this._getRangeError(this.length()))}},i.prototype.init=function(){this._initialized=!0,this._init()},i.prototype.setUnwrap=function(){this._unwrap=!0},i.prototype.howMany=function(){return this._howMany},i.prototype.setHowMany=function(t){this._howMany=t},i.prototype._promiseFulfilled=function(t){return this._addFulfilled(t),this._fulfilled()===this.howMany()?(this._values.length=this.howMany(),1===this.howMany()&&this._unwrap?this._resolve(this._values[0]):this._resolve(this._values),!0):!1},i.prototype._promiseRejected=function(t){return this._addRejected(t),this._checkOutcome()},i.prototype._promiseCancelled=function(){return this._values instanceof e||null==this._values?this._cancel():(this._addRejected(u),this._checkOutcome())},i.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){for(var t=new c,e=this.length();e<this._values.length;++e)this._values[e]!==u&&t.push(this._values[e]);
  return t.length>0?this._reject(t):this._cancel(),!0}return!1},i.prototype._fulfilled=function(){return this._totalResolved},i.prototype._rejected=function(){return this._values.length-this.length()},i.prototype._addRejected=function(t){this._values.push(t)},i.prototype._addFulfilled=function(t){this._values[this._totalResolved++]=t},i.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected()},i.prototype._getRangeError=function(t){var e="Input array must contain at least "+this._howMany+" items but contains only "+t+" items";return new a(e)},i.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0))},e.some=function(t,e){return o(t,e)},e.prototype.some=function(t){return o(this,t)},e._SomePromiseArray=i}},{"./errors":12,"./util":36}],32:[function(t,e,n){"use strict";e.exports=function(t){function e(t){void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0)}e.prototype._settledValue=function(){return this._settledValueField};var n=e.prototype.value=function(){if(!this.isFulfilled())throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},r=e.prototype.error=e.prototype.reason=function(){if(!this.isRejected())throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},i=e.prototype.isFulfilled=function(){return 0!==(33554432&this._bitField)},o=e.prototype.isRejected=function(){return 0!==(16777216&this._bitField)},s=e.prototype.isPending=function(){return 0===(50397184&this._bitField)},a=e.prototype.isResolved=function(){return 0!==(50331648&this._bitField)};e.prototype.isCancelled=t.prototype._isCancelled=function(){return 65536===(65536&this._bitField)},t.prototype.isCancelled=function(){return this._target()._isCancelled()},t.prototype.isPending=function(){return s.call(this._target())},t.prototype.isRejected=function(){return o.call(this._target())},t.prototype.isFulfilled=function(){return i.call(this._target())},t.prototype.isResolved=function(){return a.call(this._target())},t.prototype.value=function(){return n.call(this._target())},t.prototype.reason=function(){var t=this._target();return t._unsetRejectionIsUnhandled(),r.call(t)},t.prototype._value=function(){return this._settledValue()},t.prototype._reason=function(){return this._unsetRejectionIsUnhandled(),this._settledValue()},t.PromiseInspection=e}},{}],33:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,r){if(u(t)){if(t instanceof e)return t;var i=o(t);if(i===l){r&&r._pushContext();var c=e.reject(i.e);return r&&r._popContext(),c}if("function"==typeof i){if(s(t)){var c=new e(n);return t._then(c._fulfill,c._reject,void 0,c,null),c}return a(t,i,r)}}return t}function i(t){return t.then}function o(t){try{return i(t)}catch(e){return l.e=e,l}}function s(t){try{return p.call(t,"_promise0")}catch(e){return!1}}function a(t,r,i){function o(t){a&&(a._resolveCallback(t),a=null)}function s(t){a&&(a._rejectCallback(t,p,!0),a=null)}var a=new e(n),u=a;i&&i._pushContext(),a._captureStackTrace(),i&&i._popContext();var p=!0,h=c.tryCatch(r).call(t,o,s);return p=!1,a&&h===l&&(a._rejectCallback(h.e,!0,!0),a=null),u}var c=t("./util"),l=c.errorObj,u=c.isObject,p={}.hasOwnProperty;return r}},{"./util":36}],34:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){this.handle=t}function o(t){return clearTimeout(this.handle),t}function s(t){throw clearTimeout(this.handle),t}var a=t("./util"),c=e.TimeoutError;i.prototype._resultCancelled=function(){clearTimeout(this.handle)};var l=function(t){return u(+this).thenReturn(t)},u=e.delay=function(t,o){var s,a;return void 0!==o?(s=e.resolve(o)._then(l,null,null,t,void 0),r.cancellation()&&o instanceof e&&s._setOnCancel(o)):(s=new e(n),a=setTimeout(function(){s._fulfill()},+t),r.cancellation()&&s._setOnCancel(new i(a))),s._setAsyncGuaranteed(),s};e.prototype.delay=function(t){return u(t,this)};var p=function(t,e,n){var r;r="string"!=typeof e?e instanceof Error?e:new c("operation timed out"):new c(e),a.markAsOriginatingFromRejection(r),t._attachExtraTrace(r),t._reject(r),null!=n&&n.cancel()};e.prototype.timeout=function(t,e){t=+t;var n,a,c=new i(setTimeout(function(){n.isPending()&&p(n,e,a)},t));return r.cancellation()?(a=this.then(),n=a._then(o,s,void 0,c,void 0),n._setOnCancel(c)):n=this._then(o,s,void 0,c,void 0),n}}},{"./util":36}],35:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t){setTimeout(function(){throw t},0)}function c(t){var e=r(t);return e!==t&&"function"==typeof t._isDisposable&&"function"==typeof t._getDisposer&&t._isDisposable()&&e._setDisposable(t._getDisposer()),e}function l(t,n){function i(){if(s>=l)return u._fulfill();var o=c(t[s++]);if(o instanceof e&&o._isDisposable()){try{o=r(o._getDisposer().tryDispose(n),t.promise)}catch(p){return a(p)}if(o instanceof e)return o._then(i,a,null,null,null)}i()}var s=0,l=t.length,u=new e(o);return i(),u}function u(t,e,n){this._data=t,this._promise=e,this._context=n}function p(t,e,n){this.constructor$(t,e,n)}function h(t){return u.isDisposer(t)?(this.resources[this.index]._setDisposable(t),t.promise()):t}function f(t){this.length=t,this.promise=null,this[t-1]=null}var _=t("./util"),d=t("./errors").TypeError,v=t("./util").inherits,y=_.errorObj,m=_.tryCatch,g={};u.prototype.data=function(){return this._data},u.prototype.promise=function(){return this._promise},u.prototype.resource=function(){return this.promise().isFulfilled()?this.promise().value():g},u.prototype.tryDispose=function(t){var e=this.resource(),n=this._context;void 0!==n&&n._pushContext();var r=e!==g?this.doDispose(e,t):null;return void 0!==n&&n._popContext(),this._promise._unsetDisposable(),this._data=null,r},u.isDisposer=function(t){return null!=t&&"function"==typeof t.resource&&"function"==typeof t.tryDispose},v(p,u),p.prototype.doDispose=function(t,e){var n=this.data();return n.call(t,t,e)},f.prototype._resultCancelled=function(){for(var t=this.length,n=0;t>n;++n){var r=this[n];r instanceof e&&r.cancel()}},e.using=function(){var t=arguments.length;if(2>t)return n("you must pass at least 2 arguments to Promise.using");var i=arguments[t-1];if("function"!=typeof i)return n("expecting a function but got "+_.classString(i));var o,a=!0;2===t&&Array.isArray(arguments[0])?(o=arguments[0],t=o.length,a=!1):(o=arguments,t--);for(var c=new f(t),p=0;t>p;++p){var d=o[p];if(u.isDisposer(d)){var v=d;d=d.promise(),d._setDisposable(v)}else{var g=r(d);g instanceof e&&(d=g._then(h,null,null,{resources:c,index:p},void 0))}c[p]=d}for(var b=new Array(c.length),p=0;p<b.length;++p)b[p]=e.resolve(c[p]).reflect();var w=e.all(b).then(function(t){for(var e=0;e<t.length;++e){var n=t[e];if(n.isRejected())return y.e=n.error(),y;if(!n.isFulfilled())return void w.cancel();t[e]=n.value()}C._pushContext(),i=m(i);var r=a?i.apply(void 0,t):i(t),o=C._popContext();return s.checkForgottenReturns(r,o,"Promise.using",C),r}),C=w.lastly(function(){var t=new e.PromiseInspection(w);return l(c,t)});return c.promise=C,C._setOnCancel(c),C},e.prototype._setDisposable=function(t){this._bitField=131072|this._bitField,this._disposer=t},e.prototype._isDisposable=function(){return(131072&this._bitField)>0},e.prototype._getDisposer=function(){return this._disposer},e.prototype._unsetDisposable=function(){this._bitField=-131073&this._bitField,this._disposer=void 0},e.prototype.disposer=function(t){if("function"==typeof t)return new p(t,this,i());throw new d}}},{"./errors":12,"./util":36}],36:[function(t,e,n){"use strict";function r(){try{var t=T;return T=null,t.apply(this,arguments)}catch(e){return x.e=e,x}}function i(t){return T=t,r}function o(t){return null==t||t===!0||t===!1||"string"==typeof t||"number"==typeof t}function s(t){return"function"==typeof t||"object"==typeof t&&null!==t}function a(t){return o(t)?new Error(v(t)):t}function c(t,e){var n,r=t.length,i=new Array(r+1);for(n=0;r>n;++n)i[n]=t[n];return i[n]=e,i}function l(t,e,n){if(!E.isES5)return{}.hasOwnProperty.call(t,e)?t[e]:void 0;var r=Object.getOwnPropertyDescriptor(t,e);return null!=r?null==r.get&&null==r.set?r.value:n:void 0}function u(t,e,n){if(o(t))return t;var r={value:n,configurable:!0,enumerable:!1,writable:!0};return E.defineProperty(t,e,r),t}function p(t){throw t}function h(t){try{if("function"==typeof t){var e=E.names(t.prototype),n=E.isES5&&e.length>1,r=e.length>0&&!(1===e.length&&"constructor"===e[0]),i=O.test(t+"")&&E.names(t).length>0;if(n||r||i)return!0}return!1}catch(o){return!1}}function f(t){function e(){}e.prototype=t;for(var n=8;n--;)new e;return t}function _(t){return A.test(t)}function d(t,e,n){for(var r=new Array(t),i=0;t>i;++i)r[i]=e+i+n;return r}function v(t){try{return t+""}catch(e){return"[no string representation]"}}function y(t){return null!==t&&"object"==typeof t&&"string"==typeof t.message&&"string"==typeof t.name}function m(t){try{u(t,"isOperational",!0)}catch(e){}}function g(t){return null==t?!1:t instanceof Error.__BluebirdErrorTypes__.OperationalError||t.isOperational===!0}function b(t){return y(t)&&E.propertyIsWritable(t,"stack")}function w(t){return{}.toString.call(t)}function C(t,e,n){for(var r=E.names(t),i=0;i<r.length;++i){var o=r[i];if(n(o))try{E.defineProperty(e,o,E.getDescriptor(t,o))}catch(s){}}}function j(t,e){return L?process.env[t]:e}function k(){if("function"==typeof Promise)try{var t=new Promise(function(){});if("[object Promise]"==={}.toString.call(t))return Promise}catch(e){}}var E=t("./es5"),F="undefined"==typeof navigator,x={e:{}},T,P="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0!==this?this:null,R=function(t,e){function n(){this.constructor=t,this.constructor$=e;for(var n in e.prototype)r.call(e.prototype,n)&&"$"!==n.charAt(n.length-1)&&(this[n+"$"]=e.prototype[n])}var r={}.hasOwnProperty;return n.prototype=e.prototype,t.prototype=new n,t.prototype},S=function(){var t=[Array.prototype,Object.prototype,Function.prototype],e=function(e){for(var n=0;n<t.length;++n)if(t[n]===e)return!0;return!1};if(E.isES5){var n=Object.getOwnPropertyNames;return function(t){for(var r=[],i=Object.create(null);null!=t&&!e(t);){var o;try{o=n(t)}catch(s){return r}for(var a=0;a<o.length;++a){var c=o[a];if(!i[c]){i[c]=!0;var l=Object.getOwnPropertyDescriptor(t,c);null!=l&&null==l.get&&null==l.set&&r.push(c)}}t=E.getPrototypeOf(t)}return r}}var r={}.hasOwnProperty;return function(n){if(e(n))return[];var i=[];t:for(var o in n)if(r.call(n,o))i.push(o);else{for(var s=0;s<t.length;++s)if(r.call(t[s],o))continue t;i.push(o)}return i}}(),O=/this\s*\.\s*\S+\s*=/,A=/^[a-z$_][a-z$_0-9]*$/i,D=function(){return"stack"in new Error?function(t){return b(t)?t:new Error(v(t))}:function(t){if(b(t))return t;try{throw new Error(v(t))}catch(e){return e}}}(),V=function(t){return E.isArray(t)?t:null};if("undefined"!=typeof Symbol&&Symbol.iterator){var I="function"==typeof Array.from?function(t){return Array.from(t)}:function(t){for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)n.push(e.value);return n};V=function(t){return E.isArray(t)?t:null!=t&&"function"==typeof t[Symbol.iterator]?I(t):null}}var L="undefined"!=typeof process&&"[object process]"===w(process).toLowerCase(),H={isClass:h,isIdentifier:_,inheritedDataKeys:S,getDataPropertyOrDefault:l,thrower:p,isArray:E.isArray,asArray:V,notEnumerableProp:u,isPrimitive:o,isObject:s,isError:y,canEvaluate:F,errorObj:x,tryCatch:i,inherits:R,withAppended:c,maybeWrapAsError:a,toFastProperties:f,filledRange:d,toString:v,canAttachTrace:b,ensureErrorObject:D,originatesFromRejection:g,markAsOriginatingFromRejection:m,classString:w,copyDescriptors:C,hasDevTools:"undefined"!=typeof chrome&&chrome&&"function"==typeof chrome.loadTimes,isNode:L,env:j,global:P,getNativePromise:k};H.isRecentNode=H.isNode&&function(){var t=process.versions.node.split(".").map(Number);return 0===t[0]&&t[1]>10||t[0]>0}(),H.isNode&&H.toFastProperties(process);try{throw new Error}catch(N){H.lastLineError=N}e.exports=H},{"./es5":13}]},{},[4])(4)}),"undefined"!=typeof window&&null!==window?window.P=window.Promise:"undefined"!=typeof self&&null!==self&&(self.P=self.Promise);
/*! Sizzle v2.3.0 | (c) jQuery Foundation, Inc. | jquery.org/license */
!function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\x00-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,ca=function(a,b){return b?"\x00"===a?"�":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"label"in b&&b.disabled===a||"form"in b&&b.disabled===a||"form"in b&&b.disabled===!1&&(b.isDisabled===a||b.isDisabled!==!a&&("label"in b||!ea(b))!==a)}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[0>c?c+b:c]}),even:pa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=Q.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e)}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,e>i&&ya(a.slice(i,e)),f>e&&ya(a=a.slice(e)),f>e&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(_,aa),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=V.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(_,aa),$.test(j[0].type)&&qa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&sa(j),!a)return G.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||$.test(a)&&qa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null});var Aa=a.Sizzle;ga.noConflict=function(){return a.Sizzle===ga&&(a.Sizzle=Aa),ga},"function"==typeof define&&define.amd?define(function(){return ga}):"undefined"!=typeof module&&module.exports?module.exports=ga:a.Sizzle=ga}(window);
//# sourceMappingURL=sizzle.min.map
(function(e,t){typeof define=="function"&&define.amd?define([],t):e.forge=t()})(this,function(){var e,t,n;return function(r){function v(e,t){return h.call(e,t)}function m(e,t){var n,r,i,s,o,u,a,f,c,h,p,v=t&&t.split("/"),m=l.map,g=m&&m["*"]||{};if(e&&e.charAt(0)===".")if(t){v=v.slice(0,v.length-1),e=e.split("/"),o=e.length-1,l.nodeIdCompat&&d.test(e[o])&&(e[o]=e[o].replace(d,"")),e=v.concat(e);for(c=0;c<e.length;c+=1){p=e[c];if(p===".")e.splice(c,1),c-=1;else if(p===".."){if(c===1&&(e[2]===".."||e[0]===".."))break;c>0&&(e.splice(c-1,2),c-=2)}}e=e.join("/")}else e.indexOf("./")===0&&(e=e.substring(2));if((v||g)&&m){n=e.split("/");for(c=n.length;c>0;c-=1){r=n.slice(0,c).join("/");if(v)for(h=v.length;h>0;h-=1){i=m[v.slice(0,h).join("/")];if(i){i=i[r];if(i){s=i,u=c;break}}}if(s)break;!a&&g&&g[r]&&(a=g[r],f=c)}!s&&a&&(s=a,u=f),s&&(n.splice(0,u,s),e=n.join("/"))}return e}function g(e,t){return function(){return s.apply(r,p.call(arguments,0).concat([e,t]))}}function y(e){return function(t){return m(t,e)}}function b(e){return function(t){a[e]=t}}function w(e){if(v(f,e)){var t=f[e];delete f[e],c[e]=!0,i.apply(r,t)}if(!v(a,e)&&!v(c,e))throw new Error("No "+e);return a[e]}function E(e){var t,n=e?e.indexOf("!"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function S(e){return function(){return l&&l.config&&l.config[e]||{}}}var i,s,o,u,a={},f={},l={},c={},h=Object.prototype.hasOwnProperty,p=[].slice,d=/\.js$/;o=function(e,t){var n,r=E(e),i=r[0];return e=r[1],i&&(i=m(i,t),n=w(i)),i?n&&n.normalize?e=n.normalize(e,y(t)):e=m(e,t):(e=m(e,t),r=E(e),i=r[0],e=r[1],i&&(n=w(i))),{f:i?i+"!"+e:e,n:e,pr:i,p:n}},u={require:function(e){return g(e)},exports:function(e){var t=a[e];return typeof t!="undefined"?t:a[e]={}},module:function(e){return{id:e,uri:"",exports:a[e],config:S(e)}}},i=function(e,t,n,i){var s,l,h,p,d,m=[],y=typeof n,E;i=i||e;if(y==="undefined"||y==="function"){t=!t.length&&n.length?["require","exports","module"]:t;for(d=0;d<t.length;d+=1){p=o(t[d],i),l=p.f;if(l==="require")m[d]=u.require(e);else if(l==="exports")m[d]=u.exports(e),E=!0;else if(l==="module")s=m[d]=u.module(e);else if(v(a,l)||v(f,l)||v(c,l))m[d]=w(l);else{if(!p.p)throw new Error(e+" missing "+l);p.p.load(p.n,g(i,!0),b(l),{}),m[d]=a[l]}}h=n?n.apply(a[e],m):undefined;if(e)if(s&&s.exports!==r&&s.exports!==a[e])a[e]=s.exports;else if(h!==r||!E)a[e]=h}else e&&(a[e]=n)},e=t=s=function(e,t,n,a,f){if(typeof e=="string")return u[e]?u[e](t):w(o(e,t).f);if(!e.splice){l=e,l.deps&&s(l.deps,l.callback);if(!t)return;t.splice?(e=t,t=n,n=null):e=r}return t=t||function(){},typeof n=="function"&&(n=a,a=f),a?i(r,e,t,n):setTimeout(function(){i(r,e,t,n)},4),s},s.config=function(e){return s(e)},e._defined=a,n=function(e,t,n){t.splice||(n=t,t=[]),!v(a,e)&&!v(f,e)&&(f[e]=[e,t,n])},n.amd={jQuery:!0}}(),n("node_modules/almond/almond",function(){}),function(){function e(e){function n(e){this.data="",this.read=0;if(typeof e=="string")this.data=e;else if(t.isArrayBuffer(e)||t.isArrayBufferView(e)){var r=new Uint8Array(e);try{this.data=String.fromCharCode.apply(null,r)}catch(i){for(var s=0;s<r.length;++s)this.putByte(r[s])}}else if(e instanceof n||typeof e=="object"&&typeof e.data=="string"&&typeof e.read=="number")this.data=e.data,this.read=e.read;this._constructedStringLength=0}function i(e,n){n=n||{},this.read=n.readOffset||0,this.growSize=n.growSize||1024;var r=t.isArrayBuffer(e),i=t.isArrayBufferView(e);if(r||i){r?this.data=new DataView(e):this.data=new DataView(e.buffer,e.byteOffset,e.byteLength),this.write="writeOffset"in n?n.writeOffset:this.data.byteLength;return}this.data=new DataView(new ArrayBuffer(0)),this.write=0,e!==null&&e!==undefined&&this.putBytes(e),"writeOffset"in n&&(this.write=n.writeOffset)}var t=e.util=e.util||{};(function(){if(typeof process!="undefined"&&process.nextTick){t.nextTick=process.nextTick,typeof setImmediate=="function"?t.setImmediate=setImmediate:t.setImmediate=t.nextTick;return}if(typeof setImmediate=="function"){t.setImmediate=setImmediate,t.nextTick=function(e){return setImmediate(e)};return}t.setImmediate=function(e){setTimeout(e,0)};if(typeof window!="undefined"&&typeof window.postMessage=="function"){var e="forge.setImmediate",n=[];t.setImmediate=function(t){n.push(t),n.length===1&&window.postMessage(e,"*")};function r(t){if(t.source===window&&t.data===e){t.stopPropagation();var r=n.slice();n.length=0,r.forEach(function(e){e()})}}window.addEventListener("message",r,!0)}if(typeof MutationObserver!="undefined"){var i=Date.now(),s=!0,o=document.createElement("div"),n=[];(new MutationObserver(function(){var e=n.slice();n.length=0,e.forEach(function(e){e()})})).observe(o,{attributes:!0});var u=t.setImmediate;t.setImmediate=function(e){Date.now()-i>15?(i=Date.now(),u(e)):(n.push(e),n.length===1&&o.setAttribute("a",s=!s))}}t.nextTick=t.setImmediate})(),t.isArray=Array.isArray||function(e){return Object.prototype.toString.call(e)==="[object Array]"},t.isArrayBuffer=function(e){return typeof ArrayBuffer!="undefined"&&e instanceof ArrayBuffer},t.isArrayBufferView=function(e){return e&&t.isArrayBuffer(e.buffer)&&e.byteLength!==undefined},t.ByteBuffer=n,t.ByteStringBuffer=n;var r=4096;t.ByteStringBuffer.prototype._optimizeConstructedString=function(e){this._constructedStringLength+=e,this._constructedStringLength>r&&(this.data.substr(0,1),this._constructedStringLength=0)},t.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read},t.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0},t.ByteStringBuffer.prototype.putByte=function(e){return this.putBytes(String.fromCharCode(e))},t.ByteStringBuffer.prototype.fillWithByte=function(e,t){e=String.fromCharCode(e);var n=this.data;while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return this.data=n,this._optimizeConstructedString(t),this},t.ByteStringBuffer.prototype.putBytes=function(e){return this.data+=e,this._optimizeConstructedString(e.length),this},t.ByteStringBuffer.prototype.putString=function(e){return this.putBytes(t.encodeUtf8(e))},t.ByteStringBuffer.prototype.putInt16=function(e){return this.putBytes(String.fromCharCode(e>>8&255)+String.fromCharCode(e&255))},t.ByteStringBuffer.prototype.putInt24=function(e){return this.putBytes(String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255))},t.ByteStringBuffer.prototype.putInt32=function(e){return this.putBytes(String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255))},t.ByteStringBuffer.prototype.putInt16Le=function(e){return this.putBytes(String.fromCharCode(e&255)+String.fromCharCode(e>>8&255))},t.ByteStringBuffer.prototype.putInt24Le=function(e){return this.putBytes(String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255))},t.ByteStringBuffer.prototype.putInt32Le=function(e){return this.putBytes(String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>24&255))},t.ByteStringBuffer.prototype.putInt=function(e,t){var n="";do t-=8,n+=String.fromCharCode(e>>t&255);while(t>0);return this.putBytes(n)},t.ByteStringBuffer.prototype.putSignedInt=function(e,t){return e<0&&(e+=2<<t-1),this.putInt(e,t)},t.ByteStringBuffer.prototype.putBuffer=function(e){return this.putBytes(e.getBytes())},t.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)},t.ByteStringBuffer.prototype.getInt16=function(){var e=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,e},t.ByteStringBuffer.prototype.getInt24=function(){var e=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,e},t.ByteStringBuffer.prototype.getInt32=function(){var e=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,e},t.ByteStringBuffer.prototype.getInt16Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,e},t.ByteStringBuffer.prototype.getInt24Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,e},t.ByteStringBuffer.prototype.getInt32Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,e},t.ByteStringBuffer.prototype.getInt=function(e){var t=0;do t=(t<<8)+this.data.charCodeAt(this.read++),e-=8;while(e>0);return t},t.ByteStringBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),n=2<<e-2;return t>=n&&(t-=n<<1),t},t.ByteStringBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):e===0?t="":(t=this.read===0?this.data:this.data.slice(this.read),this.clear()),t},t.ByteStringBuffer.prototype.bytes=function(e){return typeof e=="undefined"?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},t.ByteStringBuffer.prototype.at=function(e){return this.data.charCodeAt(this.read+e)},t.ByteStringBuffer.prototype.setAt=function(e,t){return this.data=this.data.substr(0,this.read+e)+String.fromCharCode(t)+this.data.substr(this.read+e+1),this},t.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)},t.ByteStringBuffer.prototype.copy=function(){var e=t.createBuffer(this.data);return e.read=this.read,e},t.ByteStringBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this},t.ByteStringBuffer.prototype.clear=function(){return this.data="",this.read=0,this},t.ByteStringBuffer.prototype.truncate=function(e){var t=Math.max(0,this.length()-e);return this.data=this.data.substr(this.read,t),this.read=0,this},t.ByteStringBuffer.prototype.toHex=function(){var e="";for(var t=this.read;t<this.data.length;++t){var n=this.data.charCodeAt(t);n<16&&(e+="0"),e+=n.toString(16)}return e},t.ByteStringBuffer.prototype.toString=function(){return t.decodeUtf8(this.bytes())},t.DataBuffer=i,t.DataBuffer.prototype.length=function(){return this.write-this.read},t.DataBuffer.prototype.isEmpty=function(){return this.length()<=0},t.DataBuffer.prototype.accommodate=function(e,t){if(this.length()>=e)return this;t=Math.max(t||this.growSize,e);var n=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength),r=new Uint8Array(this.length()+t);return r.set(n),this.data=new DataView(r.buffer),this},t.DataBuffer.prototype.putByte=function(e){return this.accommodate(1),this.data.setUint8(this.write++,e),this},t.DataBuffer.prototype.fillWithByte=function(e,t){this.accommodate(t);for(var n=0;n<t;++n)this.data.setUint8(e);return this},t.DataBuffer.prototype.putBytes=function(e,n){if(t.isArrayBufferView(e)){var r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),i=r.byteLength-r.byteOffset;this.accommodate(i);var s=new Uint8Array(this.data.buffer,this.write);return s.set(r),this.write+=i,this}if(t.isArrayBuffer(e)){var r=new Uint8Array(e);this.accommodate(r.byteLength);var s=new Uint8Array(this.data.buffer);return s.set(r,this.write),this.write+=r.byteLength,this}if(e instanceof t.DataBuffer||typeof e=="object"&&typeof e.read=="number"&&typeof e.write=="number"&&t.isArrayBufferView(e.data)){var r=new Uint8Array(e.data.byteLength,e.read,e.length());this.accommodate(r.byteLength);var s=new Uint8Array(e.data.byteLength,this.write);return s.set(r),this.write+=r.byteLength,this}e instanceof t.ByteStringBuffer&&(e=e.data,n="binary"),n=n||"binary";if(typeof e=="string"){var o;if(n==="hex")return this.accommodate(Math.ceil(e.length/2)),o=new Uint8Array(this.data.buffer,this.write),this.write+=t.binary.hex.decode(e,o,this.write),this;if(n==="base64")return this.accommodate(Math.ceil(e.length/4)*3),o=new Uint8Array(this.data.buffer,this.write),this.write+=t.binary.base64.decode(e,o,this.write),this;n==="utf8"&&(e=t.encodeUtf8(e),n="binary");if(n==="binary"||n==="raw")return this.accommodate(e.length),o=new Uint8Array(this.data.buffer,this.write),this.write+=t.binary.raw.decode(o),this;if(n==="utf16")return this.accommodate(e.length*2),o=new Uint16Array(this.data.buffer,this.write),this.write+=t.text.utf16.encode(o),this;throw new Error("Invalid encoding: "+n)}throw Error("Invalid parameter: "+e)},t.DataBuffer.prototype.putBuffer=function(e){return this.putBytes(e),e.clear(),this},t.DataBuffer.prototype.putString=function(e){return this.putBytes(e,"utf16")},t.DataBuffer.prototype.putInt16=function(e){return this.accommodate(2),this.data.setInt16(this.write,e),this.write+=2,this},t.DataBuffer.prototype.putInt24=function(e){return this.accommodate(3),this.data.setInt16(this.write,e>>8&65535),this.data.setInt8(this.write,e>>16&255),this.write+=3,this},t.DataBuffer.prototype.putInt32=function(e){return this.accommodate(4),this.data.setInt32(this.write,e),this.write+=4,this},t.DataBuffer.prototype.putInt16Le=function(e){return this.accommodate(2),this.data.setInt16(this.write,e,!0),this.write+=2,this},t.DataBuffer.prototype.putInt24Le=function(e){return this.accommodate(3),this.data.setInt8(this.write,e>>16&255),this.data.setInt16(this.write,e>>8&65535,!0),this.write+=3,this},t.DataBuffer.prototype.putInt32Le=function(e){return this.accommodate(4),this.data.setInt32(this.write,e,!0),this.write+=4,this},t.DataBuffer.prototype.putInt=function(e,t){this.accommodate(t/8);do t-=8,this.data.setInt8(this.write++,e>>t&255);while(t>0);return this},t.DataBuffer.prototype.putSignedInt=function(e,t){return this.accommodate(t/8),e<0&&(e+=2<<t-1),this.putInt(e,t)},t.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++)},t.DataBuffer.prototype.getInt16=function(){var e=this.data.getInt16(this.read);return this.read+=2,e},t.DataBuffer.prototype.getInt24=function(){var e=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);return this.read+=3,e},t.DataBuffer.prototype.getInt32=function(){var e=this.data.getInt32(this.read);return this.read+=4,e},t.DataBuffer.prototype.getInt16Le=function(){var e=this.data.getInt16(this.read,!0);return this.read+=2,e},t.DataBuffer.prototype.getInt24Le=function(){var e=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,!0)<<8;return this.read+=3,e},t.DataBuffer.prototype.getInt32Le=function(){var e=this.data.getInt32(this.read,!0);return this.read+=4,e},t.DataBuffer.prototype.getInt=function(e){var t=0;do t=(t<<8)+this.data.getInt8(this.read++),e-=8;while(e>0);return t},t.DataBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),n=2<<e-2;return t>=n&&(t-=n<<1),t},t.DataBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):e===0?t="":(t=this.read===0?this.data:this.data.slice(this.read),this.clear()),t},t.DataBuffer.prototype.bytes=function(e){return typeof e=="undefined"?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},t.DataBuffer.prototype.at=function(e){return this.data.getUint8(this.read+e)},t.DataBuffer.prototype.setAt=function(e,t){return this.data.setUint8(e,t),this},t.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1)},t.DataBuffer.prototype.copy=function(){return new t.DataBuffer(this)},t.DataBuffer.prototype.compact=function(){if(this.read>0){var e=new Uint8Array(this.data.buffer,this.read),t=new Uint8Array(e.byteLength);t.set(e),this.data=new DataView(t),this.write-=this.read,this.read=0}return this},t.DataBuffer.prototype.clear=function(){return this.data=new DataView(new ArrayBuffer(0)),this.read=this.write=0,this},t.DataBuffer.prototype.truncate=function(e){return this.write=Math.max(0,this.length()-e),this.read=Math.min(this.read,this.write),this},t.DataBuffer.prototype.toHex=function(){var e="";for(var t=this.read;t<this.data.byteLength;++t){var n=this.data.getUint8(t);n<16&&(e+="0"),e+=n.toString(16)}return e},t.DataBuffer.prototype.toString=function(e){var n=new Uint8Array(this.data,this.read,this.length());e=e||"utf8";if(e==="binary"||e==="raw")return t.binary.raw.encode(n);if(e==="hex")return t.binary.hex.encode(n);if(e==="base64")return t.binary.base64.encode(n);if(e==="utf8")return t.text.utf8.decode(n);if(e==="utf16")return t.text.utf16.decode(n);throw new Error("Invalid encoding: "+e)},t.createBuffer=function(e,n){return n=n||"raw",e!==undefined&&n==="utf8"&&(e=t.encodeUtf8(e)),new t.ByteBuffer(e)},t.fillString=function(e,t){var n="";while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return n},t.xorBytes=function(e,t,n){var r="",i="",s="",o=0,u=0;for(;n>0;--n,++o)i=e.charCodeAt(o)^t.charCodeAt(o),u>=10&&(r+=s,s="",u=0),s+=String.fromCharCode(i),++u;return r+=s,r},t.hexToBytes=function(e){var t="",n=0;e.length&!0&&(n=1,t+=String.fromCharCode(parseInt(e[0],16)));for(;n<e.length;n+=2)t+=String.fromCharCode(parseInt(e.substr(n,2),16));return t},t.bytesToHex=function(e){return t.createBuffer(e).toHex()},t.int32ToBytes=function(e){return String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255)};var s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",o=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];t.encode64=function(e,t){var n="",r="",i,o,u,a=0;while(a<e.length)i=e.charCodeAt(a++),o=e.charCodeAt(a++),u=e.charCodeAt(a++),n+=s.charAt(i>>2),n+=s.charAt((i&3)<<4|o>>4),isNaN(o)?n+="==":(n+=s.charAt((o&15)<<2|u>>6),n+=isNaN(u)?"=":s.charAt(u&63)),t&&n.length>t&&(r+=n.substr(0,t)+"\r\n",n=n.substr(t));return r+=n,r},t.decode64=function(e){e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");var t="",n,r,i,s,u=0;while(u<e.length)n=o[e.charCodeAt(u++)-43],r=o[e.charCodeAt(u++)-43],i=o[e.charCodeAt(u++)-43],s=o[e.charCodeAt(u++)-43],t+=String.fromCharCode(n<<2|r>>4),i!==64&&(t+=String.fromCharCode((r&15)<<4|i>>2),s!==64&&(t+=String.fromCharCode((i&3)<<6|s)));return t},t.encodeUtf8=function(e){return unescape(encodeURIComponent(e))},t.decodeUtf8=function(e){return decodeURIComponent(escape(e))},t.binary={raw:{},hex:{},base64:{}},t.binary.raw.encode=function(e){return String.fromCharCode.apply(null,e)},t.binary.raw.decode=function(e,t,n){var r=t;r||(r=new Uint8Array(e.length)),n=n||0;var i=n;for(var s=0;s<e.length;++s)r[i++]=e.charCodeAt(s);return t?i-n:r},t.binary.hex.encode=t.bytesToHex,t.binary.hex.decode=function(e,t,n){var r=t;r||(r=new Uint8Array(Math.ceil(e.length/2))),n=n||0;var i=0,s=n;e.length&1&&(i=1,r[s++]=parseInt(e[0],16));for(;i<e.length;i+=2)r[s++]=parseInt(e.substr(i,2),16);return t?s-n:r},t.binary.base64.encode=function(e,t){var n="",r="",i,o,u,a=0;while(a<e.byteLength)i=e[a++],o=e[a++],u=e[a++],n+=s.charAt(i>>2),n+=s.charAt((i&3)<<4|o>>4),isNaN(o)?n+="==":(n+=s.charAt((o&15)<<2|u>>6),n+=isNaN(u)?"=":s.charAt(u&63)),t&&n.length>t&&(r+=n.substr(0,t)+"\r\n",n=n.substr(t));return r+=n,r},t.binary.base64.decode=function(e,t,n){var r=t;r||(r=new Uint8Array(Math.ceil(e.length/4)*3)),e=e.replace(/[^A-Za-z0-9\+\/\=]/g,""),n=n||0;var i,s,u,a,f=0,l=n;while(f<e.length)i=o[e.charCodeAt(f++)-43],s=o[e.charCodeAt(f++)-43],u=o[e.charCodeAt(f++)-43],a=o[e.charCodeAt(f++)-43],r[l++]=i<<2|s>>4,u!==64&&(r[l++]=(s&15)<<4|u>>2,a!==64&&(r[l++]=(u&3)<<6|a));return t?l-n:r.subarray(0,l)},t.text={utf8:{},utf16:{}},t.text.utf8.encode=function(e,n,r){e=t.encodeUtf8(e);var i=n;i||(i=new Uint8Array(e.length)),r=r||0;var s=r;for(var o=0;o<e.length;++o)i[s++]=e.charCodeAt(o);return n?s-r:i},t.text.utf8.decode=function(e){return t.decodeUtf8(String.fromCharCode.apply(null,e))},t.text.utf16.encode=function(e,t,n){var r=t;r||(r=new Uint8Array(e.length));var i=new Uint16Array(r);n=n||0;var s=n,o=n;for(var u=0;u<e.length;++u)i[o++]=e.charCodeAt(u),s+=2;return t?s-n:r},t.text.utf16.decode=function(e){return String.fromCharCode.apply(null,new Uint16Array(e))},t.deflate=function(e,n,r){n=t.decode64(e.deflate(t.encode64(n)).rval);if(r){var i=2,s=n.charCodeAt(1);s&32&&(i=6),n=n.substring(i,n.length-4)}return n},t.inflate=function(e,n,r){var i=e.inflate(t.encode64(n)).rval;return i===null?null:t.decode64(i)};var u=function(e,n,r){if(!e)throw new Error("WebStorage not available.");var i;r===null?i=e.removeItem(n):(r=t.encode64(JSON.stringify(r)),i=e.setItem(n,r));if(typeof i!="undefined"&&i.rval!==!0){var s=new Error(i.error.message);throw s.id=i.error.id,s.name=i.error.name,s}},a=function(e,n){if(!e)throw new Error("WebStorage not available.");var r=e.getItem(n);if(e.init)if(r.rval===null){if(r.error){var i=new Error(r.error.message);throw i.id=r.error.id,i.name=r.error.name,i}r=null}else r=r.rval;return r!==null&&(r=JSON.parse(t.decode64(r))),r},f=function(e,t,n,r){var i=a(e,t);i===null&&(i={}),i[n]=r,u(e,t,i)},l=function(e,t,n){var r=a(e,t);return r!==null&&(r=n in r?r[n]:null),r},c=function(e,t,n){var r=a(e,t);if(r!==null&&n in r){delete r[n];var i=!0;for(var s in r){i=!1;break}i&&(r=null),u(e,t,r)}},h=function(e,t){u(e,t,null)},p=function(e,t,n){var r=null;typeof n=="undefined"&&(n=["web","flash"]);var i,s=!1,o=null;for(var u in n){i=n[u];try{if(i==="flash"||i==="both"){if(t[0]===null)throw new Error("Flash local storage not available.");r=e.apply(this,t),s=i==="flash"}if(i==="web"||i==="both")t[0]=localStorage,r=e.apply(this,t),s=!0}catch(a){o=a}if(s)break}if(!s)throw o;return r};t.setItem=function(e,t,n,r,i){p(f,arguments,i)},t.getItem=function(e,t,n,r){return p(l,arguments,r)},t.removeItem=function(e,t,n,r){p(c,arguments,r)},t.clearItems=function(e,t,n){p(h,arguments,n)},t.parseUrl=function(e){var t=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;t.lastIndex=0;var n=t.exec(e),r=n===null?null:{full:e,scheme:n[1],host:n[2],port:n[3],path:n[4]};return r&&(r.fullHost=r.host,r.port?r.port!==80&&r.scheme==="http"?r.fullHost+=":"+r.port:r.port!==443&&r.scheme==="https"&&(r.fullHost+=":"+r.port):r.scheme==="http"?r.port=80:r.scheme==="https"&&(r.port=443),r.full=r.scheme+"://"+r.fullHost),r};var d=null;t.getQueryVariables=function(e){var t=function(e){var t={},n=e.split("&");for(var r=0;r<n.length;r++){var i=n[r].indexOf("="),s,o;i>0?(s=n[r].substring(0,i),o=n[r].substring(i+1)):(s=n[r],o=null),s in t||(t[s]=[]),!(s in Object.prototype)&&o!==null&&t[s].push(unescape(o))}return t},n;return typeof e=="undefined"?(d===null&&(typeof window!="undefined"&&window.location&&window.location.search?d=t(window.location.search.substring(1)):d={}),n=d):n=t(e),n},t.parseFragment=function(e){var n=e,r="",i=e.indexOf("?");i>0&&(n=e.substring(0,i),r=e.substring(i+1));var s=n.split("/");s.length>0&&s[0]===""&&s.shift();var o=r===""?{}:t.getQueryVariables(r);return{pathString:n,queryString:r,path:s,query:o}},t.makeRequest=function(e){var n=t.parseFragment(e),r={path:n.pathString,query:n.queryString,getPath:function(e){return typeof e=="undefined"?n.path:n.path[e]},getQuery:function(e,t){var r;return typeof e=="undefined"?r=n.query:(r=n.query[e],r&&typeof t!="undefined"&&(r=r[t])),r},getQueryLast:function(e,t){var n,i=r.getQuery(e);return i?n=i[i.length-1]:n=t,n}};return r},t.makeLink=function(e,t,n){e=jQuery.isArray(e)?e.join("/"):e;var r=jQuery.param(t||{});return n=n||"",e+(r.length>0?"?"+r:"")+(n.length>0?"#"+n:"")},t.setPath=function(e,t,n){if(typeof e=="object"&&e!==null){var r=0,i=t.length;while(r<i){var s=t[r++];if(r==i)e[s]=n;else{var o=s in e;if(!o||o&&typeof e[s]!="object"||o&&e[s]===null)e[s]={};e=e[s]}}}},t.getPath=function(e,t,n){var r=0,i=t.length,s=!0;while(s&&r<i&&typeof e=="object"&&e!==null){var o=t[r++];s=o in e,s&&(e=e[o])}return s?e:n},t.deletePath=function(e,t){if(typeof e=="object"&&e!==null){var n=0,r=t.length;while(n<r){var i=t[n++];if(n==r)delete e[i];else{if(!(i in e&&typeof e[i]=="object"&&e[i]!==null))break;e=e[i]}}}},t.isEmpty=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},t.format=function(e){var t=/%./g,n,r,i=0,s=[],o=0;while(n=t.exec(e)){r=e.substring(o,t.lastIndex-2),r.length>0&&s.push(r),o=t.lastIndex;var u=n[0][1];switch(u){case"s":case"o":i<arguments.length?s.push(arguments[i++ +1]):s.push("<?>");break;case"%":s.push("%");break;default:s.push("<%"+u+"?>")}}return s.push(e.substring(o)),s.join("")},t.formatNumber=function(e,t,n,r){var i=e,s=isNaN(t=Math.abs(t))?2:t,o=n===undefined?",":n,u=r===undefined?".":r,a=i<0?"-":"",f=parseInt(i=Math.abs(+i||0).toFixed(s),10)+"",l=f.length>3?f.length%3:0;return a+(l?f.substr(0,l)+u:"")+f.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+u)+(s?o+Math.abs(i-f).toFixed(s).slice(2):"")},t.formatSize=function(e){return e>=1073741824?e=t.formatNumber(e/1073741824,2,".","")+" GiB":e>=1048576?e=t.formatNumber(e/1048576,2,".","")+" MiB":e>=1024?e=t.formatNumber(e/1024,0)+" KiB":e=t.formatNumber(e,0)+" bytes",e},t.bytesFromIP=function(e){return e.indexOf(".")!==-1?t.bytesFromIPv4(e):e.indexOf(":")!==-1?t.bytesFromIPv6(e):null},t.bytesFromIPv4=function(e){e=e.split(".");if(e.length!==4)return null;var n=t.createBuffer();for(var r=0;r<e.length;++r){var i=parseInt(e[r],10);if(isNaN(i))return null;n.putByte(i)}return n.getBytes()},t.bytesFromIPv6=function(e){var n=0;e=e.split(":").filter(function(e){return e.length===0&&++n,!0});var r=(8-e.length+n)*2,i=t.createBuffer();for(var s=0;s<8;++s){if(!e[s]||e[s].length===0){i.fillWithByte(0,r),r=0;continue}var o=t.hexToBytes(e[s]);o.length<2&&i.putByte(0),i.putBytes(o)}return i.getBytes()},t.bytesToIP=function(e){return e.length===4?t.bytesToIPv4(e):e.length===16?t.bytesToIPv6(e):null},t.bytesToIPv4=function(e){if(e.length!==4)return null;var t=[];for(var n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t.join(".")},t.bytesToIPv6=function(e){if(e.length!==16)return null;var n=[],r=[],i=0;for(var s=0;s<e.length;s+=2){var o=t.bytesToHex(e[s]+e[s+1]);while(o[0]==="0"&&o!=="0")o=o.substr(1);if(o==="0"){var u=r[r.length-1],a=n.length;!u||a!==u.end+1?r.push({start:a,end:a}):(u.end=a,u.end-u.start>r[i].end-r[i].start&&(i=r.length-1))}n.push(o)}if(r.length>0){var f=r[i];f.end-f.start>0&&(n.splice(f.start,f.end-f.start+1,""),f.start===0&&n.unshift(""),f.end===7&&n.push(""))}return n.join(":")},t.estimateCores=function(e,n){function i(e,u,a){if(u===0){var f=Math.floor(e.reduce(function(e,t){return e+t},0)/e.length);return t.cores=Math.max(1,f),URL.revokeObjectURL(r),n(null,t.cores)}s(a,function(t,n){e.push(o(a,n)),i(e,u-1,a)})}function s(e,t){var n=[],i=[];for(var s=0;s<e;++s){var o=new Worker(r);o.addEventListener("message",function(r){i.push(r.data);if(i.length===e){for(var s=0;s<e;++s)n[s].terminate();t(null,i)}}),n.push(o)}for(var s=0;s<e;++s)n[s].postMessage(s)}function o(e,t){var n=[];for(var r=0;r<e;++r){var i=t[r],s=n[r]=[];for(var o=0;o<e;++o){if(r===o)continue;var u=t[o];(i.st>u.st&&i.st<u.et||u.st>i.st&&u.st<i.et)&&s.push(o)}}return n.reduce(function(e,t){return Math.max(e,t.length)},0)}typeof e=="function"&&(n=e,e={}),e=e||{};if("cores"in t&&!e.update)return n(null,t.cores);if(typeof navigator!="undefined"&&"hardwareConcurrency"in navigator&&navigator.hardwareConcurrency>0)return t.cores=navigator.hardwareConcurrency,n(null,t.cores);if(typeof Worker=="undefined")return t.cores=1,n(null,t.cores);if(typeof Blob=="undefined")return t.cores=2,n(null,t.cores);var r=URL.createObjectURL(new Blob(["(",function(){self.addEventListener("message",function(e){var t=Date.now(),n=t+4;while(Date.now()<n);self.postMessage({st:t,et:n})})}.toString(),")()"],{type:"application/javascript"}));i([],5,16)}}var r="util";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/util",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.cipher=e.cipher||{},e.cipher.algorithms=e.cipher.algorithms||{},e.cipher.createCipher=function(t,n){var r=t;typeof r=="string"&&(r=e.cipher.getAlgorithm(r),r&&(r=r()));if(!r)throw new Error("Unsupported algorithm: "+t);return new e.cipher.BlockCipher({algorithm:r,key:n,decrypt:!1})},e.cipher.createDecipher=function(t,n){var r=t;typeof r=="string"&&(r=e.cipher.getAlgorithm(r),r&&(r=r()));if(!r)throw new Error("Unsupported algorithm: "+t);return new e.cipher.BlockCipher({algorithm:r,key:n,decrypt:!0})},e.cipher.registerAlgorithm=function(t,n){t=t.toUpperCase(),e.cipher.algorithms[t]=n},e.cipher.getAlgorithm=function(t){return t=t.toUpperCase(),t in e.cipher.algorithms?e.cipher.algorithms[t]:null};var t=e.cipher.BlockCipher=function(e){this.algorithm=e.algorithm,this.mode=this.algorithm.mode,this.blockSize=this.mode.blockSize,this._finish=!1,this._input=null,this.output=null,this._op=e.decrypt?this.mode.decrypt:this.mode.encrypt,this._decrypt=e.decrypt,this.algorithm.initialize(e)};t.prototype.start=function(t){t=t||{};var n={};for(var r in t)n[r]=t[r];n.decrypt=this._decrypt,this._finish=!1,this._input=e.util.createBuffer(),this.output=t.output||e.util.createBuffer(),this.mode.start(n)},t.prototype.update=function(e){e&&this._input.putBuffer(e);while(!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish);this._input.compact()},t.prototype.finish=function(e){e&&(this.mode.name==="ECB"||this.mode.name==="CBC")&&(this.mode.pad=function(t){return e(this.blockSize,t,!1)},this.mode.unpad=function(t){return e(this.blockSize,t,!0)});var t={};return t.decrypt=this._decrypt,t.overflow=this._input.length()%this.blockSize,!this._decrypt&&this.mode.pad&&!this.mode.pad(this._input,t)?!1:(this._finish=!0,this.update(),this._decrypt&&this.mode.unpad&&!this.mode.unpad(this.output,t)?!1:this.mode.afterFinish&&!this.mode.afterFinish(this.output,t)?!1:!0)}}var r="cipher";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/cipher",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(t){typeof t=="string"&&(t=e.util.createBuffer(t));if(e.util.isArray(t)&&t.length>4){var n=t;t=e.util.createBuffer();for(var r=0;r<n.length;++r)t.putByte(n[r])}return e.util.isArray(t)||(t=[t.getInt32(),t.getInt32(),t.getInt32(),t.getInt32()]),t}function r(e){e[e.length-1]=e[e.length-1]+1&4294967295}function i(e){return[e/4294967296|0,e&4294967295]}e.cipher=e.cipher||{};var t=e.cipher.modes=e.cipher.modes||{};t.ecb=function(e){e=e||{},this.name="ECB",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)},t.ecb.prototype.start=function(e){},t.ecb.prototype.encrypt=function(e,t,n){if(e.length()<this.blockSize&&!(n&&e.length()>0))return!0;for(var r=0;r<this._ints;++r)this._inBlock[r]=e.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var r=0;r<this._ints;++r)t.putInt32(this._outBlock[r])},t.ecb.prototype.decrypt=function(e,t,n){if(e.length()<this.blockSize&&!(n&&e.length()>0))return!0;for(var r=0;r<this._ints;++r)this._inBlock[r]=e.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var r=0;r<this._ints;++r)t.putInt32(this._outBlock[r])},t.ecb.prototype.pad=function(e,t){var n=e.length()===this.blockSize?this.blockSize:this.blockSize-e.length();return e.fillWithByte(n,n),!0},t.ecb.prototype.unpad=function(e,t){if(t.overflow>0)return!1;var n=e.length(),r=e.at(n-1);return r>this.blockSize<<2?!1:(e.truncate(r),!0)},t.cbc=function(e){e=e||{},this.name="CBC",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)},t.cbc.prototype.start=function(e){if(e.iv===null){if(!this._prev)throw new Error("Invalid IV parameter.");this._iv=this._prev.slice(0)}else{if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=n(e.iv),this._prev=this._iv.slice(0)}},t.cbc.prototype.encrypt=function(e,t,n){if(e.length()<this.blockSize&&!(n&&e.length()>0))return!0;for(var r=0;r<this._ints;++r)this._inBlock[r]=this._prev[r]^e.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var r=0;r<this._ints;++r)t.putInt32(this._outBlock[r]);this._prev=this._outBlock},t.cbc.prototype.decrypt=function(e,t,n){if(e.length()<this.blockSize&&!(n&&e.length()>0))return!0;for(var r=0;r<this._ints;++r)this._inBlock[r]=e.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var r=0;r<this._ints;++r)t.putInt32(this._prev[r]^this._outBlock[r]);this._prev=this._inBlock.slice(0)},t.cbc.prototype.pad=function(e,t){var n=e.length()===this.blockSize?this.blockSize:this.blockSize-e.length();return e.fillWithByte(n,n),!0},t.cbc.prototype.unpad=function(e,t){if(t.overflow>0)return!1;var n=e.length(),r=e.at(n-1);return r>this.blockSize<<2?!1:(e.truncate(r),!0)},t.cfb=function(t){t=t||{},this.name="CFB",this.cipher=t.cipher,this.blockSize=t.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialBlock=new Array(this._ints),this._partialOutput=e.util.createBuffer(),this._partialBytes=0},t.cfb.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=n(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},t.cfb.prototype.encrypt=function(e,t,n){var r=e.length();if(r===0)return!0;this.cipher.encrypt(this._inBlock,this._outBlock);if(this._partialBytes===0&&r>=this.blockSize){for(var i=0;i<this._ints;++i)this._inBlock[i]=e.getInt32()^this._outBlock[i],t.putInt32(this._inBlock[i]);return}var s=(this.blockSize-r)%this.blockSize;s>0&&(s=this.blockSize-s),this._partialOutput.clear();for(var i=0;i<this._ints;++i)this._partialBlock[i]=e.getInt32()^this._outBlock[i],this._partialOutput.putInt32(this._partialBlock[i]);if(s>0)e.read-=this.blockSize;else for(var i=0;i<this._ints;++i)this._inBlock[i]=this._partialBlock[i];this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes);if(s>0&&!n)return t.putBytes(this._partialOutput.getBytes(s-this._partialBytes)),this._partialBytes=s,!0;t.putBytes(this._partialOutput.getBytes(r-this._partialBytes)),this._partialBytes=0},t.cfb.prototype.decrypt=function(e,t,n){var r=e.length();if(r===0)return!0;this.cipher.encrypt(this._inBlock,this._outBlock);if(this._partialBytes===0&&r>=this.blockSize){for(var i=0;i<this._ints;++i)this._inBlock[i]=e.getInt32(),t.putInt32(this._inBlock[i]^this._outBlock[i]);return}var s=(this.blockSize-r)%this.blockSize;s>0&&(s=this.blockSize-s),this._partialOutput.clear();for(var i=0;i<this._ints;++i)this._partialBlock[i]=e.getInt32(),this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);if(s>0)e.read-=this.blockSize;else for(var i=0;i<this._ints;++i)this._inBlock[i]=this._partialBlock[i];this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes);if(s>0&&!n)return t.putBytes(this._partialOutput.getBytes(s-this._partialBytes)),this._partialBytes=s,!0;t.putBytes(this._partialOutput.getBytes(r-this._partialBytes)),this._partialBytes=0},t.ofb=function(t){t=t||{},this.name="OFB",this.cipher=t.cipher,this.blockSize=t.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=e.util.createBuffer(),this._partialBytes=0},t.ofb.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=n(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},t.ofb.prototype.encrypt=function(e,t,n){var r=e.length();if(e.length()===0)return!0;this.cipher.encrypt(this._inBlock,this._outBlock);if(this._partialBytes===0&&r>=this.blockSize){for(var i=0;i<this._ints;++i)t.putInt32(e.getInt32()^this._outBlock[i]),this._inBlock[i]=this._outBlock[i];return}var s=(this.blockSize-r)%this.blockSize;s>0&&(s=this.blockSize-s),this._partialOutput.clear();for(var i=0;i<this._ints;++i)this._partialOutput.putInt32(e.getInt32()^this._outBlock[i]);if(s>0)e.read-=this.blockSize;else for(var i=0;i<this._ints;++i)this._inBlock[i]=this._outBlock[i];this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes);if(s>0&&!n)return t.putBytes(this._partialOutput.getBytes(s-this._partialBytes)),this._partialBytes=s,!0;t.putBytes(this._partialOutput.getBytes(r-this._partialBytes)),this._partialBytes=0},t.ofb.prototype.decrypt=t.ofb.prototype.encrypt,t.ctr=function(t){t=t||{},this.name="CTR",this.cipher=t.cipher,this.blockSize=t.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=e.util.createBuffer(),this._partialBytes=0},t.ctr.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=n(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},t.ctr.prototype.encrypt=function(e,t,n){var i=e.length();if(i===0)return!0;this.cipher.encrypt(this._inBlock,this._outBlock);if(this._partialBytes===0&&i>=this.blockSize)for(var s=0;s<this._ints;++s)t.putInt32(e.getInt32()^this._outBlock[s]);else{var o=(this.blockSize-i)%this.blockSize;o>0&&(o=this.blockSize-o),this._partialOutput.clear();for(var s=0;s<this._ints;++s)this._partialOutput.putInt32(e.getInt32()^this._outBlock[s]);o>0&&(e.read-=this.blockSize),this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes);if(o>0&&!n)return t.putBytes(this._partialOutput.getBytes(o-this._partialBytes)),this._partialBytes=o,!0;t.putBytes(this._partialOutput.getBytes(i-this._partialBytes)),this._partialBytes=0}r(this._inBlock)},t.ctr.prototype.decrypt=t.ctr.prototype.encrypt,t.gcm=function(t){t=t||{},this.name="GCM",this.cipher=t.cipher,this.blockSize=t.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints),this._partialOutput=e.util.createBuffer(),this._partialBytes=0,this._R=3774873600},t.gcm.prototype.start=function(t){if(!("iv"in t))throw new Error("Invalid IV parameter.");var n=e.util.createBuffer(t.iv);this._cipherLength=0;var s;"additionalData"in t?s=e.util.createBuffer(t.additionalData):s=e.util.createBuffer(),"tagLength"in t?this._tagLength=t.tagLength:this._tagLength=128,this._tag=null;if(t.decrypt){this._tag=e.util.createBuffer(t.tag).getBytes();if(this._tag.length!==this._tagLength/8)throw new Error("Authentication tag does not match tag length.")}this._hashBlock=new Array(this._ints),this.tag=null,this._hashSubkey=new Array(this._ints),this.cipher.encrypt([0,0,0,0],this._hashSubkey),this.componentBits=4,this._m=this.generateHashTable(this._hashSubkey,this.componentBits);var o=n.length();if(o===12)this._j0=[n.getInt32(),n.getInt32(),n.getInt32(),1];else{this._j0=[0,0,0,0];while(n.length()>0)this._j0=this.ghash(this._hashSubkey,this._j0,[n.getInt32(),n.getInt32(),n.getInt32(),n.getInt32()]);this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(i(o*8)))}this._inBlock=this._j0.slice(0),r(this._inBlock),this._partialBytes=0,s=e.util.createBuffer(s),this._aDataLength=i(s.length()*8);var u=s.length()%this.blockSize;u&&s.fillWithByte(0,this.blockSize-u),this._s=[0,0,0,0];while(s.length()>0)this._s=this.ghash(this._hashSubkey,this._s,[s.getInt32(),s.getInt32(),s.getInt32(),s.getInt32()])},t.gcm.prototype.encrypt=function(e,t,n){var i=e.length();if(i===0)return!0;this.cipher.encrypt(this._inBlock,this._outBlock);if(this._partialBytes===0&&i>=this.blockSize){for(var s=0;s<this._ints;++s)t.putInt32(this._outBlock[s]^=e.getInt32());this._cipherLength+=this.blockSize}else{var o=(this.blockSize-i)%this.blockSize;o>0&&(o=this.blockSize-o),this._partialOutput.clear();for(var s=0;s<this._ints;++s)this._partialOutput.putInt32(e.getInt32()^this._outBlock[s]);if(o===0||n){if(n){var u=i%this.blockSize;this._cipherLength+=u,this._partialOutput.truncate(this.blockSize-u)}else this._cipherLength+=this.blockSize;for(var s=0;s<this._ints;++s)this._outBlock[s]=this._partialOutput.getInt32();this._partialOutput.read-=this.blockSize}this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes);if(o>0&&!n)return e.read-=this.blockSize,t.putBytes(this._partialOutput.getBytes(o-this._partialBytes)),this._partialBytes=o,!0;t.putBytes(this._partialOutput.getBytes(i-this._partialBytes)),this._partialBytes=0}this._s=this.ghash(this._hashSubkey,this._s,this._outBlock),r(this._inBlock)},t.gcm.prototype.decrypt=function(e,t,n){var i=e.length();if(i<this.blockSize&&!(n&&i>0))return!0;this.cipher.encrypt(this._inBlock,this._outBlock),r(this._inBlock),this._hashBlock[0]=e.getInt32(),this._hashBlock[1]=e.getInt32(),this._hashBlock[2]=e.getInt32(),this._hashBlock[3]=e.getInt32(),this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);for(var s=0;s<this._ints;++s)t.putInt32(this._outBlock[s]^this._hashBlock[s]);i<this.blockSize?this._cipherLength+=i%this.blockSize:this._cipherLength+=this.blockSize},t.gcm.prototype.afterFinish=function(t,n){var r=!0;n.decrypt&&n.overflow&&t.truncate(this.blockSize-n.overflow),this.tag=e.util.createBuffer();var s=this._aDataLength.concat(i(this._cipherLength*8));this._s=this.ghash(this._hashSubkey,this._s,s);var o=[];this.cipher.encrypt(this._j0,o);for(var u=0;u<this._ints;++u)this.tag.putInt32(this._s[u]^o[u]);return this.tag.truncate(this.tag.length()%(this._tagLength/8)),n.decrypt&&this.tag.bytes()!==this._tag&&(r=!1),r},t.gcm.prototype.multiply=function(e,t){var n=[0,0,0,0],r=t.slice(0);for(var i=0;i<128;++i){var s=e[i/32|0]&1<<31-i%32;s&&(n[0]^=r[0],n[1]^=r[1],n[2]^=r[2],n[3]^=r[3]),this.pow(r,r)}return n},t.gcm.prototype.pow=function(e,t){var n=e[3]&1;for(var r=3;r>0;--r)t[r]=e[r]>>>1|(e[r-1]&1)<<31;t[0]=e[0]>>>1,n&&(t[0]^=this._R)},t.gcm.prototype.tableMultiply=function(e){var t=[0,0,0,0];for(var n=0;n<32;++n){var r=n/8|0,i=e[r]>>>(7-n%8)*4&15,s=this._m[n][i];t[0]^=s[0],t[1]^=s[1],t[2]^=s[2],t[3]^=s[3]}return t},t.gcm.prototype.ghash=function(e,t,n){return t[0]^=n[0],t[1]^=n[1],t[2]^=n[2],t[3]^=n[3],this.tableMultiply(t)},t.gcm.prototype.generateHashTable=function(e,t){var n=8/t,r=4*n,i=16*n,s=new Array(i);for(var o=0;o<i;++o){var u=[0,0,0,0],a=o/r|0,f=(r-1-o%r)*t;u[a]=1<<t-1<<f,s[o]=this.generateSubHashTable(this.multiply(u,e),t)}return s},t.gcm.prototype.generateSubHashTable=function(e,t){var n=1<<t,r=n>>>1,i=new Array(n);i[r]=e.slice(0);var s=r>>>1;while(s>0)this.pow(i[2*s],i[s]=[]),s>>=1;s=2;while(s<r){for(var o=1;o<s;++o){var u=i[s],a=i[o];i[s+o]=[u[0]^a[0],u[1]^a[1],u[2]^a[2],u[3]^a[3]]}s*=2}i[0]=[0,0,0,0];for(s=r+1;s<n;++s){var f=i[s^r];i[s]=[e[0]^f[0],e[1]^f[1],e[2]^f[2],e[3]^f[3]]}return i}}var r="cipherModes";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/cipherModes",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function t(t,n){var r=function(){return new e.aes.Algorithm(t,n)};e.cipher.registerAlgorithm(t,r)}function f(){n=!0,o=[0,1,2,4,8,16,32,64,128,27,54];var e=new Array(256);for(var t=0;t<128;++t)e[t]=t<<1,e[t+128]=t+128<<1^283;i=new Array(256),s=new Array(256),u=new Array(4),a=new Array(4);for(var t=0;t<4;++t)u[t]=new Array(256),a[t]=new Array(256);var r=0,f=0,l,c,h,p,d,v,m;for(var t=0;t<256;++t){p=f^f<<1^f<<2^f<<3^f<<4,p=p>>8^p&255^99,i[r]=p,s[p]=r,d=e[p],l=e[r],c=e[l],h=e[c],v=d<<24^p<<16^p<<8^(p^d),m=(l^c^h)<<24^(r^h)<<16^(r^c^h)<<8^(r^l^h);for(var g=0;g<4;++g)u[g][r]=v,a[g][p]=m,v=v<<24|v>>>8,m=m<<24|m>>>8;r===0?r=f=1:(r=l^e[e[e[l^h]]],f^=e[e[f]])}}function l(e,t){var n=e.slice(0),s,u=1,f=n.length,l=f+6+1,c=r*l;for(var h=f;h<c;++h)s=n[h-1],h%f===0?(s=i[s>>>16&255]<<24^i[s>>>8&255]<<16^i[s&255]<<8^i[s>>>24]^o[u]<<24,u++):f>6&&h%f===4&&(s=i[s>>>24]<<24^i[s>>>16&255]<<16^i[s>>>8&255]<<8^i[s&255]),n[h]=n[h-f]^s;if(t){var p,d=a[0],v=a[1],m=a[2],g=a[3],y=n.slice(0);c=n.length;for(var h=0,b=c-r;h<c;h+=r,b-=r)if(h===0||h===c-r)y[h]=n[b],y[h+1]=n[b+3],y[h+2]=n[b+2],y[h+3]=n[b+1];else for(var w=0;w<r;++w)p=n[b+w],y[h+(3&-w)]=d[i[p>>>24]]^v[i[p>>>16&255]]^m[i[p>>>8&255]]^g[i[p&255]];n=y}return n}function c(e,t,n,r){var o=e.length/4-1,f,l,c,h,p;r?(f=a[0],l=a[1],c=a[2],h=a[3],p=s):(f=u[0],l=u[1],c=u[2],h=u[3],p=i);var d,v,m,g,y,b,w;d=t[0]^e[0],v=t[r?3:1]^e[1],m=t[2]^e[2],g=t[r?1:3]^e[3];var E=3;for(var S=1;S<o;++S)y=f[d>>>24]^l[v>>>16&255]^c[m>>>8&255]^h[g&255]^e[++E],b=f[v>>>24]^l[m>>>16&255]^c[g>>>8&255]^h[d&255]^e[++E],w=f[m>>>24]^l[g>>>16&255]^c[d>>>8&255]^h[v&255]^e[++E],g=f[g>>>24]^l[d>>>16&255]^c[v>>>8&255]^h[m&255]^e[++E],d=y,v=b,m=w;n[0]=p[d>>>24]<<24^p[v>>>16&255]<<16^p[m>>>8&255]<<8^p[g&255]^e[++E],n[r?3:1]=p[v>>>24]<<24^p[m>>>16&255]<<16^p[g>>>8&255]<<8^p[d&255]^e[++E],n[2]=p[m>>>24]<<24^p[g>>>16&255]<<16^p[d>>>8&255]<<8^p[v&255]^e[++E],n[r?1:3]=p[g>>>24]<<24^p[d>>>16&255]<<16^p[v>>>8&255]<<8^p[m&255]^e[++E]}function h(t){t=t||{};var n=(t.mode||"CBC").toUpperCase(),r="AES-"+n,i;t.decrypt?i=e.cipher.createDecipher(r,t.key):i=e.cipher.createCipher(r,t.key);var s=i.start;return i.start=function(t,n){var r=null;n instanceof e.util.ByteBuffer&&(r=n,n={}),n=n||{},n.output=r,n.iv=t,s.call(i,n)},i}e.aes=e.aes||{},e.aes.startEncrypting=function(e,t,n,r){var i=h({key:e,output:n,decrypt:!1,mode:r});return i.start(t),i},e.aes.createEncryptionCipher=function(e,t){return h({key:e,output:null,decrypt:!1,mode:t})},e.aes.startDecrypting=function(e,t,n,r){var i=h({key:e,output:n,decrypt:!0,mode:r});return i.start(t),i},e.aes.createDecryptionCipher=function(e,t){return h({key:e,output:null,decrypt:!0,mode:t})},e.aes.Algorithm=function(e,t){n||f();var r=this;r.name=e,r.mode=new t({blockSize:16,cipher:{encrypt:function(e,t){return c(r._w,e,t,!1)},decrypt:function(e,t){return c(r._w,e,t,!0)}}}),r._init=!1},e.aes.Algorithm.prototype.initialize=function(t){if(this._init)return;var n=t.key,r;if(typeof n!="string"||n.length!==16&&n.length!==24&&n.length!==32){if(e.util.isArray(n)&&(n.length===16||n.length===24||n.length===32)){r=n,n=e.util.createBuffer();for(var i=0;i<r.length;++i)n.putByte(r[i])}}else n=e.util.createBuffer(n);if(!e.util.isArray(n)){r=n,n=[];var s=r.length();if(s===16||s===24||s===32){s>>>=2;for(var i=0;i<s;++i)n.push(r.getInt32())}}if(!e.util.isArray(n)||n.length!==4&&n.length!==6&&n.length!==8)throw new Error("Invalid key parameter.");var o=this.mode.name,u=["CFB","OFB","CTR","GCM"].indexOf(o)!==-1;this._w=l(n,t.decrypt&&!u),this._init=!0},e.aes._expandKey=function(e,t){return n||f(),l(e,t)},e.aes._updateBlock=c,t("AES-ECB",e.cipher.modes.ecb),t("AES-CBC",e.cipher.modes.cbc),t("AES-CFB",e.cipher.modes.cfb),t("AES-OFB",e.cipher.modes.ofb),t("AES-CTR",e.cipher.modes.ctr),t("AES-GCM",e.cipher.modes.gcm);var n=!1,r=4,i,s,o,u,a}var r="aes";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aes",["require","module","./cipher","./cipherModes","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.pki=e.pki||{};var t=e.pki.oids=e.oids=e.oids||{};t["1.2.840.113549.1.1.1"]="rsaEncryption",t.rsaEncryption="1.2.840.113549.1.1.1",t["1.2.840.113549.1.1.4"]="md5WithRSAEncryption",t.md5WithRSAEncryption="1.2.840.113549.1.1.4",t["1.2.840.113549.1.1.5"]="sha1WithRSAEncryption",t.sha1WithRSAEncryption="1.2.840.113549.1.1.5",t["1.2.840.113549.1.1.7"]="RSAES-OAEP",t["RSAES-OAEP"]="1.2.840.113549.1.1.7",t["1.2.840.113549.1.1.8"]="mgf1",t.mgf1="1.2.840.113549.1.1.8",t["1.2.840.113549.1.1.9"]="pSpecified",t.pSpecified="1.2.840.113549.1.1.9",t["1.2.840.113549.1.1.10"]="RSASSA-PSS",t["RSASSA-PSS"]="1.2.840.113549.1.1.10",t["1.2.840.113549.1.1.11"]="sha256WithRSAEncryption",t.sha256WithRSAEncryption="1.2.840.113549.1.1.11",t["1.2.840.113549.1.1.12"]="sha384WithRSAEncryption",t.sha384WithRSAEncryption="1.2.840.113549.1.1.12",t["1.2.840.113549.1.1.13"]="sha512WithRSAEncryption",t.sha512WithRSAEncryption="1.2.840.113549.1.1.13",t["1.3.14.3.2.7"]="desCBC",t.desCBC="1.3.14.3.2.7",t["1.3.14.3.2.26"]="sha1",t.sha1="1.3.14.3.2.26",t["2.16.840.1.101.3.4.2.1"]="sha256",t.sha256="2.16.840.1.101.3.4.2.1",t["2.16.840.1.101.3.4.2.2"]="sha384",t.sha384="2.16.840.1.101.3.4.2.2",t["2.16.840.1.101.3.4.2.3"]="sha512",t.sha512="2.16.840.1.101.3.4.2.3",t["1.2.840.113549.2.5"]="md5",t.md5="1.2.840.113549.2.5",t["1.2.840.113549.1.7.1"]="data",t.data="1.2.840.113549.1.7.1",t["1.2.840.113549.1.7.2"]="signedData",t.signedData="1.2.840.113549.1.7.2",t["1.2.840.113549.1.7.3"]="envelopedData",t.envelopedData="1.2.840.113549.1.7.3",t["1.2.840.113549.1.7.4"]="signedAndEnvelopedData",t.signedAndEnvelopedData="1.2.840.113549.1.7.4",t["1.2.840.113549.1.7.5"]="digestedData",t.digestedData="1.2.840.113549.1.7.5",t["1.2.840.113549.1.7.6"]="encryptedData",t.encryptedData="1.2.840.113549.1.7.6",t["1.2.840.113549.1.9.1"]="emailAddress",t.emailAddress="1.2.840.113549.1.9.1",t["1.2.840.113549.1.9.2"]="unstructuredName",t.unstructuredName="1.2.840.113549.1.9.2",t["1.2.840.113549.1.9.3"]="contentType",t.contentType="1.2.840.113549.1.9.3",t["1.2.840.113549.1.9.4"]="messageDigest",t.messageDigest="1.2.840.113549.1.9.4",t["1.2.840.113549.1.9.5"]="signingTime",t.signingTime="1.2.840.113549.1.9.5",t["1.2.840.113549.1.9.6"]="counterSignature",t.counterSignature="1.2.840.113549.1.9.6",t["1.2.840.113549.1.9.7"]="challengePassword",t.challengePassword="1.2.840.113549.1.9.7",t["1.2.840.113549.1.9.8"]="unstructuredAddress",t.unstructuredAddress="1.2.840.113549.1.9.8",t["1.2.840.113549.1.9.14"]="extensionRequest",t.extensionRequest="1.2.840.113549.1.9.14",t["1.2.840.113549.1.9.20"]="friendlyName",t.friendlyName="1.2.840.113549.1.9.20",t["1.2.840.113549.1.9.21"]="localKeyId",t.localKeyId="1.2.840.113549.1.9.21",t["1.2.840.113549.1.9.22.1"]="x509Certificate",t.x509Certificate="1.2.840.113549.1.9.22.1",t["1.2.840.113549.1.12.10.1.1"]="keyBag",t.keyBag="1.2.840.113549.1.12.10.1.1",t["1.2.840.113549.1.12.10.1.2"]="pkcs8ShroudedKeyBag",t.pkcs8ShroudedKeyBag="1.2.840.113549.1.12.10.1.2",t["1.2.840.113549.1.12.10.1.3"]="certBag",t.certBag="1.2.840.113549.1.12.10.1.3",t["1.2.840.113549.1.12.10.1.4"]="crlBag",t.crlBag="1.2.840.113549.1.12.10.1.4",t["1.2.840.113549.1.12.10.1.5"]="secretBag",t.secretBag="1.2.840.113549.1.12.10.1.5",t["1.2.840.113549.1.12.10.1.6"]="safeContentsBag",t.safeContentsBag="1.2.840.113549.1.12.10.1.6",t["1.2.840.113549.1.5.13"]="pkcs5PBES2",t.pkcs5PBES2="1.2.840.113549.1.5.13",t["1.2.840.113549.1.5.12"]="pkcs5PBKDF2",t.pkcs5PBKDF2="1.2.840.113549.1.5.12",t["1.2.840.113549.1.12.1.1"]="pbeWithSHAAnd128BitRC4",t.pbeWithSHAAnd128BitRC4="1.2.840.113549.1.12.1.1",t["1.2.840.113549.1.12.1.2"]="pbeWithSHAAnd40BitRC4",t.pbeWithSHAAnd40BitRC4="1.2.840.113549.1.12.1.2",t["1.2.840.113549.1.12.1.3"]="pbeWithSHAAnd3-KeyTripleDES-CBC",t["pbeWithSHAAnd3-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.3",t["1.2.840.113549.1.12.1.4"]="pbeWithSHAAnd2-KeyTripleDES-CBC",t["pbeWithSHAAnd2-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.4",t["1.2.840.113549.1.12.1.5"]="pbeWithSHAAnd128BitRC2-CBC",t["pbeWithSHAAnd128BitRC2-CBC"]="1.2.840.113549.1.12.1.5",t["1.2.840.113549.1.12.1.6"]="pbewithSHAAnd40BitRC2-CBC",t["pbewithSHAAnd40BitRC2-CBC"]="1.2.840.113549.1.12.1.6",t["1.2.840.113549.3.7"]="des-EDE3-CBC",t["des-EDE3-CBC"]="1.2.840.113549.3.7",t["2.16.840.1.101.3.4.1.2"]="aes128-CBC",t["aes128-CBC"]="2.16.840.1.101.3.4.1.2",t["2.16.840.1.101.3.4.1.22"]="aes192-CBC",t["aes192-CBC"]="2.16.840.1.101.3.4.1.22",t["2.16.840.1.101.3.4.1.42"]="aes256-CBC",t["aes256-CBC"]="2.16.840.1.101.3.4.1.42",t["2.5.4.3"]="commonName",t.commonName="2.5.4.3",t["2.5.4.5"]="serialName",t.serialName="2.5.4.5",t["2.5.4.6"]="countryName",t.countryName="2.5.4.6",t["2.5.4.7"]="localityName",t.localityName="2.5.4.7",t["2.5.4.8"]="stateOrProvinceName",t.stateOrProvinceName="2.5.4.8",t["2.5.4.10"]="organizationName",t.organizationName="2.5.4.10",t["2.5.4.11"]="organizationalUnitName",t.organizationalUnitName="2.5.4.11",t["2.16.840.1.113730.1.1"]="nsCertType",t.nsCertType="2.16.840.1.113730.1.1",t["2.5.29.1"]="authorityKeyIdentifier",t["2.5.29.2"]="keyAttributes",t["2.5.29.3"]="certificatePolicies",t["2.5.29.4"]="keyUsageRestriction",t["2.5.29.5"]="policyMapping",t["2.5.29.6"]="subtreesConstraint",t["2.5.29.7"]="subjectAltName",t["2.5.29.8"]="issuerAltName",t["2.5.29.9"]="subjectDirectoryAttributes",t["2.5.29.10"]="basicConstraints",t["2.5.29.11"]="nameConstraints",t["2.5.29.12"]="policyConstraints",t["2.5.29.13"]="basicConstraints",t["2.5.29.14"]="subjectKeyIdentifier",t.subjectKeyIdentifier="2.5.29.14",t["2.5.29.15"]="keyUsage",t.keyUsage="2.5.29.15",t["2.5.29.16"]="privateKeyUsagePeriod",t["2.5.29.17"]="subjectAltName",t.subjectAltName="2.5.29.17",t["2.5.29.18"]="issuerAltName",t.issuerAltName="2.5.29.18",t["2.5.29.19"]="basicConstraints",t.basicConstraints="2.5.29.19",t["2.5.29.20"]="cRLNumber",t["2.5.29.21"]="cRLReason",t["2.5.29.22"]="expirationDate",t["2.5.29.23"]="instructionCode",t["2.5.29.24"]="invalidityDate",t["2.5.29.25"]="cRLDistributionPoints",t["2.5.29.26"]="issuingDistributionPoint",t["2.5.29.27"]="deltaCRLIndicator",t["2.5.29.28"]="issuingDistributionPoint",t["2.5.29.29"]="certificateIssuer",t["2.5.29.30"]="nameConstraints",t["2.5.29.31"]="cRLDistributionPoints",t["2.5.29.32"]="certificatePolicies",t["2.5.29.33"]="policyMappings",t["2.5.29.34"]="policyConstraints",t["2.5.29.35"]="authorityKeyIdentifier",t["2.5.29.36"]="policyConstraints",t["2.5.29.37"]="extKeyUsage",t.extKeyUsage="2.5.29.37",t["2.5.29.46"]="freshestCRL",t["2.5.29.54"]="inhibitAnyPolicy",t["1.3.6.1.5.5.7.3.1"]="serverAuth",t.serverAuth="1.3.6.1.5.5.7.3.1",t["1.3.6.1.5.5.7.3.2"]="clientAuth",t.clientAuth="1.3.6.1.5.5.7.3.2",t["1.3.6.1.5.5.7.3.3"]="codeSigning",t.codeSigning="1.3.6.1.5.5.7.3.3",t["1.3.6.1.5.5.7.3.4"]="emailProtection",t.emailProtection="1.3.6.1.5.5.7.3.4",t["1.3.6.1.5.5.7.3.8"]="timeStamping",t.timeStamping="1.3.6.1.5.5.7.3.8"}var r="oids";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/oids",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1=e.asn1||{};t.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192},t.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30},t.create=function(t,n,r,i){if(e.util.isArray(i)){var s=[];for(var o=0;o<i.length;++o)i[o]!==undefined&&s.push(i[o]);i=s}return{tagClass:t,type:n,constructed:r,composed:r||e.util.isArray(i),value:i}};var n=t.getBerValueLength=function(e){var t=e.getByte();if(t===128)return undefined;var n,r=t&128;return r?n=e.getInt((t&127)<<3):n=t,n};t.fromDer=function(r,i){i===undefined&&(i=!0),typeof r=="string"&&(r=e.util.createBuffer(r));if(r.length()<2){var s=new Error("Too few bytes to parse DER.");throw s.bytes=r.length(),s}var o=r.getByte(),u=o&192,a=o&31,f=n(r);if(r.length()<f){if(i){var s=new Error("Too few bytes to read ASN.1 value.");throw s.detail=r.length()+" < "+f,s}f=r.length()}var l,c=(o&32)===32,h=c;if(!h&&u===t.Class.UNIVERSAL&&a===t.Type.BITSTRING&&f>1){var p=r.read,d=r.getByte();if(d===0){o=r.getByte();var v=o&192;if(v===t.Class.UNIVERSAL||v===t.Class.CONTEXT_SPECIFIC)try{var m=n(r);h=m===f-(r.read-p),h&&(++p,--f)}catch(g){}}r.read=p}if(h){l=[];if(f===undefined)for(;;){if(r.bytes(2)===String.fromCharCode(0,0)){r.getBytes(2);break}l.push(t.fromDer(r,i))}else{var y=r.length();while(f>0)l.push(t.fromDer(r,i)),f-=y-r.length(),y=r.length()}}else{if(f===undefined){if(i)throw new Error("Non-constructed ASN.1 object of indefinite length.");f=r.length()}if(a===t.Type.BMPSTRING){l="";for(var b=0;b<f;b+=2)l+=String.fromCharCode(r.getInt16())}else l=r.getBytes(f)}return t.create(u,a,c,l)},t.toDer=function(n){var r=e.util.createBuffer(),i=n.tagClass|n.type,s=e.util.createBuffer();if(n.composed){n.constructed?i|=32:s.putByte(0);for(var o=0;o<n.value.length;++o)n.value[o]!==undefined&&s.putBuffer(t.toDer(n.value[o]))}else if(n.type===t.Type.BMPSTRING)for(var o=0;o<n.value.length;++o)s.putInt16(n.value.charCodeAt(o));else s.putBytes(n.value);r.putByte(i);if(s.length()<=127)r.putByte(s.length()&127);else{var u=s.length(),a="";do a+=String.fromCharCode(u&255),u>>>=8;while(u>0);r.putByte(a.length|128);for(var o=a.length-1;o>=0;--o)r.putByte(a.charCodeAt(o))}return r.putBuffer(s),r},t.oidToDer=function(t){var n=t.split("."),r=e.util.createBuffer();r.putByte(40*parseInt(n[0],10)+parseInt(n[1],10));var i,s,o,u;for(var a=2;a<n.length;++a){i=!0,s=[],o=parseInt(n[a],10);do u=o&127,o>>>=7,i||(u|=128),s.push(u),i=!1;while(o>0);for(var f=s.length-1;f>=0;--f)r.putByte(s[f])}return r},t.derToOid=function(t){var n;typeof t=="string"&&(t=e.util.createBuffer(t));var r=t.getByte();n=Math.floor(r/40)+"."+r%40;var i=0;while(t.length()>0)r=t.getByte(),i<<=7,r&128?i+=r&127:(n+="."+(i+r),i=0);return n},t.utcTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,2),10);n=n>=50?1900+n:2e3+n;var r=parseInt(e.substr(2,2),10)-1,i=parseInt(e.substr(4,2),10),s=parseInt(e.substr(6,2),10),o=parseInt(e.substr(8,2),10),u=0;if(e.length>11){var a=e.charAt(10),f=10;a!=="+"&&a!=="-"&&(u=parseInt(e.substr(10,2),10),f+=2)}t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,0);if(f){a=e.charAt(f);if(a==="+"||a==="-"){var l=parseInt(e.substr(f+1,2),10),c=parseInt(e.substr(f+4,2),10),h=l*60+c;h*=6e4,a==="+"?t.setTime(+t-h):t.setTime(+t+h)}}return t},t.generalizedTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,4),10),r=parseInt(e.substr(4,2),10)-1,i=parseInt(e.substr(6,2),10),s=parseInt(e.substr(8,2),10),o=parseInt(e.substr(10,2),10),u=parseInt(e.substr(12,2),10),a=0,f=0,l=!1;e.charAt(e.length-1)==="Z"&&(l=!0);var c=e.length-5,h=e.charAt(c);if(h==="+"||h==="-"){var p=parseInt(e.substr(c+1,2),10),d=parseInt(e.substr(c+4,2),10);f=p*60+d,f*=6e4,h==="+"&&(f*=-1),l=!0}return e.charAt(14)==="."&&(a=parseFloat(e.substr(14),10)*1e3),l?(t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,a),t.setTime(+t+f)):(t.setFullYear(n,r,i),t.setHours(s,o,u,a)),t},t.dateToUtcTime=function(e){if(typeof e=="string")return e;var t="",n=[];n.push((""+e.getUTCFullYear()).substr(2)),n.push(""+(e.getUTCMonth()+1)),n.push(""+e.getUTCDate()),n.push(""+e.getUTCHours()),n.push(""+e.getUTCMinutes()),n.push(""+e.getUTCSeconds());for(var r=0;r<n.length;++r)n[r].length<2&&(t+="0"),t+=n[r];return t+="Z",t},t.dateToGeneralizedTime=function(e){if(typeof e=="string")return e;var t="",n=[];n.push(""+e.getUTCFullYear()),n.push(""+(e.getUTCMonth()+1)),n.push(""+e.getUTCDate()),n.push(""+e.getUTCHours()),n.push(""+e.getUTCMinutes()),n.push(""+e.getUTCSeconds());for(var r=0;r<n.length;++r)n[r].length<2&&(t+="0"),t+=n[r];return t+="Z",t},t.integerToDer=function(t){var n=e.util.createBuffer();if(t>=-128&&t<128)return n.putSignedInt(t,8);if(t>=-32768&&t<32768)return n.putSignedInt(t,16);if(t>=-8388608&&t<8388608)return n.putSignedInt(t,24);if(t>=-2147483648&&t<2147483648)return n.putSignedInt(t,32);var r=new Error("Integer too large; max is 32-bits.");throw r.integer=t,r},t.derToInteger=function(t){typeof t=="string"&&(t=e.util.createBuffer(t));var n=t.length()*8;if(n>32)throw new Error("Integer too large; max is 32-bits.");return t.getSignedInt(n)},t.validate=function(n,r,i,s){var o=!1;if(n.tagClass!==r.tagClass&&typeof r.tagClass!="undefined"||n.type!==r.type&&typeof r.type!="undefined")s&&(n.tagClass!==r.tagClass&&s.push("["+r.name+"] "+'Expected tag class "'+r.tagClass+'", got "'+n.tagClass+'"'),n.type!==r.type&&s.push("["+r.name+"] "+'Expected type "'+r.type+'", got "'+n.type+'"'));else if(n.constructed===r.constructed||typeof r.constructed=="undefined"){o=!0;if(r.value&&e.util.isArray(r.value)){var u=0;for(var a=0;o&&a<r.value.length;++a)o=r.value[a].optional||!1,n.value[u]&&(o=t.validate(n.value[u],r.value[a],i,s),o?++u:r.value[a].optional&&(o=!0)),!o&&s&&s.push("["+r.name+"] "+'Tag class "'+r.tagClass+'", type "'+r.type+'" expected value length "'+r.value.length+'", got "'+n.value.length+'"')}o&&i&&(r.capture&&(i[r.capture]=n.value),r.captureAsn1&&(i[r.captureAsn1]=n))}else s&&s.push("["+r.name+"] "+'Expected constructed "'+r.constructed+'", got "'+n.constructed+'"');return o};var r=/[^\\u0000-\\u00ff]/;t.prettyPrint=function(n,i,s){var o="";i=i||0,s=s||2,i>0&&(o+="\n");var u="";for(var a=0;a<i*s;++a)u+=" ";o+=u+"Tag: ";switch(n.tagClass){case t.Class.UNIVERSAL:o+="Universal:";break;case t.Class.APPLICATION:o+="Application:";break;case t.Class.CONTEXT_SPECIFIC:o+="Context-Specific:";break;case t.Class.PRIVATE:o+="Private:"}if(n.tagClass===t.Class.UNIVERSAL){o+=n.type;switch(n.type){case t.Type.NONE:o+=" (None)";break;case t.Type.BOOLEAN:o+=" (Boolean)";break;case t.Type.BITSTRING:o+=" (Bit string)";break;case t.Type.INTEGER:o+=" (Integer)";break;case t.Type.OCTETSTRING:o+=" (Octet string)";break;case t.Type.NULL:o+=" (Null)";break;case t.Type.OID:o+=" (Object Identifier)";break;case t.Type.ODESC:o+=" (Object Descriptor)";break;case t.Type.EXTERNAL:o+=" (External or Instance of)";break;case t.Type.REAL:o+=" (Real)";break;case t.Type.ENUMERATED:o+=" (Enumerated)";break;case t.Type.EMBEDDED:o+=" (Embedded PDV)";break;case t.Type.UTF8:o+=" (UTF8)";break;case t.Type.ROID:o+=" (Relative Object Identifier)";break;case t.Type.SEQUENCE:o+=" (Sequence)";break;case t.Type.SET:o+=" (Set)";break;case t.Type.PRINTABLESTRING:o+=" (Printable String)";break;case t.Type.IA5String:o+=" (IA5String (ASCII))";break;case t.Type.UTCTIME:o+=" (UTC time)";break;case t.Type.GENERALIZEDTIME:o+=" (Generalized time)";break;case t.Type.BMPSTRING:o+=" (BMP String)"}}else o+=n.type;o+="\n",o+=u+"Constructed: "+n.constructed+"\n";if(n.composed){var f=0,l="";for(var a=0;a<n.value.length;++a)n.value[a]!==undefined&&(f+=1,l+=t.prettyPrint(n.value[a],i+1,s),a+1<n.value.length&&(l+=","));o+=u+"Sub values: "+f+l}else{o+=u+"Value: ";if(n.type===t.Type.OID){var c=t.derToOid(n.value);o+=c,e.pki&&e.pki.oids&&c in e.pki.oids&&(o+=" ("+e.pki.oids[c]+") ")}if(n.type===t.Type.INTEGER)try{o+=t.derToInteger(n.value)}catch(h){o+="0x"+e.util.bytesToHex(n.value)}else n.type===t.Type.OCTETSTRING?(r.test(n.value)||(o+="("+n.value+") "),o+="0x"+e.util.bytesToHex(n.value)):n.type===t.Type.UTF8?o+=e.util.decodeUtf8(n.value):n.type===t.Type.PRINTABLESTRING||n.type===t.Type.IA5String?o+=n.value:r.test(n.value)?o+="0x"+e.util.bytesToHex(n.value):n.value.length===0?o+="[null]":o+=n.value}return o}}var r="asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/asn1",["require","module","./util","./oids"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function u(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9],i=[7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21],s=new Array(64);for(var t=0;t<64;++t)s[t]=Math.floor(Math.abs(Math.sin(t+1))*4294967296);o=!0}function a(e,t,n){var o,u,a,f,l,c,h,p,d=n.length();while(d>=64){u=e.h0,a=e.h1,f=e.h2,l=e.h3;for(p=0;p<16;++p)t[p]=n.getInt32Le(),c=l^a&(f^l),o=u+c+s[p]+t[p],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<32;++p)c=f^l&(a^f),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<48;++p)c=a^f^l,o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<64;++p)c=f^(a|~l),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;e.h0=e.h0+u|0,e.h1=e.h1+a|0,e.h2=e.h2+f|0,e.h3=e.h3+l|0,d-=64}}var t=e.md5=e.md5||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.md5=e.md.algorithms.md5=t,t.create=function(){o||u();var t=null,r=e.util.createBuffer(),i=new Array(16),s={algorithm:"md5",blockLength:64,digestLength:16,messageLength:0,messageLength64:[0,0]};return s.start=function(){return s.messageLength=0,s.messageLength64=[0,0],r=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878},s},s.start(),s.update=function(n,o){return o==="utf8"&&(n=e.util.encodeUtf8(n)),s.messageLength+=n.length,s.messageLength64[0]+=n.length/4294967296>>>0,s.messageLength64[1]+=n.length>>>0,r.putBytes(n),a(t,i,r),(r.read>2048||r.length()===0)&&r.compact(),s},s.digest=function(){var o=e.util.createBuffer();o.putBytes(r.bytes()),o.putBytes(n.substr(0,64-(s.messageLength64[1]+8&63))),o.putInt32Le(s.messageLength64[1]<<3),o.putInt32Le(s.messageLength64[0]<<3|s.messageLength64[0]>>>28);var u={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3};a(u,i,o);var f=e.util.createBuffer();return f.putInt32Le(u.h0),f.putInt32Le(u.h1),f.putInt32Le(u.h2),f.putInt32Le(u.h3),f},s};var n=null,r=null,i=null,s=null,o=!1}var r="md5";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md5",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function i(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=!0}function s(e,t,n){var r,i,s,o,u,a,f,l,c=n.length();while(c>=64){i=e.h0,s=e.h1,o=e.h2,u=e.h3,a=e.h4;for(l=0;l<16;++l)r=n.getInt32(),t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<20;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<32;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<40;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<60;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s&o|u&(s^o),r=(i<<5|i>>>27)+f+a+2400959708+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<80;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+3395469782+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;e.h0=e.h0+i|0,e.h1=e.h1+s|0,e.h2=e.h2+o|0,e.h3=e.h3+u|0,e.h4=e.h4+a|0,c-=64}}var t=e.sha1=e.sha1||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha1=e.md.algorithms.sha1=t,t.create=function(){r||i();var t=null,o=e.util.createBuffer(),u=new Array(80),a={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0,messageLength64:[0,0]};return a.start=function(){return a.messageLength=0,a.messageLength64=[0,0],o=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,a.messageLength64[0]+=n.length/4294967296>>>0,a.messageLength64[1]+=n.length>>>0,o.putBytes(n),s(t,u,o),(o.read>2048||o.length()===0)&&o.compact(),a},a.digest=function(){var r=e.util.createBuffer();r.putBytes(o.bytes()),r.putBytes(n.substr(0,64-(a.messageLength64[1]+8&63))),r.putInt32(a.messageLength64[0]<<3|a.messageLength64[0]>>>28),r.putInt32(a.messageLength64[1]<<3);var i={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4};s(i,u,r);var f=e.util.createBuffer();return f.putInt32(i.h0),f.putInt32(i.h1),f.putInt32(i.h2),f.putInt32(i.h3),f.putInt32(i.h4),f},a};var n=null,r=!1}var r="sha1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function s(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),i=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],r=!0}function o(e,t,n){var r,s,o,u,a,f,l,c,h,p,d,v,m,g,y,b=n.length();while(b>=64){for(l=0;l<16;++l)t[l]=n.getInt32();for(;l<64;++l)r=t[l-2],r=(r>>>17|r<<15)^(r>>>19|r<<13)^r>>>10,s=t[l-15],s=(s>>>7|s<<25)^(s>>>18|s<<14)^s>>>3,t[l]=r+t[l-7]+s+t[l-16]|0;c=e.h0,h=e.h1,p=e.h2,d=e.h3,v=e.h4,m=e.h5,g=e.h6,y=e.h7;for(l=0;l<64;++l)u=(v>>>6|v<<26)^(v>>>11|v<<21)^(v>>>25|v<<7),a=g^v&(m^g),o=(c>>>2|c<<30)^(c>>>13|c<<19)^(c>>>22|c<<10),f=c&h|p&(c^h),r=y+u+a+i[l]+t[l],s=o+f,y=g,g=m,m=v,v=d+r|0,d=p,p=h,h=c,c=r+s|0;e.h0=e.h0+c|0,e.h1=e.h1+h|0,e.h2=e.h2+p|0,e.h3=e.h3+d|0,e.h4=e.h4+v|0,e.h5=e.h5+m|0,e.h6=e.h6+g|0,e.h7=e.h7+y|0,b-=64}}var t=e.sha256=e.sha256||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha256=e.md.algorithms.sha256=t,t.create=function(){r||s();var t=null,i=e.util.createBuffer(),u=new Array(64),a={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0,messageLength64:[0,0]};return a.start=function(){return a.messageLength=0,a.messageLength64=[0,0],i=e.util.createBuffer(),t={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,a.messageLength64[0]+=n.length/4294967296>>>0,a.messageLength64[1]+=n.length>>>0,i.putBytes(n),o(t,u,i),(i.read>2048||i.length()===0)&&i.compact(),a},a.digest=function(){var r=e.util.createBuffer();r.putBytes(i.bytes()),r.putBytes(n.substr(0,64-(a.messageLength64[1]+8&63))),r.putInt32(a.messageLength64[0]<<3|a.messageLength64[0]>>>28),r.putInt32(a.messageLength64[1]<<3);var s={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4,h5:t.h5,h6:t.h6,h7:t.h7};o(s,u,r);var f=e.util.createBuffer();return f.putInt32(s.h0),f.putInt32(s.h1),f.putInt32(s.h2),f.putInt32(s.h3),f.putInt32(s.h4),f.putInt32(s.h5),f.putInt32(s.h6),f.putInt32(s.h7),f},a};var n=null,r=!1,i=null}var r="sha256";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha256",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function u(){r=String.fromCharCode(128),r+=e.util.fillString(String.fromCharCode(0),128),s=[[1116352408,3609767458],[1899447441,602891725],[3049323471,3964484399],[3921009573,2173295548],[961987163,4081628472],[1508970993,3053834265],[2453635748,2937671579],[2870763221,3664609560],[3624381080,2734883394],[310598401,1164996542],[607225278,1323610764],[1426881987,3590304994],[1925078388,4068182383],[2162078206,991336113],[2614888103,633803317],[3248222580,3479774868],[3835390401,2666613458],[4022224774,944711139],[264347078,2341262773],[604807628,2007800933],[770255983,1495990901],[1249150122,1856431235],[1555081692,3175218132],[1996064986,2198950837],[2554220882,3999719339],[2821834349,766784016],[2952996808,2566594879],[3210313671,3203337956],[3336571891,1034457026],[3584528711,2466948901],[113926993,3758326383],[338241895,168717936],[666307205,1188179964],[773529912,1546045734],[1294757372,1522805485],[1396182291,2643833823],[1695183700,2343527390],[1986661051,1014477480],[2177026350,1206759142],[2456956037,344077627],[2730485921,1290863460],[2820302411,3158454273],[3259730800,3505952657],[3345764771,106217008],[3516065817,3606008344],[3600352804,1432725776],[4094571909,1467031594],[275423344,851169720],[430227734,3100823752],[506948616,1363258195],[659060556,3750685593],[883997877,3785050280],[958139571,3318307427],[1322822218,3812723403],[1537002063,2003034995],[1747873779,3602036899],[1955562222,1575990012],[2024104815,1125592928],[2227730452,2716904306],[2361852424,442776044],[2428436474,593698344],[2756734187,3733110249],[3204031479,2999351573],[3329325298,3815920427],[3391569614,3928383900],[3515267271,566280711],[3940187606,3454069534],[4118630271,4000239992],[116418474,1914138554],[174292421,2731055270],[289380356,3203993006],[460393269,320620315],[685471733,587496836],[852142971,1086792851],[1017036298,365543100],[1126000580,2618297676],[1288033470,3409855158],[1501505948,4234509866],[1607167915,987167468],[1816402316,1246189591]],o={},o["SHA-512"]=[[1779033703,4089235720],[3144134277,2227873595],[1013904242,4271175723],[2773480762,1595750129],[1359893119,2917565137],[2600822924,725511199],[528734635,4215389547],[1541459225,327033209]],o["SHA-384"]=[[3418070365,3238371032],[1654270250,914150663],[2438529370,812702999],[355462360,4144912697],[1731405415,4290775857],[2394180231,1750603025],[3675008525,1694076839],[1203062813,3204075428]],o["SHA-512/256"]=[[573645204,4230739756],[2673172387,3360449730],[596883563,1867755857],[2520282905,1497426621],[2519219938,2827943907],[3193839141,1401305490],[721525244,746961066],[246885852,2177182882]],o["SHA-512/224"]=[[2352822216,424955298],[1944164710,2312950998],[502970286,855612546],[1738396948,1479516111],[258812777,2077511080],[2011393907,79989058],[1067287976,1780299464],[286451373,2446758561]],i=!0}function a(e,t,n){var r,i,o,u,a,f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_,D,P,H,B,j,F,I=n.length();while(I>=128){for(_=0;_<16;++_)t[_][0]=n.getInt32()>>>0,t[_][1]=n.getInt32()>>>0;for(;_<80;++_)H=t[_-2],D=H[0],P=H[1],r=((D>>>19|P<<13)^(P>>>29|D<<3)^D>>>6)>>>0,i=((D<<13|P>>>19)^(P<<3|D>>>29)^(D<<26|P>>>6))>>>0,j=t[_-15],D=j[0],P=j[1],o=((D>>>1|P<<31)^(D>>>8|P<<24)^D>>>7)>>>0,u=((D<<31|P>>>1)^(D<<24|P>>>8)^(D<<25|P>>>7))>>>0,B=t[_-7],F=t[_-16],P=i+B[1]+u+F[1],t[_][0]=r+B[0]+o+F[0]+(P/4294967296>>>0)>>>0,t[_][1]=P>>>0;m=e[0][0],g=e[0][1],y=e[1][0],b=e[1][1],w=e[2][0],E=e[2][1],S=e[3][0],x=e[3][1],T=e[4][0],N=e[4][1],C=e[5][0],k=e[5][1],L=e[6][0],A=e[6][1],O=e[7][0],M=e[7][1];for(_=0;_<80;++_)l=((T>>>14|N<<18)^(T>>>18|N<<14)^(N>>>9|T<<23))>>>0,c=((T<<18|N>>>14)^(T<<14|N>>>18)^(N<<23|T>>>9))>>>0,h=(L^T&(C^L))>>>0,p=(A^N&(k^A))>>>0,a=((m>>>28|g<<4)^(g>>>2|m<<30)^(g>>>7|m<<25))>>>0,f=((m<<4|g>>>28)^(g<<30|m>>>2)^(g<<25|m>>>7))>>>0,d=(m&y|w&(m^y))>>>0,v=(g&b|E&(g^b))>>>0,P=M+c+p+s[_][1]+t[_][1],r=O+l+h+s[_][0]+t[_][0]+(P/4294967296>>>0)>>>0,i=P>>>0,P=f+v,o=a+d+(P/4294967296>>>0)>>>0,u=P>>>0,O=L,M=A,L=C,A=k,C=T,k=N,P=x+i,T=S+r+(P/4294967296>>>0)>>>0,N=P>>>0,S=w,x=E,w=y,E=b,y=m,b=g,P=i+u,m=r+o+(P/4294967296>>>0)>>>0,g=P>>>0;P=e[0][1]+g,e[0][0]=e[0][0]+m+(P/4294967296>>>0)>>>0,e[0][1]=P>>>0,P=e[1][1]+b,e[1][0]=e[1][0]+y+(P/4294967296>>>0)>>>0,e[1][1]=P>>>0,P=e[2][1]+E,e[2][0]=e[2][0]+w+(P/4294967296>>>0)>>>0,e[2][1]=P>>>0,P=e[3][1]+x,e[3][0]=e[3][0]+S+(P/4294967296>>>0)>>>0,e[3][1]=P>>>0,P=e[4][1]+N,e[4][0]=e[4][0]+T+(P/4294967296>>>0)>>>0,e[4][1]=P>>>0,P=e[5][1]+k,e[5][0]=e[5][0]+C+(P/4294967296>>>0)>>>0,e[5][1]=P>>>0,P=e[6][1]+A,e[6][0]=e[6][0]+L+(P/4294967296>>>0)>>>0,e[6][1]=P>>>0,P=e[7][1]+M,e[7][0]=e[7][0]+O+(P/4294967296>>>0)>>>0,e[7][1]=P>>>0,I-=128}}var t=e.sha512=e.sha512||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha512=e.md.algorithms.sha512=t;var n=e.sha384=e.sha512.sha384=e.sha512.sha384||{};n.create=function(){return t.create("SHA-384")},e.md.sha384=e.md.algorithms.sha384=n,e.sha512.sha256=e.sha512.sha256||{create:function(){return t.create("SHA-512/256")}},e.md["sha512/256"]=e.md.algorithms["sha512/256"]=e.sha512.sha256,e.sha512.sha224=e.sha512.sha224||{create:function(){return t.create("SHA-512/224")}},e.md["sha512/224"]=e.md.algorithms["sha512/224"]=e.sha512.sha224,t.create=function(t){i||u(),typeof t=="undefined"&&(t="SHA-512");if(t in o){var n=o[t],s=null,f=e.util.createBuffer(),l=new Array(80);for(var c=0;c<80;++c)l[c]=new Array(2);var h={algorithm:t.replace("-","").toLowerCase(),blockLength:128,digestLength:64,messageLength:0,messageLength128:[0,0,0,0]};return h.start=function(){h.messageLength=0,h.messageLength128=[0,0,0,0],f=e.util.createBuffer(),s=new Array(n.length);for(var t=0;t<n.length;++t)s[t]=n[t].slice(0);return h},h.start(),h.update=function(t,n){n==="utf8"&&(t=e.util.encodeUtf8(t)),h.messageLength+=t.length;var r=t.length;r=[r/4294967296>>>0,r>>>0];for(var i=3;i>=0;--i)h.messageLength128[i]+=r[1],r[1]=r[0]+(h.messageLength128[i]/4294967296>>>0),h.messageLength128[i]=h.messageLength128[i]>>>0,r[0]=r[1]/4294967296>>>0;return f.putBytes(t),a(s,l,f),(f.read>2048||f.length()===0)&&f.compact(),h},h.digest=function(){var n=e.util.createBuffer();n.putBytes(f.bytes()),n.putBytes(r.substr(0,128-(h.messageLength128[3]+16&127)));var i=[];for(var o=0;o<3;++o)i[o]=h.messageLength128[o]<<3|h.messageLength128[o-1]>>>28;i[3]=h.messageLength128[3]<<3,n.putInt32(i[0]),n.putInt32(i[1]),n.putInt32(i[2]),n.putInt32(i[3]);var u=new Array(s.length);for(var o=0;o<s.length;++o)u[o]=s[o].slice(0);a(u,l,n);var c=e.util.createBuffer(),p;t==="SHA-512"?p=u.length:t==="SHA-384"?p=u.length-2:p=u.length-4;for(var o=0;o<p;++o)c.putInt32(u[o][0]),(o!==p-1||t!=="SHA-512/224")&&c.putInt32(u[o][1]);return c},h}throw new Error("Invalid SHA-512 algorithm: "+t)};var r=null,i=!1,s=null,o=null}var r="sha512";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha512",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.md=e.md||{},e.md.algorithms={md5:e.md5,sha1:e.sha1,sha256:e.sha256},e.md.md5=e.md5,e.md.sha1=e.sha1,e.md.sha256=e.sha256}var r="md";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md",["require","module","./md5","./sha1","./sha256","./sha512"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.hmac=e.hmac||{};t.create=function(){var t=null,n=null,r=null,i=null,s={};return s.start=function(s,o){if(s!==null)if(typeof s=="string"){s=s.toLowerCase();if(!(s in e.md.algorithms))throw new Error('Unknown hash algorithm "'+s+'"');n=e.md.algorithms[s].create()}else n=s;if(o===null)o=t;else{if(typeof o=="string")o=e.util.createBuffer(o);else if(e.util.isArray(o)){var u=o;o=e.util.createBuffer();for(var a=0;a<u.length;++a)o.putByte(u[a])}var f=o.length();f>n.blockLength&&(n.start(),n.update(o.bytes()),o=n.digest()),r=e.util.createBuffer(),i=e.util.createBuffer(),f=o.length();for(var a=0;a<f;++a){var u=o.at(a);r.putByte(54^u),i.putByte(92^u)}if(f<n.blockLength){var u=n.blockLength-f;for(var a=0;a<u;++a)r.putByte(54),i.putByte(92)}t=o,r=r.bytes(),i=i.bytes()}n.start(),n.update(r)},s.update=function(e){n.update(e)},s.getMac=function(){var e=n.digest().bytes();return n.start(),n.update(i),n.update(e),n.digest()},s.digest=s.getMac,s}}var r="hmac";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/hmac",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(e){var t=e.name+": ",n=[],r=function(e,t){return" "+t};for(var i=0;i<e.values.length;++i)n.push(e.values[i].replace(/^(\S+\r\n)/,r));t+=n.join(",")+"\r\n";var s=0,o=-1;for(var i=0;i<t.length;++i,++s)if(s>65&&o!==-1){var u=t[o];u===","?(++o,t=t.substr(0,o)+"\r\n "+t.substr(o)):t=t.substr(0,o)+"\r\n"+u+t.substr(o+1),s=i-o-1,o=-1,++i}else if(t[i]===" "||t[i]==="	"||t[i]===",")o=i;return t}function r(e){return e.replace(/^\s+/,"")}var t=e.pem=e.pem||{};t.encode=function(t,r){r=r||{};var i="-----BEGIN "+t.type+"-----\r\n",s;t.procType&&(s={name:"Proc-Type",values:[String(t.procType.version),t.procType.type]},i+=n(s)),t.contentDomain&&(s={name:"Content-Domain",values:[t.contentDomain]},i+=n(s)),t.dekInfo&&(s={name:"DEK-Info",values:[t.dekInfo.algorithm]},t.dekInfo.parameters&&s.values.push(t.dekInfo.parameters),i+=n(s));if(t.headers)for(var o=0;o<t.headers.length;++o)i+=n(t.headers[o]);return t.procType&&(i+="\r\n"),i+=e.util.encode64(t.body,r.maxline||64)+"\r\n",i+="-----END "+t.type+"-----\r\n",i},t.decode=function(t){var n=[],i=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,s=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,o=/\r?\n/,u;for(;;){u=i.exec(t);if(!u)break;var a={type:u[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:e.util.decode64(u[3])};n.push(a);if(!u[2])continue;var f=u[2].split(o),l=0;while(u&&l<f.length){var c=f[l].replace(/\s+$/,"");for(var h=l+1;h<f.length;++h){var p=f[h];if(!/\s/.test(p[0]))break;c+=p,l=h}u=c.match(s);if(u){var d={name:u[1],values:[]},v=u[2].split(",");for(var m=0;m<v.length;++m)d.values.push(r(v[m]));if(!a.procType){if(d.name!=="Proc-Type")throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');if(d.values.length!==2)throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');a.procType={version:v[0],type:v[1]}}else if(!a.contentDomain&&d.name==="Content-Domain")a.contentDomain=v[0]||"";else if(!a.dekInfo&&d.name==="DEK-Info"){if(d.values.length===0)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');a.dekInfo={algorithm:v[0],parameters:v[1]||null}}else a.headers.push(d)}++l}if(a.procType==="ENCRYPTED"&&!a.dekInfo)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')}if(n.length===0)throw new Error("Invalid PEM formatted message.");return n}}var r="pem";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pem",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function t(t,n){var r=function(){return new e.des.Algorithm(t,n)};e.cipher.registerAlgorithm(t,r)}function l(e){var t=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],n=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],r=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],i=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],s=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],o=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],u=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],a=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],f=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],l=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],c=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],h=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],p=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],d=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],v=e.length()>8?3:1,m=[],g=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],y=0,b;for(var w=0;w<v;w++){var E=e.getInt32(),S=e.getInt32();b=(E>>>4^S)&252645135,S^=b,E^=b<<4,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>2^S)&858993459,S^=b,E^=b<<2,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=(S>>>8^E)&16711935,E^=b,S^=b<<8,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=E<<8|S>>>20&240,E=S<<24|S<<8&16711680|S>>>8&65280|S>>>24&240,S=b;for(var x=0;x<g.length;++x){g[x]?(E=E<<2|E>>>26,S=S<<2|S>>>26):(E=E<<1|E>>>27,S=S<<1|S>>>27),E&=-15,S&=-15;var T=t[E>>>28]|n[E>>>24&15]|r[E>>>20&15]|i[E>>>16&15]|s[E>>>12&15]|o[E>>>8&15]|u[E>>>4&15],N=a[S>>>28]|f[S>>>24&15]|l[S>>>20&15]|c[S>>>16&15]|h[S>>>12&15]|p[S>>>8&15]|d[S>>>4&15];b=(N>>>16^T)&65535,m[y++]=T^b,m[y++]=N^b<<16}}return m}function c(e,t,l,c){var h=e.length===32?3:9,p;h===3?p=c?[30,-2,-2]:[0,32,2]:p=c?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];var d,v=t[0],m=t[1];d=(v>>>4^m)&252645135,m^=d,v^=d<<4,d=(v>>>16^m)&65535,m^=d,v^=d<<16,d=(m>>>2^v)&858993459,v^=d,m^=d<<2,d=(m>>>8^v)&16711935,v^=d,m^=d<<8,d=(v>>>1^m)&1431655765,m^=d,v^=d<<1,v=v<<1|v>>>31,m=m<<1|m>>>31;for(var g=0;g<h;g+=3){var y=p[g+1],b=p[g+2];for(var w=p[g];w!=y;w+=b){var E=m^e[w],S=(m>>>4|m<<28)^e[w+1];d=v,v=m,m=d^(r[E>>>24&63]|s[E>>>16&63]|u[E>>>8&63]|f[E&63]|n[S>>>24&63]|i[S>>>16&63]|o[S>>>8&63]|a[S&63])}d=v,v=m,m=d}v=v>>>1|v<<31,m=m>>>1|m<<31,d=(v>>>1^m)&1431655765,m^=d,v^=d<<1,d=(m>>>8^v)&16711935,v^=d,m^=d<<8,d=(m>>>2^v)&858993459,v^=d,m^=d<<2,d=(v>>>16^m)&65535,m^=d,v^=d<<16,d=(v>>>4^m)&252645135,m^=d,v^=d<<4,l[0]=v,l[1]=m}function h(t){t=t||{};var n=(t.mode||"CBC").toUpperCase(),r="DES-"+n,i;t.decrypt?i=e.cipher.createDecipher(r,t.key):i=e.cipher.createCipher(r,t.key);var s=i.start;return i.start=function(t,n){var r=null;n instanceof e.util.ByteBuffer&&(r=n,n={}),n=n||{},n.output=r,n.iv=t,s.call(i,n)},i}e.des=e.des||{},e.des.startEncrypting=function(e,t,n,r){var i=h({key:e,output:n,decrypt:!1,mode:r||(t===null?"ECB":"CBC")});return i.start(t),i},e.des.createEncryptionCipher=function(e,t){return h({key:e,output:null,decrypt:!1,mode:t})},e.des.startDecrypting=function(e,t,n,r){var i=h({key:e,output:n,decrypt:!0,mode:r||(t===null?"ECB":"CBC")});return i.start(t),i},e.des.createDecryptionCipher=function(e,t){return h({key:e,output:null,decrypt:!0,mode:t})},e.des.Algorithm=function(e,t){var n=this;n.name=e,n.mode=new t({blockSize:8,cipher:{encrypt:function(e,t){return c(n._keys,e,t,!1)},decrypt:function(e,t){return c(n._keys,e,t,!0)}}}),n._init=!1},e.des.Algorithm.prototype.initialize=function(t){if(this._init)return;var n=e.util.createBuffer(t.key);if(this.name.indexOf("3DES")===0&&n.length()!==24)throw new Error("Invalid Triple-DES key size: "+n.length()*8);this._keys=l(n),this._init=!0},t("DES-ECB",e.cipher.modes.ecb),t("DES-CBC",e.cipher.modes.cbc),t("DES-CFB",e.cipher.modes.cfb),t("DES-OFB",e.cipher.modes.ofb),t("DES-CTR",e.cipher.modes.ctr),t("3DES-ECB",e.cipher.modes.ecb),t("3DES-CBC",e.cipher.modes.cbc),t("3DES-CFB",e.cipher.modes.cfb),t("3DES-OFB",e.cipher.modes.ofb),t("3DES-CTR",e.cipher.modes.ctr);var n=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],r=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],i=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],s=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],o=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],u=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],a=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],f=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696]}var r="des";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/des",["require","module","./cipher","./cipherModes","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var n=e.pkcs5=e.pkcs5||{},r=typeof process!="undefined"&&process.versions&&process.versions.node,i;r&&!e.disableNativeCode&&(i=t("crypto")),e.pbkdf2=n.pbkdf2=function(t,n,s,o,u,a){function w(){if(y>c)return a(null,d);p.start(null,null),p.update(n),p.update(e.util.int32ToBytes(y)),v=g=p.digest().getBytes(),b=2,E()}function E(){if(b<=s)return p.start(null,null),p.update(g),m=p.digest().getBytes(),v=e.util.xorBytes(v,m,f),g=m,++b,e.util.setImmediate(E);d+=y<c?v:v.substr(0,h),++y,w()}typeof u=="function"&&(a=u,u=null);if(r&&!e.disableNativeCode&&i.pbkdf2&&(u===null||typeof u!="object")&&(i.pbkdf2Sync.length>4||!u||u==="sha1"))return typeof u!="string"&&(u="sha1"),n=new Buffer(n,"binary"),a?i.pbkdf2Sync.length===4?i.pbkdf2(t,n,s,o,function(e,t){if(e)return a(e);a(null,t.toString("binary"))}):i.pbkdf2(t,n,s,o,u,function(e,t){if(e)return a(e);a(null,t.toString("binary"))}):i.pbkdf2Sync.length===4?i.pbkdf2Sync(t,n,s,o).toString("binary"):i.pbkdf2Sync(t,n,s,o,u).toString("binary");if(typeof u=="undefined"||u===null)u=e.md.sha1.create();if(typeof u=="string"){if(!(u in e.md.algorithms))throw new Error("Unknown hash algorithm: "+u);u=e.md[u].create()}var f=u.digestLength;if(o>4294967295*f){var l=new Error("Derived key is too long.");if(a)return a(l);throw l}var c=Math.ceil(o/f),h=o-(c-1)*f,p=e.hmac.create();p.start(u,t);var d="",v,m,g;if(!a){for(var y=1;y<=c;++y){p.start(null,null),p.update(n),p.update(e.util.int32ToBytes(y)),v=g=p.digest().getBytes();for(var b=2;b<=s;++b)p.start(null,null),p.update(g),m=p.digest().getBytes(),v=e.util.xorBytes(v,m,f),g=m;d+=y<c?v:v.substr(0,h)}return d}var y=1,b;w()}}var r="pbkdf2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbkdf2",["require","module","./hmac","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var n=typeof process!="undefined"&&process.versions&&process.versions.node,r=null;!e.disableNativeCode&&n&&!process.versions["node-webkit"]&&(r=t("crypto"));var i=e.prng=e.prng||{};i.create=function(t){function u(e){if(n.pools[0].messageLength>=32)return f(),e();var t=32-n.pools[0].messageLength<<5;n.seedFile(t,function(t,r){if(t)return e(t);n.collect(r),f(),e()})}function a(){if(n.pools[0].messageLength>=32)return f();var e=32-n.pools[0].messageLength<<5;n.collect(n.seedFileSync(e)),f()}function f(){var e=n.plugin.md.create();e.update(n.pools[0].digest().getBytes()),n.pools[0].start();var t=1;for(var r=1;r<32;++r)t=t===31?2147483648:t<<2,t%n.reseeds===0&&(e.update(n.pools[r].digest().getBytes()),n.pools[r].start());var i=e.digest().getBytes();e.start(),e.update(i);var s=e.digest().getBytes();n.key=n.plugin.formatKey(i),n.seed=n.plugin.formatSeed(s),n.reseeds=n.reseeds===4294967295?0:n.reseeds+1,n.generated=0}function l(t){var n=null;if(typeof window!="undefined"){var r=window.crypto||window.msCrypto;r&&r.getRandomValues&&(n=function(e){return r.getRandomValues(e)})}var i=e.util.createBuffer();if(n)while(i.length()<t){var s=Math.max(1,Math.min(t-i.length(),65536)/4),o=new Uint32Array(Math.floor(s));try{n(o);for(var u=0;u<o.length;++u)i.putInt32(o[u])}catch(a){if(!(typeof QuotaExceededError!="undefined"&&a instanceof QuotaExceededError))throw a}}if(i.length()<t){var f,l,c,h=Math.floor(Math.random()*65536);while(i.length()<t){l=16807*(h&65535),f=16807*(h>>16),l+=(f&32767)<<16,l+=f>>15,l=(l&2147483647)+(l>>31),h=l&4294967295;for(var u=0;u<3;++u)c=h>>>(u<<3),c^=Math.floor(Math.random()*256),i.putByte(String.fromCharCode(c&255))}}return i.getBytes(t)}var n={plugin:t,key:null,seed:null,time:null,reseeds:0,generated:0},i=t.md,s=new Array(32);for(var o=0;o<32;++o)s[o]=i.create();return n.pools=s,n.pool=0,n.generate=function(t,r){function l(c){if(c)return r(c);if(f.length()>=t)return r(null,f.getBytes(t));n.generated>1048575&&(n.key=null);if(n.key===null)return e.util.nextTick(function(){u(l)});var h=i(n.key,n.seed);n.generated+=h.length,f.putBytes(h),n.key=o(i(n.key,s(n.seed))),n.seed=a(i(n.key,n.seed)),e.util.setImmediate(l)}if(!r)return n.generateSync(t);var i=n.plugin.cipher,s=n.plugin.increment,o=n.plugin.formatKey,a=n.plugin.formatSeed,f=e.util.createBuffer();n.key=null,l()},n.generateSync=function(t){var r=n.plugin.cipher,i=n.plugin.increment,s=n.plugin.formatKey,o=n.plugin.formatSeed;n.key=null;var u=e.util.createBuffer();while(u.length()<t){n.generated>1048575&&(n.key=null),n.key===null&&a();var f=r(n.key,n.seed);n.generated+=f.length,u.putBytes(f),n.key=s(r(n.key,i(n.seed))),n.seed=o(r(n.key,n.seed))}return u.getBytes(t)},r?(n.seedFile=function(e,t){r.randomBytes(e,function(e,n){if(e)return t(e);t(null,n.toString())})},n.seedFileSync=function(e){return r.randomBytes(e).toString()}):(n.seedFile=function(e,t){try{t(null,l(e))}catch(n){t(n)}},n.seedFileSync=l),n.collect=function(e){var t=e.length;for(var r=0;r<t;++r)n.pools[n.pool].update(e.substr(r,1)),n.pool=n.pool===31?0:n.pool+1},n.collectInt=function(e,t){var r="";for(var i=0;i<t;i+=8)r+=String.fromCharCode(e>>i&255);n.collect(r)},n.registerWorker=function(e){if(e===self)n.seedFile=function(e,t){function n(e){var r=e.data;r.forge&&r.forge.prng&&(self.removeEventListener("message",n),t(r.forge.prng.err,r.forge.prng.bytes))}self.addEventListener("message",n),self.postMessage({forge:{prng:{needed:e}}})};else{var t=function(t){var r=t.data;r.forge&&r.forge.prng&&n.seedFile(r.forge.prng.needed,function(t,n){e.postMessage({forge:{prng:{err:t,bytes:n}}})})};e.addEventListener("message",t)}},n}}var r="prng";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/prng",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){if(e.random&&e.random.getBytes)return;(function(t){function s(){var t=e.prng.create(n);return t.getBytes=function(e,n){return t.generate(e,n)},t.getBytesSync=function(e){return t.generate(e)},t}var n={},r=new Array(4),i=e.util.createBuffer();n.formatKey=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),e.aes._expandKey(t,!1)},n.formatSeed=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),t},n.cipher=function(t,n){return e.aes._updateBlock(t,n,r,!1),i.putInt32(r[0]),i.putInt32(r[1]),i.putInt32(r[2]),i.putInt32(r[3]),i.getBytes()},n.increment=function(e){return++e[3],e},n.md=e.md.sha256;var o=s(),u=typeof process!="undefined"&&process.versions&&process.versions.node,a=null;if(typeof window!="undefined"){var f=window.crypto||window.msCrypto;f&&f.getRandomValues&&(a=function(e){return f.getRandomValues(e)})}if(e.disableNativeCode||!u&&!a){typeof window=="undefined"||window.document===undefined,o.collectInt(+(new Date),32);if(typeof navigator!="undefined"){var l="";for(var c in navigator)try{typeof navigator[c]=="string"&&(l+=navigator[c])}catch(h){}o.collect(l),l=null}t&&(t().mousemove(function(e){o.collectInt(e.clientX,16),o.collectInt(e.clientY,16)}),t().keypress(function(e){o.collectInt(e.charCode,8)}))}if(!e.random)e.random=o;else for(var c in o)e.random[c]=o[c];e.random.createInstance=s})(typeof jQuery!="undefined"?jQuery:null)}var r="random";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/random",["require","module","./aes","./md","./prng","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],n=[1,2,3,5],r=function(e,t){return e<<t&65535|(e&65535)>>16-t},i=function(e,t){return(e&65535)>>t|e<<16-t&65535};e.rc2=e.rc2||{},e.rc2.expandKey=function(n,r){typeof n=="string"&&(n=e.util.createBuffer(n)),r=r||128;var i=n,s=n.length(),o=r,u=Math.ceil(o/8),a=255>>(o&7),f;for(f=s;f<128;f++)i.putByte(t[i.at(f-1)+i.at(f-s)&255]);i.setAt(128-u,t[i.at(128-u)&a]);for(f=127-u;f>=0;f--)i.setAt(f,t[i.at(f+1)^i.at(f+u)]);return i};var s=function(t,s,o){var u=!1,a=null,f=null,l=null,c,h,p,d,v=[];t=e.rc2.expandKey(t,s);for(p=0;p<64;p++)v.push(t.getInt16Le());o?(c=function(e){for(p=0;p<4;p++)e[p]+=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),e[p]=r(e[p],n[p]),d++},h=function(e){for(p=0;p<4;p++)e[p]+=v[e[(p+3)%4]&63]}):(c=function(e){for(p=3;p>=0;p--)e[p]=i(e[p],n[p]),e[p]-=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),d--},h=function(e){for(p=3;p>=0;p--)e[p]-=v[e[(p+3)%4]&63]});var m=function(e){var t=[];for(p=0;p<4;p++){var n=a.getInt16Le();l!==null&&(o?n^=l.getInt16Le():l.putInt16Le(n)),t.push(n&65535)}d=o?0:63;for(var r=0;r<e.length;r++)for(var i=0;i<e[r][0];i++)e[r][1](t);for(p=0;p<4;p++)l!==null&&(o?l.putInt16Le(t[p]):t[p]^=l.getInt16Le()),f.putInt16Le(t[p])},g=null;return g={start:function(t,n){t&&typeof t=="string"&&(t=e.util.createBuffer(t)),u=!1,a=e.util.createBuffer(),f=n||new e.util.createBuffer,l=t,g.output=f},update:function(e){u||a.putBuffer(e);while(a.length()>=8)m([[5,c],[1,h],[6,c],[1,h],[5,c]])},finish:function(e){var t=!0;if(o)if(e)t=e(8,a,!o);else{var n=a.length()===8?8:8-a.length();a.fillWithByte(n,n)}t&&(u=!0,g.update());if(!o){t=a.length()===0;if(t)if(e)t=e(8,f,!o);else{var r=f.length(),i=f.at(r-1);i>r?t=!1:f.truncate(i)}}return t}},g};e.rc2.startEncrypting=function(t,n,r){var i=e.rc2.createEncryptionCipher(t,128);return i.start(n,r),i},e.rc2.createEncryptionCipher=function(e,t){return s(e,t,!0)},e.rc2.startDecrypting=function(t,n,r){var i=e.rc2.createDecryptionCipher(t,128);return i.start(n,r),i},e.rc2.createDecryptionCipher=function(e,t){return s(e,t,!1)}}var r="rc2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rc2",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function i(e,t,n){this.data=[],e!=null&&("number"==typeof e?this.fromNumber(e,t,n):t==null&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function s(){return new i(null)}function o(e,t,n,r,i,s){while(--s>=0){var o=t*this.data[e++]+n.data[r]+i;i=Math.floor(o/67108864),n.data[r++]=o&67108863}return i}function u(e,t,n,r,i,s){var o=t&32767,u=t>>15;while(--s>=0){var a=this.data[e]&32767,f=this.data[e++]>>15,l=u*a+f*o;a=o*a+((l&32767)<<15)+n.data[r]+(i&1073741823),i=(a>>>30)+(l>>>15)+u*f+(i>>>30),n.data[r++]=a&1073741823}return i}function a(e,t,n,r,i,s){var o=t&16383,u=t>>14;while(--s>=0){var a=this.data[e]&16383,f=this.data[e++]>>14,l=u*a+f*o;a=o*a+((l&16383)<<14)+n.data[r]+i,i=(a>>28)+(l>>14)+u*f,n.data[r++]=a&268435455}return i}function d(e){return l.charAt(e)}function v(e,t){var n=c[e.charCodeAt(t)];return n==null?-1:n}function m(e){for(var t=this.t-1;t>=0;--t)e.data[t]=this.data[t];e.t=this.t,e.s=this.s}function g(e){this.t=1,this.s=e<0?-1:0,e>0?this.data[0]=e:e<-1?this.data[0]=e+this.DV:this.t=0}function y(e){var t=s();return t.fromInt(e),t}function b(e,t){var n;if(t==16)n=4;else if(t==8)n=3;else if(t==256)n=8;else if(t==2)n=1;else if(t==32)n=5;else{if(t!=4){this.fromRadix(e,t);return}n=2}this.t=0,this.s=0;var r=e.length,s=!1,o=0;while(--r>=0){var u=n==8?e[r]&255:v(e,r);if(u<0){e.charAt(r)=="-"&&(s=!0);continue}s=!1,o==0?this.data[this.t++]=u:o+n>this.DB?(this.data[this.t-1]|=(u&(1<<this.DB-o)-1)<<o,this.data[this.t++]=u>>this.DB-o):this.data[this.t-1]|=u<<o,o+=n,o>=this.DB&&(o-=this.DB)}n==8&&(e[0]&128)!=0&&(this.s=-1,o>0&&(this.data[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),s&&i.ZERO.subTo(this,this)}function w(){var e=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==e)--this.t}function E(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(e==16)t=4;else if(e==8)t=3;else if(e==2)t=1;else if(e==32)t=5;else{if(e!=4)return this.toRadix(e);t=2}var n=(1<<t)-1,r,i=!1,s="",o=this.t,u=this.DB-o*this.DB%t;if(o-->0){u<this.DB&&(r=this.data[o]>>u)>0&&(i=!0,s=d(r));while(o>=0)u<t?(r=(this.data[o]&(1<<u)-1)<<t-u,r|=this.data[--o]>>(u+=this.DB-t)):(r=this.data[o]>>(u-=t)&n,u<=0&&(u+=this.DB,--o)),r>0&&(i=!0),i&&(s+=d(r))}return i?s:"0"}function S(){var e=s();return i.ZERO.subTo(this,e),e}function x(){return this.s<0?this.negate():this}function T(e){var t=this.s-e.s;if(t!=0)return t;var n=this.t;t=n-e.t;if(t!=0)return this.s<0?-t:t;while(--n>=0)if((t=this.data[n]-e.data[n])!=0)return t;return 0}function N(e){var t=1,n;return(n=e>>>16)!=0&&(e=n,t+=16),(n=e>>8)!=0&&(e=n,t+=8),(n=e>>4)!=0&&(e=n,t+=4),(n=e>>2)!=0&&(e=n,t+=2),(n=e>>1)!=0&&(e=n,t+=1),t}function C(){return this.t<=0?0:this.DB*(this.t-1)+N(this.data[this.t-1]^this.s&this.DM)}function k(e,t){var n;for(n=this.t-1;n>=0;--n)t.data[n+e]=this.data[n];for(n=e-1;n>=0;--n)t.data[n]=0;t.t=this.t+e,t.s=this.s}function L(e,t){for(var n=e;n<this.t;++n)t.data[n-e]=this.data[n];t.t=Math.max(this.t-e,0),t.s=this.s}function A(e,t){var n=e%this.DB,r=this.DB-n,i=(1<<r)-1,s=Math.floor(e/this.DB),o=this.s<<n&this.DM,u;for(u=this.t-1;u>=0;--u)t.data[u+s+1]=this.data[u]>>r|o,o=(this.data[u]&i)<<n;for(u=s-1;u>=0;--u)t.data[u]=0;t.data[s]=o,t.t=this.t+s+1,t.s=this.s,t.clamp()}function O(e,t){t.s=this.s;var n=Math.floor(e/this.DB);if(n>=this.t){t.t=0;return}var r=e%this.DB,i=this.DB-r,s=(1<<r)-1;t.data[0]=this.data[n]>>r;for(var o=n+1;o<this.t;++o)t.data[o-n-1]|=(this.data[o]&s)<<i,t.data[o-n]=this.data[o]>>r;r>0&&(t.data[this.t-n-1]|=(this.s&s)<<i),t.t=this.t-n,t.clamp()}function M(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]-e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r-=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r-=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r-=e.s}t.s=r<0?-1:0,r<-1?t.data[n++]=this.DV+r:r>0&&(t.data[n++]=r),t.t=n,t.clamp()}function _(e,t){var n=this.abs(),r=e.abs(),s=n.t;t.t=s+r.t;while(--s>=0)t.data[s]=0;for(s=0;s<r.t;++s)t.data[s+n.t]=n.am(0,r.data[s],t,s,0,n.t);t.s=0,t.clamp(),this.s!=e.s&&i.ZERO.subTo(t,t)}function D(e){var t=this.abs(),n=e.t=2*t.t;while(--n>=0)e.data[n]=0;for(n=0;n<t.t-1;++n){var r=t.am(n,t.data[n],e,2*n,0,1);(e.data[n+t.t]+=t.am(n+1,2*t.data[n],e,2*n+1,r,t.t-n-1))>=t.DV&&(e.data[n+t.t]-=t.DV,e.data[n+t.t+1]=1)}e.t>0&&(e.data[e.t-1]+=t.am(n,t.data[n],e,2*n,0,1)),e.s=0,e.clamp()}function P(e,t,n){var r=e.abs();if(r.t<=0)return;var o=this.abs();if(o.t<r.t){t!=null&&t.fromInt(0),n!=null&&this.copyTo(n);return}n==null&&(n=s());var u=s(),a=this.s,f=e.s,l=this.DB-N(r.data[r.t-1]);l>0?(r.lShiftTo(l,u),o.lShiftTo(l,n)):(r.copyTo(u),o.copyTo(n));var c=u.t,h=u.data[c-1];if(h==0)return;var p=h*(1<<this.F1)+(c>1?u.data[c-2]>>this.F2:0),d=this.FV/p,v=(1<<this.F1)/p,m=1<<this.F2,g=n.t,y=g-c,b=t==null?s():t;u.dlShiftTo(y,b),n.compareTo(b)>=0&&(n.data[n.t++]=1,n.subTo(b,n)),i.ONE.dlShiftTo(c,b),b.subTo(u,u);while(u.t<c)u.data[u.t++]=0;while(--y>=0){var w=n.data[--g]==h?this.DM:Math.floor(n.data[g]*d+(n.data[g-1]+m)*v);if((n.data[g]+=u.am(0,w,n,y,0,c))<w){u.dlShiftTo(y,b),n.subTo(b,n);while(n.data[g]<--w)n.subTo(b,n)}}t!=null&&(n.drShiftTo(c,t),a!=f&&i.ZERO.subTo(t,t)),n.t=c,n.clamp(),l>0&&n.rShiftTo(l,n),a<0&&i.ZERO.subTo(n,n)}function H(e){var t=s();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(i.ZERO)>0&&e.subTo(t,t),t}function B(e){this.m=e}function j(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e}function F(e){return e}function I(e){e.divRemTo(this.m,null,e)}function q(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function R(e,t){e.squareTo(t),this.reduce(t)}function U(){if(this.t<1)return 0;var e=this.data[0];if((e&1)==0)return 0;var t=e&3;return t=t*(2-(e&15)*t)&15,t=t*(2-(e&255)*t)&255,t=t*(2-((e&65535)*t&65535))&65535,t=t*(2-e*t%this.DV)%this.DV,t>0?this.DV-t:-t}function z(e){this.m=e,this.mp=e.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function W(e){var t=s();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(i.ZERO)>0&&this.m.subTo(t,t),t}function X(e){var t=s();return e.copyTo(t),this.reduce(t),t}function V(e){while(e.t<=this.mt2)e.data[e.t++]=0;for(var t=0;t<this.m.t;++t){var n=e.data[t]&32767,r=n*this.mpl+((n*this.mph+(e.data[t]>>15)*this.mpl&this.um)<<15)&e.DM;n=t+this.m.t,e.data[n]+=this.m.am(0,r,e,t,0,this.m.t);while(e.data[n]>=e.DV)e.data[n]-=e.DV,e.data[++n]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)}function $(e,t){e.squareTo(t),this.reduce(t)}function J(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function K(){return(this.t>0?this.data[0]&1:this.s)==0}function Q(e,t){if(e>4294967295||e<1)return i.ONE;var n=s(),r=s(),o=t.convert(this),u=N(e)-1;o.copyTo(n);while(--u>=0){t.sqrTo(n,r);if((e&1<<u)>0)t.mulTo(r,o,n);else{var a=n;n=r,r=a}}return t.revert(n)}function G(e,t){var n;return e<256||t.isEven()?n=new B(t):n=new z(t),this.exp(e,n)}function Y(){var e=s();return this.copyTo(e),e}function Z(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this.data[0];if(this.t==0)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]}function et(){return this.t==0?this.s:this.data[0]<<24>>24}function tt(){return this.t==0?this.s:this.data[0]<<16>>16}function nt(e){return Math.floor(Math.LN2*this.DB/Math.log(e))}function rt(){return this.s<0?-1:this.t<=0||this.t==1&&this.data[0]<=0?0:1}function it(e){e==null&&(e=10);if(this.signum()==0||e<2||e>36)return"0";var t=this.chunkSize(e),n=Math.pow(e,t),r=y(n),i=s(),o=s(),u="";this.divRemTo(r,i,o);while(i.signum()>0)u=(n+o.intValue()).toString(e).substr(1)+u,i.divRemTo(r,i,o);return o.intValue().toString(e)+u}function st(e,t){this.fromInt(0),t==null&&(t=10);var n=this.chunkSize(t),r=Math.pow(t,n),s=!1,o=0,u=0;for(var a=0;a<e.length;++a){var f=v(e,a);if(f<0){e.charAt(a)=="-"&&this.signum()==0&&(s=!0);continue}u=t*u+f,++o>=n&&(this.dMultiply(r),this.dAddOffset(u,0),o=0,u=0)}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(u,0)),s&&i.ZERO.subTo(this,this)}function ot(e,t,n){if("number"==typeof t)if(e<2)this.fromInt(1);else{this.fromNumber(e,n),this.testBit(e-1)||this.bitwiseTo(i.ONE.shiftLeft(e-1),dt,this),this.isEven()&&this.dAddOffset(1,0);while(!this.isProbablePrime(t))this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(i.ONE.shiftLeft(e-1),this)}else{var r=new Array,s=e&7;r.length=(e>>3)+1,t.nextBytes(r),s>0?r[0]&=(1<<s)-1:r[0]=0,this.fromString(r,256)}}function ut(){var e=this.t,t=new Array;t[0]=this.s;var n=this.DB-e*this.DB%8,r,i=0;if(e-->0){n<this.DB&&(r=this.data[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);while(e>=0){n<8?(r=(this.data[e]&(1<<n)-1)<<8-n,r|=this.data[--e]>>(n+=this.DB-8)):(r=this.data[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),(r&128)!=0&&(r|=-256),i==0&&(this.s&128)!=(r&128)&&++i;if(i>0||r!=this.s)t[i++]=r}}return t}function at(e){return this.compareTo(e)==0}function ft(e){return this.compareTo(e)<0?this:e}function lt(e){return this.compareTo(e)>0?this:e}function ct(e,t,n){var r,i,s=Math.min(e.t,this.t);for(r=0;r<s;++r)n.data[r]=t(this.data[r],e.data[r]);if(e.t<this.t){i=e.s&this.DM;for(r=s;r<this.t;++r)n.data[r]=t(this.data[r],i);n.t=this.t}else{i=this.s&this.DM;for(r=s;r<e.t;++r)n.data[r]=t(i,e.data[r]);n.t=e.t}n.s=t(this.s,e.s),n.clamp()}function ht(e,t){return e&t}function pt(e){var t=s();return this.bitwiseTo(e,ht,t),t}function dt(e,t){return e|t}function vt(e){var t=s();return this.bitwiseTo(e,dt,t),t}function mt(e,t){return e^t}function gt(e){var t=s();return this.bitwiseTo(e,mt,t),t}function yt(e,t){return e&~t}function bt(e){var t=s();return this.bitwiseTo(e,yt,t),t}function wt(){var e=s();for(var t=0;t<this.t;++t)e.data[t]=this.DM&~this.data[t];return e.t=this.t,e.s=~this.s,e}function Et(e){var t=s();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t}function St(e){var t=s();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t}function xt(e){if(e==0)return-1;var t=0;return(e&65535)==0&&(e>>=16,t+=16),(e&255)==0&&(e>>=8,t+=8),(e&15)==0&&(e>>=4,t+=4),(e&3)==0&&(e>>=2,t+=2),(e&1)==0&&++t,t}function Tt(){for(var e=0;e<this.t;++e)if(this.data[e]!=0)return e*this.DB+xt(this.data[e]);return this.s<0?this.t*this.DB:-1}function Nt(e){var t=0;while(e!=0)e&=e-1,++t;return t}function Ct(){var e=0,t=this.s&this.DM;for(var n=0;n<this.t;++n)e+=Nt(this.data[n]^t);return e}function kt(e){var t=Math.floor(e/this.DB);return t>=this.t?this.s!=0:(this.data[t]&1<<e%this.DB)!=0}function Lt(e,t){var n=i.ONE.shiftLeft(e);return this.bitwiseTo(n,t,n),n}function At(e){return this.changeBit(e,dt)}function Ot(e){return this.changeBit(e,yt)}function Mt(e){return this.changeBit(e,mt)}function _t(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]+e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r+=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r+=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=e.s}t.s=r<0?-1:0,r>0?t.data[n++]=r:r<-1&&(t.data[n++]=this.DV+r),t.t=n,t.clamp()}function Dt(e){var t=s();return this.addTo(e,t),t}function Pt(e){var t=s();return this.subTo(e,t),t}function Ht(e){var t=s();return this.multiplyTo(e,t),t}function Bt(e){var t=s();return this.divRemTo(e,t,null),t}function jt(e){var t=s();return this.divRemTo(e,null,t),t}function Ft(e){var t=s(),n=s();return this.divRemTo(e,t,n),new Array(t,n)}function It(e){this.data[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()}function qt(e,t){if(e==0)return;while(this.t<=t)this.data[this.t++]=0;this.data[t]+=e;while(this.data[t]>=this.DV)this.data[t]-=this.DV,++t>=this.t&&(this.data[this.t++]=0),++this.data[t]}function Rt(){}function Ut(e){return e}function zt(e,t,n){e.multiplyTo(t,n)}function Wt(e,t){e.squareTo(t)}function Xt(e){return this.exp(e,new Rt)}function Vt(e,t,n){var r=Math.min(this.t+e.t,t);n.s=0,n.t=r;while(r>0)n.data[--r]=0;var i;for(i=n.t-this.t;r<i;++r)n.data[r+this.t]=this.am(0,e.data[r],n,r,0,this.t);for(i=Math.min(e.t,t);r<i;++r)this.am(0,e.data[r],n,r,0,t-r);n.clamp()}function $t(e,t,n){--t;var r=n.t=this.t+e.t-t;n.s=0;while(--r>=0)n.data[r]=0;for(r=Math.max(t-this.t,0);r<e.t;++r)n.data[this.t+r-t]=this.am(t-r,e.data[r],n,0,0,this.t+r-t);n.clamp(),n.drShiftTo(1,n)}function Jt(e){this.r2=s(),this.q3=s(),i.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}function Kt(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=s();return e.copyTo(t),this.reduce(t),t}function Qt(e){return e}function Gt(e){e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(e.compareTo(this.r2)<0)e.dAddOffset(1,this.m.t+1);e.subTo(this.r2,e);while(e.compareTo(this.m)>=0)e.subTo(this.m,e)}function Yt(e,t){e.squareTo(t),this.reduce(t)}function Zt(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function en(e,t){var n=e.bitLength(),r,i=y(1),o;if(n<=0)return i;n<18?r=1:n<48?r=3:n<144?r=4:n<768?r=5:r=6,n<8?o=new B(t):t.isEven()?o=new Jt(t):o=new z(t);var u=new Array,a=3,f=r-1,l=(1<<r)-1;u[1]=o.convert(this);if(r>1){var c=s();o.sqrTo(u[1],c);while(a<=l)u[a]=s(),o.mulTo(c,u[a-2],u[a]),a+=2}var h=e.t-1,p,d=!0,v=s(),m;n=N(e.data[h])-1;while(h>=0){n>=f?p=e.data[h]>>n-f&l:(p=(e.data[h]&(1<<n+1)-1)<<f-n,h>0&&(p|=e.data[h-1]>>this.DB+n-f)),a=r;while((p&1)==0)p>>=1,--a;(n-=a)<0&&(n+=this.DB,--h);if(d)u[p].copyTo(i),d=!1;else{while(a>1)o.sqrTo(i,v),o.sqrTo(v,i),a-=2;a>0?o.sqrTo(i,v):(m=i,i=v,v=m),o.mulTo(v,u[p],i)}while(h>=0&&(e.data[h]&1<<n)==0)o.sqrTo(i,v),m=i,i=v,v=m,--n<0&&(n=this.DB-1,--h)}return o.revert(i)}function tn(e){var t=this.s<0?this.negate():this.clone(),n=e.s<0?e.negate():e.clone();if(t.compareTo(n)<0){var r=t;t=n,n=r}var i=t.getLowestSetBit(),s=n.getLowestSetBit();if(s<0)return t;i<s&&(s=i),s>0&&(t.rShiftTo(s,t),n.rShiftTo(s,n));while(t.signum()>0)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=n.getLowestSetBit())>0&&n.rShiftTo(i,n),t.compareTo(n)>=0?(t.subTo(n,t),t.rShiftTo(1,t)):(n.subTo(t,n),n.rShiftTo(1,n));return s>0&&n.lShiftTo(s,n),n}function nn(e){if(e<=0)return 0;var t=this.DV%e,n=this.s<0?e-1:0;if(this.t>0)if(t==0)n=this.data[0]%e;else for(var r=this.t-1;r>=0;--r)n=(t*n+this.data[r])%e;return n}function rn(e){var t=e.isEven();if(this.isEven()&&t||e.signum()==0)return i.ZERO;var n=e.clone(),r=this.clone(),s=y(1),o=y(0),u=y(0),a=y(1);while(n.signum()!=0){while(n.isEven()){n.rShiftTo(1,n);if(t){if(!s.isEven()||!o.isEven())s.addTo(this,s),o.subTo(e,o);s.rShiftTo(1,s)}else o.isEven()||o.subTo(e,o);o.rShiftTo(1,o)}while(r.isEven()){r.rShiftTo(1,r);if(t){if(!u.isEven()||!a.isEven())u.addTo(this,u),a.subTo(e,a);u.rShiftTo(1,u)}else a.isEven()||a.subTo(e,a);a.rShiftTo(1,a)}n.compareTo(r)>=0?(n.subTo(r,n),t&&s.subTo(u,s),o.subTo(a,o)):(r.subTo(n,r),t&&u.subTo(s,u),a.subTo(o,a))}return r.compareTo(i.ONE)!=0?i.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a}function un(e){var t,n=this.abs();if(n.t==1&&n.data[0]<=sn[sn.length-1]){for(t=0;t<sn.length;++t)if(n.data[0]==sn[t])return!0;return!1}if(n.isEven())return!1;t=1;while(t<sn.length){var r=sn[t],i=t+1;while(i<sn.length&&r<on)r*=sn[i++];r=n.modInt(r);while(t<i)if(r%sn[t++]==0)return!1}return n.millerRabin(e)}function an(e){var t=this.subtract(i.ONE),n=t.getLowestSetBit();if(n<=0)return!1;var r=t.shiftRight(n),s=fn(),o;for(var u=0;u<e;++u){do o=new i(this.bitLength(),s);while(o.compareTo(i.ONE)<=0||o.compareTo(t)>=0);var a=o.modPow(r,this);if(a.compareTo(i.ONE)!=0&&a.compareTo(t)!=0){var f=1;while(f++<n&&a.compareTo(t)!=0){a=a.modPowInt(2,this);if(a.compareTo(i.ONE)==0)return!1}if(a.compareTo(t)!=0)return!1}}return!0}function fn(){return{nextBytes:function(e){for(var t=0;t<e.length;++t)e[t]=Math.floor(Math.random()*256)}}}var t,n=0xdeadbeefcafe,r=(n&16777215)==15715070;typeof navigator=="undefined"?(i.prototype.am=a,t=28):r&&navigator.appName=="Microsoft Internet Explorer"?(i.prototype.am=u,t=30):r&&navigator.appName!="Netscape"?(i.prototype.am=o,t=26):(i.prototype.am=a,t=28),i.prototype.DB=t,i.prototype.DM=(1<<t)-1,i.prototype.DV=1<<t;var f=52;i.prototype.FV=Math.pow(2,f),i.prototype.F1=f-t,i.prototype.F2=2*t-f;var l="0123456789abcdefghijklmnopqrstuvwxyz",c=new Array,h,p;h="0".charCodeAt(0);for(p=0;p<=9;++p)c[h++]=p;h="a".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;h="A".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;B.prototype.convert=j,B.prototype.revert=F,B.prototype.reduce=I,B.prototype.mulTo=q,B.prototype.sqrTo=R,z.prototype.convert=W,z.prototype.revert=X,z.prototype.reduce=V,z.prototype.mulTo=J,z.prototype.sqrTo=$,i.prototype.copyTo=m,i.prototype.fromInt=g,i.prototype.fromString=b,i.prototype.clamp=w,i.prototype.dlShiftTo=k,i.prototype.drShiftTo=L,i.prototype.lShiftTo=A,i.prototype.rShiftTo=O,i.prototype.subTo=M,i.prototype.multiplyTo=_,i.prototype.squareTo=D,i.prototype.divRemTo=P,i.prototype.invDigit=U,i.prototype.isEven=K,i.prototype.exp=Q,i.prototype.toString=E,i.prototype.negate=S,i.prototype.abs=x,i.prototype.compareTo=T,i.prototype.bitLength=C,i.prototype.mod=H,i.prototype.modPowInt=G,i.ZERO=y(0),i.ONE=y(1),Rt.prototype.convert=Ut,Rt.prototype.revert=Ut,Rt.prototype.mulTo=zt,Rt.prototype.sqrTo=Wt,Jt.prototype.convert=Kt,Jt.prototype.revert=Qt,Jt.prototype.reduce=Gt,Jt.prototype.mulTo=Zt,Jt.prototype.sqrTo=Yt;var sn=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],on=(1<<26)/sn[sn.length-1];i.prototype.chunkSize=nt,i.prototype.toRadix=it,i.prototype.fromRadix=st,i.prototype.fromNumber=ot,i.prototype.bitwiseTo=ct,i.prototype.changeBit=Lt,i.prototype.addTo=_t,i.prototype.dMultiply=It,i.prototype.dAddOffset=qt,i.prototype.multiplyLowerTo=Vt,i.prototype.multiplyUpperTo=$t,i.prototype.modInt=nn,i.prototype.millerRabin=an,i.prototype.clone=Y,i.prototype.intValue=Z,i.prototype.byteValue=et,i.prototype.shortValue=tt,i.prototype.signum=rt,i.prototype.toByteArray=ut,i.prototype.equals=at,i.prototype.min=ft,i.prototype.max=lt,i.prototype.and=pt,i.prototype.or=vt,i.prototype.xor=gt,i.prototype.andNot=bt,i.prototype.not=wt,i.prototype.shiftLeft=Et,i.prototype.shiftRight=St,i.prototype.getLowestSetBit=Tt,i.prototype.bitCount=Ct,i.prototype.testBit=kt,i.prototype.setBit=At,i.prototype.clearBit=Ot,i.prototype.flipBit=Mt,i.prototype.add=Dt,i.prototype.subtract=Pt,i.prototype.multiply=Ht,i.prototype.divide=Bt,i.prototype.remainder=jt,i.prototype.divideAndRemainder=Ft,i.prototype.modPow=en,i.prototype.modInverse=rn,i.prototype.pow=Xt,i.prototype.gcd=tn,i.prototype.isProbablePrime=un,e.jsbn=e.jsbn||{},e.jsbn.BigInteger=i}var r="jsbn";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/jsbn",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(t,n,r){r||(r=e.md.sha1.create());var i="",s=Math.ceil(n/r.digestLength);for(var o=0;o<s;++o){var u=String.fromCharCode(o>>24&255,o>>16&255,o>>8&255,o&255);r.start(),r.update(t+u),i+=r.digest().getBytes()}return i.substring(0,n)}var t=e.pkcs1=e.pkcs1||{};t.encode_rsa_oaep=function(t,r,i){var s,o,u,a;typeof i=="string"?(s=i,o=arguments[3]||undefined,u=arguments[4]||undefined):i&&(s=i.label||undefined,o=i.seed||undefined,u=i.md||undefined,i.mgf1&&i.mgf1.md&&(a=i.mgf1.md)),u?u.start():u=e.md.sha1.create(),a||(a=u);var f=Math.ceil(t.n.bitLength()/8),l=f-2*u.digestLength-2;if(r.length>l){var c=new Error("RSAES-OAEP input message length is too long.");throw c.length=r.length,c.maxLength=l,c}s||(s=""),u.update(s,"raw");var h=u.digest(),p="",d=l-r.length;for(var v=0;v<d;v++)p+="\0";var m=h.getBytes()+p+""+r;if(!o)o=e.random.getBytes(u.digestLength);else if(o.length!==u.digestLength){var c=new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");throw c.seedLength=o.length,c.digestLength=u.digestLength,c}var g=n(o,f-u.digestLength-1,a),y=e.util.xorBytes(m,g,m.length),b=n(y,u.digestLength,a),w=e.util.xorBytes(o,b,o.length);return"\0"+w+y},t.decode_rsa_oaep=function(t,r,i){var s,o,u;typeof i=="string"?(s=i,o=arguments[3]||undefined):i&&(s=i.label||undefined,o=i.md||undefined,i.mgf1&&i.mgf1.md&&(u=i.mgf1.md));var a=Math.ceil(t.n.bitLength()/8);if(r.length!==a){var f=new Error("RSAES-OAEP encoded message length is invalid.");throw f.length=r.length,f.expectedLength=a,f}o===undefined?o=e.md.sha1.create():o.start(),u||(u=o);if(a<2*o.digestLength+2)throw new Error("RSAES-OAEP key is too short for the hash function.");s||(s=""),o.update(s,"raw");var l=o.digest().getBytes(),c=r.charAt(0),h=r.substring(1,o.digestLength+1),p=r.substring(1+o.digestLength),d=n(p,o.digestLength,u),v=e.util.xorBytes(h,d,h.length),m=n(v,a-o.digestLength-1,u),g=e.util.xorBytes(p,m,p.length),y=g.substring(0,o.digestLength),f=c!=="\0";for(var b=0;b<o.digestLength;++b)f|=l.charAt(b)!==y.charAt(b);var w=1,E=o.digestLength;for(var S=o.digestLength;S<g.length;S++){var x=g.charCodeAt(S),T=x&1^1,N=w?65534:0;f|=x&N,w&=T,E+=w}if(f||g.charCodeAt(E)!==1)throw new Error("Invalid RSAES-OAEP padding.");return g.substring(E+1)}}var r="pkcs1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs1",["require","module","./util","./random","./sha1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function o(e,t,n,r){return"workers"in n?a(e,t,n,r):u(e,t,n,r)}function u(t,n,i,s){var o=f(t,n),a=0,c=l(o.bitLength());"millerRabinTests"in i&&(c=i.millerRabinTests);var h=10;"maxBlockTime"in i&&(h=i.maxBlockTime);var p=+(new Date);do{o.bitLength()>t&&(o=f(t,n));if(o.isProbablePrime(c))return s(null,o);o.dAddOffset(r[a++%8],0)}while(h<0||+(new Date)-p<h);e.util.setImmediate(function(){u(t,n,i,s)})}function a(t,r,i,s){function p(){function d(i){if(p)return;--u;var a=i.data;if(a.found){for(var h=0;h<e.length;++h)e[h].terminate();return p=!0,s(null,new n(a.prime,16))}o.bitLength()>t&&(o=f(t,r));var d=o.toString(16);i.target.postMessage({hex:d,workLoad:l}),o.dAddOffset(c,0)}a=Math.max(1,a);var e=[];for(var i=0;i<a;++i)e[i]=new Worker(h);var u=a;for(var i=0;i<a;++i)e[i].addEventListener("message",d);var p=!1}if(typeof Worker=="undefined")return u(t,r,i,s);var o=f(t,r),a=i.workers,l=i.workLoad||100,c=l*30/8,h=i.workerScript||"forge/prime.worker.js";if(a===-1)return e.util.estimateCores(function(e,t){e&&(t=2),a=t-1,p()});p()}function f(e,t){var r=new n(e,t),o=e-1;return r.testBit(o)||r.bitwiseTo(n.ONE.shiftLeft(o),s,r),r.dAddOffset(31-r.mod(i).byteValue(),0),r}function l(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}if(e.prime)return;var t=e.prime=e.prime||{},n=e.jsbn.BigInteger,r=[6,4,2,4,2,4,6,2],i=new n(null);i.fromInt(30);var s=function(e,t){return e|t};t.generateProbablePrime=function(t,n,r){typeof n=="function"&&(r=n,n={}),n=n||{};var i=n.algorithm||"PRIMEINC";typeof i=="string"&&(i={name:i}),i.options=i.options||{};var s=n.prng||e.random,u={nextBytes:function(e){var t=s.getBytesSync(e.length);for(var n=0;n<e.length;++n)e[n]=t.charCodeAt(n)}};if(i.name==="PRIMEINC")return o(t,u,i.options,r);throw new Error("Invalid prime generation algorithm: "+i.name)}}var r="prime";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/prime",["require","module","./util","./jsbn","./random"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function c(t,n,r){var i=e.util.createBuffer(),s=Math.ceil(n.n.bitLength()/8);if(t.length>s-11){var o=new Error("Message is too long for PKCS#1 v1.5 padding.");throw o.length=t.length,o.max=s-11,o}i.putByte(0),i.putByte(r);var u=s-3-t.length,a;if(r===0||r===1){a=r===0?0:255;for(var f=0;f<u;++f)i.putByte(a)}else while(u>0){var l=0,c=e.random.getBytes(u);for(var f=0;f<u;++f)a=c.charCodeAt(f),a===0?++l:i.putByte(a);u=l}return i.putByte(0),i.putBytes(t),i}function h(t,n,r,i){var s=Math.ceil(n.n.bitLength()/8),o=e.util.createBuffer(t),u=o.getByte(),a=o.getByte();if(u!==0||r&&a!==0&&a!==1||!r&&a!=2||r&&a===0&&typeof i=="undefined")throw new Error("Encryption block is invalid.");var f=0;if(a===0){f=s-3-i;for(var l=0;l<f;++l)if(o.getByte()!==0)throw new Error("Encryption block is invalid.")}else if(a===1){f=0;while(o.length()>1){if(o.getByte()!==255){--o.read;break}++f}}else if(a===2){f=0;while(o.length()>1){if(o.getByte()===0){--o.read;break}++f}}var c=o.getByte();if(c!==0||f!==s-3-o.length())throw new Error("Encryption block is invalid.");return o.getBytes()}function p(n,i,s){function u(){a(n.pBits,function(e,t){if(e)return s(e);n.p=t;if(n.q!==null)return f(e,n.q);a(n.qBits,f)})}function a(t,n){e.prime.generateProbablePrime(t,o,n)}function f(e,i){if(e)return s(e);n.q=i;if(n.p.compareTo(n.q)<0){var o=n.p;n.p=n.q,n.q=o}if(n.p.subtract(t.ONE).gcd(n.e).compareTo(t.ONE)!==0){n.p=null,u();return}if(n.q.subtract(t.ONE).gcd(n.e).compareTo(t.ONE)!==0){n.q=null,a(n.qBits,f);return}n.p1=n.p.subtract(t.ONE),n.q1=n.q.subtract(t.ONE),n.phi=n.p1.multiply(n.q1);if(n.phi.gcd(n.e).compareTo(t.ONE)!==0){n.p=n.q=null,u();return}n.n=n.p.multiply(n.q);if(n.n.bitLength()!==n.bits){n.q=null,a(n.qBits,f);return}var l=n.e.modInverse(n.phi);n.keys={privateKey:r.rsa.setPrivateKey(n.n,n.e,l,n.p,n.q,l.mod(n.p1),l.mod(n.q1),n.q.modInverse(n.p)),publicKey:r.rsa.setPublicKey(n.n,n.e)},s(null,n.keys)}typeof i=="function"&&(s=i,i={}),i=i||{};var o={algorithm:{name:i.algorithm||"PRIMEINC",options:{workers:i.workers||2,workLoad:i.workLoad||100,workerScript:i.workerScript}}};"prng"in i&&(o.prng=i.prng),u()}function d(t){var n=t.toString(16);return n[0]>="8"&&(n="00"+n),e.util.hexToBytes(n)}function v(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1;e.pki=e.pki||{},e.pki.rsa=e.rsa=e.rsa||{};var r=e.pki,i=[6,4,2,4,2,4,6,2],s={name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},o={name:"RSAPrivateKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},u={name:"RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},a=e.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},f=function(e){var t;if(e.algorithm in r.oids){t=r.oids[e.algorithm];var s=n.oidToDer(t).getBytes(),o=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),u=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);u.value.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,s)),u.value.push(n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,""));var a=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.digest().getBytes());return o.value.push(u),o.value.push(a),n.toDer(o).getBytes()}var i=new Error("Unknown message digest algorithm.");throw i.algorithm=e.algorithm,i},l=function(n,r,i){if(i)return n.modPow(r.e,r.n);if(!r.p||!r.q)return n.modPow(r.d,r.n);r.dP||(r.dP=r.d.mod(r.p.subtract(t.ONE))),r.dQ||(r.dQ=r.d.mod(r.q.subtract(t.ONE))),r.qInv||(r.qInv=r.q.modInverse(r.p));var s;do s=(new t(e.util.bytesToHex(e.random.getBytes(r.n.bitLength()/8)),16)).mod(r.n);while(s.equals(t.ZERO));n=n.multiply(s.modPow(r.e,r.n)).mod(r.n);var o=n.mod(r.p).modPow(r.dP,r.p),u=n.mod(r.q).modPow(r.dQ,r.q);while(o.compareTo(u)<0)o=o.add(r.p);var a=o.subtract(u).multiply(r.qInv).mod(r.p).multiply(r.q).add(u);return a=a.multiply(s.modInverse(r.n)).mod(r.n),a};r.rsa.encrypt=function(n,r,i){var s=i,o,u=Math.ceil(r.n.bitLength()/8);i!==!1&&i!==!0?(s=i===2,o=c(n,r,i)):(o=e.util.createBuffer(),o.putBytes(n));var a=new t(o.toHex(),16),f=l(a,r,s),h=f.toString(16),p=e.util.createBuffer(),d=u-Math.ceil(h.length/2);while(d>0)p.putByte(0),--d;return p.putBytes(e.util.hexToBytes(h)),p.getBytes()},r.rsa.decrypt=function(n,r,i,s){var o=Math.ceil(r.n.bitLength()/8);if(n.length!==o){var u=new Error("Encrypted message length is invalid.");throw u.length=n.length,u.expected=o,u}var a=new t(e.util.createBuffer(n).toHex(),16);if(a.compareTo(r.n)>=0)throw new Error("Encrypted message is invalid.");var f=l(a,r,i),c=f.toString(16),p=e.util.createBuffer(),d=o-Math.ceil(c.length/2);while(d>0)p.putByte(0),--d;return p.putBytes(e.util.hexToBytes(c)),s!==!1?h(p.getBytes(),r,i):p.getBytes()},r.rsa.createKeyPairGenerationState=function(n,r,i){typeof n=="string"&&(n=parseInt(n,10)),n=n||2048,i=i||{};var s=i.prng||e.random,o={nextBytes:function(e){var t=s.getBytesSync(e.length);for(var n=0;n<e.length;++n)e[n]=t.charCodeAt(n)}},u=i.algorithm||"PRIMEINC",a;if(u!=="PRIMEINC")throw new Error("Invalid key generation algorithm: "+u);return a={algorithm:u,state:0,bits:n,rng:o,eInt:r||65537,e:new t(null),p:null,q:null,qBits:n>>1,pBits:n-(n>>1),pqState:0,num:null,keys:null},a.e.fromInt(a.eInt),a},r.rsa.stepKeyPairGenerationState=function(e,n){"algorithm"in e||(e.algorithm="PRIMEINC");var s=new t(null);s.fromInt(30);var o=0,u=function(e,t){return e|t},a=+(new Date),f,l=0;while(e.keys===null&&(n<=0||l<n)){if(e.state===0){var c=e.p===null?e.pBits:e.qBits,h=c-1;e.pqState===0?(e.num=new t(c,e.rng),e.num.testBit(h)||e.num.bitwiseTo(t.ONE.shiftLeft(h),u,e.num),e.num.dAddOffset(31-e.num.mod(s).byteValue(),0),o=0,++e.pqState):e.pqState===1?e.num.bitLength()>c?e.pqState=0:e.num.isProbablePrime(v(e.num.bitLength()))?++e.pqState:e.num.dAddOffset(i[o++%8],0):e.pqState===2?e.pqState=e.num.subtract(t.ONE).gcd(e.e).compareTo(t.ONE)===0?3:0:e.pqState===3&&(e.pqState=0,e.p===null?e.p=e.num:e.q=e.num,e.p!==null&&e.q!==null&&++e.state,e.num=null)}else if(e.state===1)e.p.compareTo(e.q)<0&&(e.num=e.p,e.p=e.q,e.q=e.num),++e.state;else if(e.state===2)e.p1=e.p.subtract(t.ONE),e.q1=e.q.subtract(t.ONE),e.phi=e.p1.multiply(e.q1),++e.state;else if(e.state===3)e.phi.gcd(e.e).compareTo(t.ONE)===0?++e.state:(e.p=null,e.q=null,e.state=0);else if(e.state===4)e.n=e.p.multiply(e.q),e.n.bitLength()===e.bits?++e.state:(e.q=null,e.state=0);else if(e.state===5){var p=e.e.modInverse(e.phi);e.keys={privateKey:r.rsa.setPrivateKey(e.n,e.e,p,e.p,e.q,p.mod(e.p1),p.mod(e.q1),e.q.modInverse(e.p)),publicKey:r.rsa.setPublicKey(e.n,e.e)}}f=+(new Date),l+=f-a,a=f}return e.keys!==null},r.rsa.generateKeyPair=function(e,t,n,i){arguments.length===1?typeof e=="object"?(n=e,e=undefined):typeof e=="function"&&(i=e,e=undefined):arguments.length===2?typeof e=="number"?typeof t=="function"?(i=t,t=undefined):typeof t!="number"&&(n=t,t=undefined):(n=e,i=t,e=undefined,t=undefined):arguments.length===3&&(typeof t=="number"?typeof n=="function"&&(i=n,n=undefined):(i=n,n=t,t=undefined)),n=n||{},e===undefined&&(e=n.bits||2048),t===undefined&&(t=n.e||65537);var s=r.rsa.createKeyPairGenerationState(e,t,n);if(!i)return r.rsa.stepKeyPairGenerationState(s,0),s.keys;p(s,n,i)},r.setRsaPublicKey=


    r.rsa.setPublicKey=function(t,i){var s={n:t,e:i};return s.encrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");if(n==="RSAES-PKCS1-V1_5")n={encode:function(e,t,n){return c(e,t,2).getBytes()}};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={encode:function(t,n){return e.pkcs1.encode_rsa_oaep(n,t,i)}};else if(["RAW","NONE","NULL",null].indexOf(n)!==-1)n={encode:function(e){return e}};else if(typeof n=="string")throw new Error('Unsupported encryption scheme: "'+n+'".');var o=n.encode(t,s,!0);return r.rsa.encrypt(o,s,!0)},s.verify=function(e,t,i){typeof i=="string"?i=i.toUpperCase():i===undefined&&(i="RSASSA-PKCS1-V1_5");if(i==="RSASSA-PKCS1-V1_5")i={verify:function(e,t){t=h(t,s,!0);var r=n.fromDer(t);return e===r.value[1].value}};else if(i==="NONE"||i==="NULL"||i===null)i={verify:function(e,t){return t=h(t,s,!0),e===t}};var o=r.rsa.decrypt(t,s,!0,!1);return i.verify(e,o,s.n.bitLength())},s},r.setRsaPrivateKey=r.rsa.setPrivateKey=function(t,n,i,s,o,u,a,l){var c={n:t,e:n,d:i,p:s,q:o,dP:u,dQ:a,qInv:l};return c.decrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");var s=r.rsa.decrypt(t,c,!1,!1);if(n==="RSAES-PKCS1-V1_5")n={decode:h};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={decode:function(t,n){return e.pkcs1.decode_rsa_oaep(n,t,i)}};else{if(["RAW","NONE","NULL",null].indexOf(n)===-1)throw new Error('Unsupported encryption scheme: "'+n+'".');n={decode:function(e){return e}}}return n.decode(s,c,!1)},c.sign=function(e,t){var n=!1;typeof t=="string"&&(t=t.toUpperCase());if(t===undefined||t==="RSASSA-PKCS1-V1_5")t={encode:f},n=1;else if(t==="NONE"||t==="NULL"||t===null)t={encode:function(){return e}},n=1;var i=t.encode(e,c.n.bitLength());return r.rsa.encrypt(i,c,n)},c},r.wrapRsaPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,n.toDer(e).getBytes())])},r.privateKeyFromAsn1=function(i){var u={},a=[];n.validate(i,s,u,a)&&(i=n.fromDer(e.util.createBuffer(u.privateKey))),u={},a=[];if(!n.validate(i,o,u,a)){var f=new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");throw f.errors=a,f}var l,c,h,p,d,v,m,g;return l=e.util.createBuffer(u.privateKeyModulus).toHex(),c=e.util.createBuffer(u.privateKeyPublicExponent).toHex(),h=e.util.createBuffer(u.privateKeyPrivateExponent).toHex(),p=e.util.createBuffer(u.privateKeyPrime1).toHex(),d=e.util.createBuffer(u.privateKeyPrime2).toHex(),v=e.util.createBuffer(u.privateKeyExponent1).toHex(),m=e.util.createBuffer(u.privateKeyExponent2).toHex(),g=e.util.createBuffer(u.privateKeyCoefficient).toHex(),r.setRsaPrivateKey(new t(l,16),new t(c,16),new t(h,16),new t(p,16),new t(d,16),new t(v,16),new t(m,16),new t(g,16))},r.privateKeyToAsn1=r.privateKeyToRSAPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.d)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.p)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.q)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dP)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dQ)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.qInv))])},r.publicKeyFromAsn1=function(i){var s={},o=[];if(n.validate(i,a,s,o)){var f=n.derToOid(s.publicKeyOid);if(f!==r.oids.rsaEncryption){var l=new Error("Cannot read public key. Unknown OID.");throw l.oid=f,l}i=s.rsaPublicKey}o=[];if(!n.validate(i,u,s,o)){var l=new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");throw l.errors=o,l}var c=e.util.createBuffer(s.publicKeyModulus).toHex(),h=e.util.createBuffer(s.publicKeyExponent).toHex();return r.setRsaPublicKey(new t(c,16),new t(h,16))},r.publicKeyToAsn1=r.publicKeyToSubjectPublicKeyInfo=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,[r.publicKeyToRSAPublicKey(e)])])},r.publicKeyToRSAPublicKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e))])}}var r="rsa";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rsa",["require","module","./asn1","./jsbn","./oids","./pkcs1","./prime","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function a(e,t){return e.start().update(t).digest().getBytes()}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1,r=e.pki=e.pki||{};r.pbe=e.pbe=e.pbe||{};var i=r.oids,s={name:"EncryptedPrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},o={name:"PBES2Algorithms",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,onstructed:!0,capture:"kdfIterationCount"}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},u={name:"pkcs-12PbeParams",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"iterations"}]};r.encryptPrivateKeyInfo=function(t,s,o){o=o||{},o.saltSize=o.saltSize||8,o.count=o.count||2048,o.algorithm=o.algorithm||"aes128";var u=e.random.getBytesSync(o.saltSize),a=o.count,f=n.integerToDer(a),l,c,h;if(o.algorithm.indexOf("aes")===0||o.algorithm==="des"){var p,d,v;switch(o.algorithm){case"aes128":l=16,p=16,d=i["aes128-CBC"],v=e.aes.createEncryptionCipher;break;case"aes192":l=24,p=16,d=i["aes192-CBC"],v=e.aes.createEncryptionCipher;break;case"aes256":l=32,p=16,d=i["aes256-CBC"],v=e.aes.createEncryptionCipher;break;case"des":l=8,p=8,d=i.desCBC,v=e.des.createEncryptionCipher;break;default:var m=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw m.algorithm=o.algorithm,m}var g=e.pkcs5.pbkdf2(s,u,a,l),y=e.random.getBytesSync(p),b=v(g);b.start(y),b.update(n.toDer(t)),b.finish(),h=b.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBES2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBKDF2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])]),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(d).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,y)])])])}else{if(o.algorithm!=="3des"){var m=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw m.algorithm=o.algorithm,m}l=24;var w=new e.util.ByteBuffer(u),g=r.pbe.generatePkcs12Key(s,w,1,a,l),y=r.pbe.generatePkcs12Key(s,w,2,a,l),b=e.des.createEncryptionCipher(g);b.start(y),b.update(n.toDer(t)),b.finish(),h=b.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])])}var E=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[c,n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,h)]);return E},r.decryptPrivateKeyInfo=function(t,i){var o=null,u={},a=[];if(!n.validate(t,s,u,a)){var f=new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw f.errors=a,f}var l=n.derToOid(u.encryptionOid),c=r.pbe.getCipher(l,u.encryptionParams,i),h=e.util.createBuffer(u.encryptedData);return c.update(h),c.finish()&&(o=n.fromDer(c.output)),o},r.encryptedPrivateKeyToPem=function(t,r){var i={type:"ENCRYPTED PRIVATE KEY",body:n.toDer(t).getBytes()};return e.pem.encode(i,{maxline:r})},r.encryptedPrivateKeyFromPem=function(t){var r=e.pem.decode(t)[0];if(r.type!=="ENCRYPTED PRIVATE KEY"){var i=new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');throw i.headerType=r.type,i}if(r.procType&&r.procType.type==="ENCRYPTED")throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");return n.fromDer(r.body)},r.encryptRsaPrivateKey=function(t,i,s){s=s||{};if(!s.legacy){var o=r.wrapRsaPrivateKey(r.privateKeyToAsn1(t));return o=r.encryptPrivateKeyInfo(o,i,s),r.encryptedPrivateKeyToPem(o)}var u,a,f,l;switch(s.algorithm){case"aes128":u="AES-128-CBC",f=16,a=e.random.getBytesSync(16),l=e.aes.createEncryptionCipher;break;case"aes192":u="AES-192-CBC",f=24,a=e.random.getBytesSync(16),l=e.aes.createEncryptionCipher;break;case"aes256":u="AES-256-CBC",f=32,a=e.random.getBytesSync(16),l=e.aes.createEncryptionCipher;break;case"3des":u="DES-EDE3-CBC",f=24,a=e.random.getBytesSync(8),l=e.des.createEncryptionCipher;break;case"des":u="DES-CBC",f=8,a=e.random.getBytesSync(8),l=e.des.createEncryptionCipher;break;default:var c=new Error('Could not encrypt RSA private key; unsupported encryption algorithm "'+s.algorithm+'".');throw c.algorithm=s.algorithm,c}var h=e.pbe.opensslDeriveBytes(i,a.substr(0,8),f),p=l(h);p.start(a),p.update(n.toDer(r.privateKeyToAsn1(t))),p.finish();var d={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:u,parameters:e.util.bytesToHex(a).toUpperCase()},body:p.output.getBytes()};return e.pem.encode(d)},r.decryptRsaPrivateKey=function(t,i){var s=null,o=e.pem.decode(t)[0];if(o.type!=="ENCRYPTED PRIVATE KEY"&&o.type!=="PRIVATE KEY"&&o.type!=="RSA PRIVATE KEY"){var u=new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');throw u.headerType=u,u}if(o.procType&&o.procType.type==="ENCRYPTED"){var a,f;switch(o.dekInfo.algorithm){case"DES-CBC":a=8,f=e.des.createDecryptionCipher;break;case"DES-EDE3-CBC":a=24,f=e.des.createDecryptionCipher;break;case"AES-128-CBC":a=16,f=e.aes.createDecryptionCipher;break;case"AES-192-CBC":a=24,f=e.aes.createDecryptionCipher;break;case"AES-256-CBC":a=32,f=e.aes.createDecryptionCipher;break;case"RC2-40-CBC":a=5,f=function(t){return e.rc2.createDecryptionCipher(t,40)};break;case"RC2-64-CBC":a=8,f=function(t){return e.rc2.createDecryptionCipher(t,64)};break;case"RC2-128-CBC":a=16,f=function(t){return e.rc2.createDecryptionCipher(t,128)};break;default:var u=new Error('Could not decrypt private key; unsupported encryption algorithm "'+o.dekInfo.algorithm+'".');throw u.algorithm=o.dekInfo.algorithm,u}var l=e.util.hexToBytes(o.dekInfo.parameters),c=e.pbe.opensslDeriveBytes(i,l.substr(0,8),a),h=f(c);h.start(l),h.update(e.util.createBuffer(o.body));if(!h.finish())return s;s=h.output.getBytes()}else s=o.body;return o.type==="ENCRYPTED PRIVATE KEY"?s=r.decryptPrivateKeyInfo(n.fromDer(s),i):s=n.fromDer(s),s!==null&&(s=r.privateKeyFromAsn1(s)),s},r.pbe.generatePkcs12Key=function(t,n,r,i,s,o){var u,a;if(typeof o=="undefined"||o===null)o=e.md.sha1.create();var f=o.digestLength,l=o.blockLength,c=new e.util.ByteBuffer,h=new e.util.ByteBuffer;if(t!==null&&t!==undefined){for(a=0;a<t.length;a++)h.putInt16(t.charCodeAt(a));h.putInt16(0)}var p=h.length(),d=n.length(),v=new e.util.ByteBuffer;v.fillWithByte(r,l);var m=l*Math.ceil(d/l),g=new e.util.ByteBuffer;for(a=0;a<m;a++)g.putByte(n.at(a%d));var y=l*Math.ceil(p/l),b=new e.util.ByteBuffer;for(a=0;a<y;a++)b.putByte(h.at(a%p));var w=g;w.putBuffer(b);var E=Math.ceil(s/f);for(var S=1;S<=E;S++){var x=new e.util.ByteBuffer;x.putBytes(v.bytes()),x.putBytes(w.bytes());for(var T=0;T<i;T++)o.start(),o.update(x.getBytes()),x=o.digest();var N=new e.util.ByteBuffer;for(a=0;a<l;a++)N.putByte(x.at(a%f));var C=Math.ceil(d/l)+Math.ceil(p/l),k=new e.util.ByteBuffer;for(u=0;u<C;u++){var L=new e.util.ByteBuffer(w.getBytes(l)),A=511;for(a=N.length()-1;a>=0;a--)A>>=8,A+=N.at(a)+L.at(a),L.setAt(a,A&255);k.putBuffer(L)}w=k,c.putBuffer(x)}return c.truncate(c.length()-s),c},r.pbe.getCipher=function(e,t,n){switch(e){case r.oids.pkcs5PBES2:return r.pbe.getCipherForPBES2(e,t,n);case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case r.oids["pbewithSHAAnd40BitRC2-CBC"]:return r.pbe.getCipherForPKCS12PBE(e,t,n);default:var i=new Error("Cannot read encrypted PBE data block. Unsupported OID.");throw i.oid=e,i.supportedOids=["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"],i}},r.pbe.getCipherForPBES2=function(t,i,s){var u={},a=[];if(!n.validate(i,o,u,a)){var f=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw f.errors=a,f}t=n.derToOid(u.kdfOid);if(t!==r.oids.pkcs5PBKDF2){var f=new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");throw f.oid=t,f.supportedOids=["pkcs5PBKDF2"],f}t=n.derToOid(u.encOid);if(t!==r.oids["aes128-CBC"]&&t!==r.oids["aes192-CBC"]&&t!==r.oids["aes256-CBC"]&&t!==r.oids["des-EDE3-CBC"]&&t!==r.oids.desCBC){var f=new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");throw f.oid=t,f.supportedOids=["aes128-CBC","aes192-CBC","aes256-CBC","des-EDE3-CBC","desCBC"],f}var l=u.kdfSalt,c=e.util.createBuffer(u.kdfIterationCount);c=c.getInt(c.length()<<3);var h,p;switch(r.oids[t]){case"aes128-CBC":h=16,p=e.aes.createDecryptionCipher;break;case"aes192-CBC":h=24,p=e.aes.createDecryptionCipher;break;case"aes256-CBC":h=32,p=e.aes.createDecryptionCipher;break;case"des-EDE3-CBC":h=24,p=e.des.createDecryptionCipher;break;case"desCBC":h=8,p=e.des.createDecryptionCipher}var d=e.pkcs5.pbkdf2(s,l,c,h),v=u.encIv,m=p(d);return m.start(v),m},r.pbe.getCipherForPKCS12PBE=function(t,i,s){var o={},a=[];if(!n.validate(i,u,o,a)){var f=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw f.errors=a,f}var l=e.util.createBuffer(o.salt),c=e.util.createBuffer(o.iterations);c=c.getInt(c.length()<<3);var h,p,d;switch(t){case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:h=24,p=8,d=e.des.startDecrypting;break;case r.oids["pbewithSHAAnd40BitRC2-CBC"]:h=5,p=8,d=function(t,n){var r=e.rc2.createDecryptionCipher(t,40);return r.start(n,null),r};break;default:var f=new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");throw f.oid=t,f}var v=r.pbe.generatePkcs12Key(s,l,1,c,h),m=r.pbe.generatePkcs12Key(s,l,2,c,p);return d(v,m)},r.pbe.opensslDeriveBytes=function(t,n,r,i){if(typeof i=="undefined"||i===null)i=e.md.md5.create();n===null&&(n="");var s=[a(i,t+n)];for(var o=16,u=1;o<r;++u,o+=16)s.push(a(i,s[u-1]+t+n));return s.join("").substr(0,r)}}var r="pbe";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbe",["require","module","./aes","./asn1","./des","./md","./oids","./pem","./pbkdf2","./random","./rc2","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pkcs7asn1=e.pkcs7asn1||{};e.pkcs7=e.pkcs7||{},e.pkcs7.asn1=n;var r={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.ContentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,captureAsn1:"content"}]};n.contentInfoValidator=r;var i={name:"EncryptedContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,captureAsn1:"encParameter"}]},{name:"EncryptedContentInfo.encryptedContent",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,capture:"encryptedContent",captureAsn1:"encryptedContentAsn1"}]};n.envelopedDataValidator={name:"EnvelopedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EnvelopedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"EnvelopedData.RecipientInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"recipientInfos"}].concat(i)},n.encryptedDataValidator={name:"EncryptedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"}].concat(i)};var s={name:"SignerInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1},{name:"SignerInfo.issuerAndSerialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.issuerAndSerialNumber.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"SignerInfo.issuerAndSerialNumber.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"SignerInfo.digestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.digestAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"digestAlgorithm"},{name:"SignerInfo.digestAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,constructed:!1,captureAsn1:"digestParameter",optional:!0}]},{name:"SignerInfo.authenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"authenticatedAttributes"},{name:"SignerInfo.digestEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,capture:"signatureAlgorithm"},{name:"SignerInfo.encryptedDigest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"signature"},{name:"SignerInfo.unauthenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,capture:"unauthenticatedAttributes"}]};n.signedDataValidator={name:"SignedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"SignedData.DigestAlgorithms",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"digestAlgorithms"},r,{name:"SignedData.Certificates",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,optional:!0,captureAsn1:"certificates"},{name:"SignedData.CertificateRevocationLists",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,optional:!0,captureAsn1:"crls"},{name:"SignedData.SignerInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,capture:"signerInfos",optional:!0,value:[s]}]},n.recipientInfoValidator={name:"RecipientInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"RecipientInfo.issuerAndSerial",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.issuerAndSerial.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"RecipientInfo.issuerAndSerial.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"RecipientInfo.keyEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.keyEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"RecipientInfo.keyEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,constructed:!1,captureAsn1:"encParameter"}]},{name:"RecipientInfo.encryptedKey",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"encKey"}]}}var r="pkcs7asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7asn1",["require","module","./asn1","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{};var t=e.mgf.mgf1=e.mgf1=e.mgf1||{};t.create=function(t){var n={generate:function(n,r){var i=new e.util.ByteBuffer,s=Math.ceil(r/t.digestLength);for(var o=0;o<s;o++){var u=new e.util.ByteBuffer;u.putInt32(o),t.start(),t.update(n+u.getBytes()),i.putBuffer(t.digest())}return i.truncate(i.length()-r),i.getBytes()}};return n}}var r="mgf1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{},e.mgf.mgf1=e.mgf1}var r="mgf";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf",["require","module","./mgf1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.pss=e.pss||{};t.create=function(t){arguments.length===3&&(t={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]});var n=t.md,r=t.mgf,i=n.digestLength,s=t.salt||null;typeof s=="string"&&(s=e.util.createBuffer(s));var o;if("saltLength"in t)o=t.saltLength;else{if(s===null)throw new Error("Salt length not specified or specific salt not given.");o=s.length()}if(s!==null&&s.length()!==o)throw new Error("Given salt length does not match length of given salt.");var u=t.prng||e.random,a={};return a.encode=function(t,a){var f,l=a-1,c=Math.ceil(l/8),h=t.digest().getBytes();if(c<i+o+2)throw new Error("Message is too long to encrypt.");var p;s===null?p=u.getBytesSync(o):p=s.bytes();var d=new e.util.ByteBuffer;d.fillWithByte(0,8),d.putBytes(h),d.putBytes(p),n.start(),n.update(d.getBytes());var v=n.digest().getBytes(),m=new e.util.ByteBuffer;m.fillWithByte(0,c-o-i-2),m.putByte(1),m.putBytes(p);var g=m.getBytes(),y=c-i-1,b=r.generate(v,y),w="";for(f=0;f<y;f++)w+=String.fromCharCode(g.charCodeAt(f)^b.charCodeAt(f));var E=65280>>8*c-l&255;return w=String.fromCharCode(w.charCodeAt(0)&~E)+w.substr(1),w+v+String.fromCharCode(188)},a.verify=function(t,s,u){var a,f=u-1,l=Math.ceil(f/8);s=s.substr(-l);if(l<i+o+2)throw new Error("Inconsistent parameters to PSS signature verification.");if(s.charCodeAt(l-1)!==188)throw new Error("Encoded message does not end in 0xBC.");var c=l-i-1,h=s.substr(0,c),p=s.substr(c,i),d=65280>>8*l-f&255;if((h.charCodeAt(0)&d)!==0)throw new Error("Bits beyond keysize not zero as expected.");var v=r.generate(p,c),m="";for(a=0;a<c;a++)m+=String.fromCharCode(h.charCodeAt(a)^v.charCodeAt(a));m=String.fromCharCode(m.charCodeAt(0)&~d)+m.substr(1);var g=l-i-o-2;for(a=0;a<g;a++)if(m.charCodeAt(a)!==0)throw new Error("Leftmost octets not zero as expected");if(m.charCodeAt(g)!==1)throw new Error("Inconsistent PSS signature, 0x01 marker not found");var y=m.substr(-o),b=new e.util.ByteBuffer;b.fillWithByte(0,8),b.putBytes(t),b.putBytes(y),n.start(),n.update(b.getBytes());var w=n.digest().getBytes();return p===w},a}}var r="pss";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pss",["require","module","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function l(e,t){typeof t=="string"&&(t={shortName:t});var n=null,r;for(var i=0;n===null&&i<e.attributes.length;++i)r=e.attributes[i],t.type&&t.type===r.type?n=r:t.name&&t.name===r.name?n=r:t.shortName&&t.shortName===r.shortName&&(n=r);return n}function h(n){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),i,s,o=n.attributes;for(var u=0;u<o.length;++u){i=o[u];var a=i.value,f=t.Type.PRINTABLESTRING;"valueTagClass"in i&&(f=i.valueTagClass,f===t.Type.UTF8&&(a=e.util.encodeUtf8(a))),s=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(i.type).getBytes()),t.create(t.Class.UNIVERSAL,f,!1,a)])]),r.value.push(s)}return r}function p(n){var r={};for(var i=0;i<n.length;++i){var s=n[i];if(s.shortName&&(s.valueTagClass===t.Type.UTF8||s.valueTagClass===t.Type.PRINTABLESTRING||s.valueTagClass===t.Type.IA5STRING)){var o=s.value;s.valueTagClass===t.Type.UTF8&&(o=e.util.encodeUtf8(s.value)),s.shortName in r?e.util.isArray(r[s.shortName])?r[s.shortName].push(o):r[s.shortName]=[r[s.shortName],o]:r[s.shortName]=o}}return r}function d(e){var s;for(var o=0;o<e.length;++o){s=e[o],typeof s.name=="undefined"&&(s.type&&s.type in n.oids?s.name=n.oids[s.type]:s.shortName&&s.shortName in i&&(s.name=n.oids[i[s.shortName]]));if(typeof s.type=="undefined"){if(!(s.name&&s.name in n.oids)){var u=new Error("Attribute type not specified.");throw u.attribute=s,u}s.type=n.oids[s.name]}typeof s.shortName=="undefined"&&s.name&&s.name in i&&(s.shortName=i[s.name]);if(s.type===r.extensionRequest){s.valueConstructed=!0,s.valueTagClass=t.Type.SEQUENCE;if(!s.value&&s.extensions){s.value=[];for(var a=0;a<s.extensions.length;++a)s.value.push(n.certificateExtensionToAsn1(v(s.extensions[a])))}}if(typeof s.value=="undefined"){var u=new Error("Attribute value not specified.");throw u.attribute=s,u}}}function v(i,s){s=s||{},typeof i.name=="undefined"&&i.id&&i.id in n.oids&&(i.name=n.oids[i.id]);if(typeof i.id=="undefined"){if(!(i.name&&i.name in n.oids)){var o=new Error("Extension ID not specified.");throw o.extension=i,o}i.id=n.oids[i.name]}if(typeof i.value!="undefined")return i;if(i.name==="keyUsage"){var u=0,a=0,f=0;i.digitalSignature&&(a|=128,u=7),i.nonRepudiation&&(a|=64,u=6),i.keyEncipherment&&(a|=32,u=5),i.dataEncipherment&&(a|=16,u=4),i.keyAgreement&&(a|=8,u=3),i.keyCertSign&&(a|=4,u=2),i.cRLSign&&(a|=2,u=1),i.encipherOnly&&(a|=1,u=0),i.decipherOnly&&(f|=128,u=7);var l=String.fromCharCode(u);f!==0?l+=String.fromCharCode(a)+String.fromCharCode(f):a!==0&&(l+=String.fromCharCode(a)),i.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,l)}else if(i.name==="basicConstraints")i.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),i.cA&&i.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255))),"pathLenConstraint"in i&&i.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(i.pathLenConstraint).getBytes()));else if(i.name==="extKeyUsage"){i.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var c=i.value.value;for(var h in i){if(i[h]!==!0)continue;h in r?c.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r[h]).getBytes())):h.indexOf(".")!==-1&&c.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(h).getBytes()))}}else if(i.name==="nsCertType"){var u=0,a=0;i.client&&(a|=128,u=7),i.server&&(a|=64,u=6),i.email&&(a|=32,u=5),i.objsign&&(a|=16,u=4),i.reserved&&(a|=8,u=3),i.sslCA&&(a|=4,u=2),i.emailCA&&(a|=2,u=1),i.objCA&&(a|=1,u=0);var l=String.fromCharCode(u);a!==0&&(l+=String.fromCharCode(a)),i.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,l)}else if(i.name==="subjectAltName"||i.name==="issuerAltName"){i.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var p;for(var d=0;d<i.altNames.length;++d){p=i.altNames[d];var l=p.value;if(p.type===7&&p.ip){l=e.util.bytesFromIP(p.ip);if(l===null){var o=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');throw o.extension=i,o}}else p.type===8&&(p.oid?l=t.oidToDer(t.oidToDer(p.oid)):l=t.oidToDer(l));i.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC,p.type,!1,l))}}else if(i.name==="subjectKeyIdentifier"&&s.cert){var v=s.cert.generateSubjectKeyIdentifier();i.subjectKeyIdentifier=v.toHex(),i.value=t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,v.getBytes())}if(typeof i.value=="undefined"){var o=new Error("Extension value not specified.");throw o.extension=i,o}return i}function m(e,n){switch(e){case r["RSASSA-PSS"]:var i=[];return n.hash.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])),n.mgf.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])])),n.saltLength!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.saltLength).getBytes())])),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,i);default:return t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")}}function g(n){var r=t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[]);if(n.attributes.length===0)return r;var i=n.attributes;for(var s=0;s<i.length;++s){var o=i[s],u=o.value,a=t.Type.UTF8;"valueTagClass"in o&&(a=o.valueTagClass),a===t.Type.UTF8&&(u=e.util.encodeUtf8(u));var f=!1;"valueConstructed"in o&&(f=o.valueConstructed);var l=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(o.type).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,a,f,u)])]);r.value.push(l)}return r}var t=e.asn1,n=e.pki=e.pki||{},r=n.oids,i={};i.CN=r.commonName,i.commonName="CN",i.C=r.countryName,i.countryName="C",i.L=r.localityName,i.localityName="L",i.ST=r.stateOrProvinceName,i.stateOrProvinceName="ST",i.O=r.organizationName,i.organizationName="O",i.OU=r.organizationalUnitName,i.organizationalUnitName="OU",i.E=r.emailAddress,i.emailAddress="E";var s=e.pki.rsa.publicKeyValidator,o={name:"Certificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"tbsCertificate",value:[{name:"Certificate.TBSCertificate.version",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.version.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certVersion"}]},{name:"Certificate.TBSCertificate.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certSerialNumber"},{name:"Certificate.TBSCertificate.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.signature.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certinfoSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certinfoSignatureParams"}]},{name:"Certificate.TBSCertificate.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certIssuer"},{name:"Certificate.TBSCertificate.validity",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.validity.notBefore (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity1UTCTime"},{name:"Certificate.TBSCertificate.validity.notBefore (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity2GeneralizedTime"},{name:"Certificate.TBSCertificate.validity.notAfter (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity3UTCTime"},{name:"Certificate.TBSCertificate.validity.notAfter (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity4GeneralizedTime"}]},{name:"Certificate.TBSCertificate.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certSubject"},s,{name:"Certificate.TBSCertificate.issuerUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.issuerUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certIssuerUniqueId"}]},{name:"Certificate.TBSCertificate.subjectUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.subjectUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSubjectUniqueId"}]},{name:"Certificate.TBSCertificate.extensions",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,constructed:!0,captureAsn1:"certExtensions",optional:!0}]},{name:"Certificate.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certSignatureParams"}]},{name:"Certificate.signatureValue",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSignature"}]},u={name:"rsapss",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.hashAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"hashOid"}]}]},{name:"rsapss.maskGenAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenOid"},{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenHashOid"}]}]}]},{name:"rsapss.saltLength",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,optional:!0,value:[{name:"rsapss.saltLength.saltLength",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"saltLength"}]},{name:"rsapss.trailerField",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,optional:!0,value:[{name:"rsapss.trailer.trailer",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"trailer"}]}]},a={name:"CertificationRequestInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfo",value:[{name:"CertificationRequestInfo.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certificationRequestInfoVersion"},{name:"CertificationRequestInfo.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfoSubject"},s,{name:"CertificationRequestInfo.attributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"certificationRequestInfoAttributes",value:[{name:"CertificationRequestInfo.attributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequestInfo.attributes.type",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1},{name:"CertificationRequestInfo.attributes.value",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0}]}]}]},f={name:"CertificationRequest",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"csr",value:[a,{name:"CertificationRequest.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequest.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"csrSignatureOid"},{name:"CertificationRequest.signatureAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"csrSignatureParams"}]},{name:"CertificationRequest.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"csrSignature"}]};n.RDNAttributesAsArray=function(e,n){var s=[],o,u,a;for(var f=0;f<e.value.length;++f){o=e.value[f];for(var l=0;l<o.value.length;++l)a={},u=o.value[l],a.type=t.derToOid(u.value[0].value),a.value=u.value[1].value,a.valueTagClass=u.value[1].type,a.type in r&&(a.name=r[a.type],a.name in i&&(a.shortName=i[a.name])),n&&(n.update(a.type),n.update(a.value)),s.push(a)}return s},n.CRIAttributesAsArray=function(e){var s=[];for(var o=0;o<e.length;++o){var u=e[o],a=t.derToOid(u.value[0].value),f=u.value[1].value;for(var l=0;l<f.length;++l){var c={};c.type=a,c.value=f[l].value,c.valueTagClass=f[l].type,c.type in r&&(c.name=r[c.type],c.name in i&&(c.shortName=i[c.name]));if(c.type===r.extensionRequest){c.extensions=[];for(var h=0;h<c.value.length;++h)c.extensions.push(n.certificateExtensionFromAsn1(c.value[h]))}s.push(c)}}return s};var c=function(e,n,i){var s={};if(e!==r["RSASSA-PSS"])return s;i&&(s={hash:{algorithmOid:r.sha1},mgf:{algorithmOid:r.mgf1,hash:{algorithmOid:r.sha1}},saltLength:20});var o={},a=[];if(!t.validate(n,u,o,a)){var f=new Error("Cannot read RSASSA-PSS parameter block.");throw f.errors=a,f}return o.hashOid!==undefined&&(s.hash=s.hash||{},s.hash.algorithmOid=t.derToOid(o.hashOid)),o.maskGenOid!==undefined&&(s.mgf=s.mgf||{},s.mgf.algorithmOid=t.derToOid(o.maskGenOid),s.mgf.hash=s.mgf.hash||{},s.mgf.hash.algorithmOid=t.derToOid(o.maskGenHashOid)),o.saltLength!==undefined&&(s.saltLength=o.saltLength.charCodeAt(0)),s};n.certificateFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE"&&o.type!=="X509 CERTIFICATE"&&o.type!=="TRUSTED CERTIFICATE"){var u=new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');throw u.headerType=o.type,u}if(o.procType&&o.procType.type==="ENCRYPTED")throw new Error("Could not convert certificate from PEM; PEM is encrypted.");var a=t.fromDer(o.body,s);return n.certificateFromAsn1(a,i)},n.certificateToPem=function(r,i){var s={type:"CERTIFICATE",body:t.toDer(n.certificateToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PUBLIC KEY"&&i.type!=="RSA PUBLIC KEY"){var s=new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');throw s.headerType=i.type,s}if(i.procType&&i.procType.type==="ENCRYPTED")throw new Error("Could not convert public key from PEM; PEM is encrypted.");var o=t.fromDer(i.body);return n.publicKeyFromAsn1(o)},n.publicKeyToPem=function(r,i){var s={type:"PUBLIC KEY",body:t.toDer(n.publicKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyToRSAPublicKeyPem=function(r,i){var s={type:"RSA PUBLIC KEY",body:t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.getPublicKeyFingerprint=function(r,i){i=i||{};var s=i.md||e.md.sha1.create(),o=i.type||"RSAPublicKey",u;switch(o){case"RSAPublicKey":u=t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes();break;case"SubjectPublicKeyInfo":u=t.toDer(n.publicKeyToAsn1(r)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+i.type+'".')}s.start(),s.update(u);var a=s.digest();if(i.encoding==="hex"){var f=a.toHex();return i.delimiter?f.match(/.{2}/g).join(i.delimiter):f}if(i.encoding==="binary")return a.getBytes();if(i.encoding)throw new Error('Unknown encoding "'+i.encoding+'".');return a},n.certificationRequestFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE REQUEST"){var u=new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');throw u.headerType=o.type,u}if(o.procType&&o.procType.type==="ENCRYPTED")throw new Error("Could not convert certification request from PEM; PEM is encrypted.");var a=t.fromDer(o.body,s);return n.certificationRequestFromAsn1(a,i)},n.certificationRequestToPem=function(r,i){var s={type:"CERTIFICATE REQUEST",body:t.toDer(n.certificationRequestToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.createCertificate=function(){var i={};return i.version=2,i.serialNumber="00",i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.validity={},i.validity.notBefore=new Date,i.validity.notAfter=new Date,i.issuer={},i.issuer.getField=function(e){return l(i.issuer,e)},i.issuer.addField=function(e){d([e]),i.issuer.attributes.push(e)},i.issuer.attributes=[],i.issuer.hash=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){d([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.extensions=[],i.publicKey=null,i.md=null,i.setSubject=function(e,t){d(e),i.subject.attributes=e,delete i.subject.uniqueId,t&&(i.subject.uniqueId=t),i.subject.hash=null},i.setIssuer=function(e,t){d(e),i.issuer.attributes=e,delete i.issuer.uniqueId,t&&(i.issuer.uniqueId=t),i.issuer.hash=null},i.setExtensions=function(e){for(var t=0;t<e.length;++t)v(e[t],{cert:i});i.extensions=e},i.getExtension=function(e){typeof e=="string"&&(e={name:e});var t=null,n;for(var r=0;t===null&&r<i.extensions.length;++r)n=i.extensions[r],e.id&&n.id===e.id?t=n:e.name&&n.name===e.name&&(t=n);return t},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u){var a=new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");throw a.algorithm=i.md.algorithm,a}i.signatureOid=i.siginfo.algorithmOid=u,i.tbsCertificate=n.getTBSCertificate(i);var f=t.toDer(i.tbsCertificate);i.md.update(f.getBytes()),i.signature=s.sign(i.md)},i.verify=function(s){var o=!1;if(!i.issued(s)){var u=s.issuer,a=i.subject,f=new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");throw f.expectedIssuer=u.attributes,f.actualIssuer=a.attributes,f}var l=s.md;if(l===null){if(s.signatureOid in r){var c=r[s.signatureOid];switch(c){case"sha1WithRSAEncryption":l=e.md.sha1.create();break;case"md5WithRSAEncryption":l=e.md.md5.create();break;case"sha256WithRSAEncryption":l=e.md.sha256.create();break;case"RSASSA-PSS":l=e.md.sha256.create()}}if(l===null){var f=new Error("Could not compute certificate digest. Unknown signature OID.");throw f.signatureOid=s.signatureOid,f}var h=s.tbsCertificate||n.getTBSCertificate(s),p=t.toDer(h);l.update(p.getBytes())}if(l!==null){var d;switch(s.signatureOid){case r.sha1WithRSAEncryption:d=undefined;break;case r["RSASSA-PSS"]:var v,m;v=r[s.signatureParameters.mgf.hash.algorithmOid];if(v===undefined||e.md[v]===undefined){var f=new Error("Unsupported MGF hash function.");throw f.oid=s.signatureParameters.mgf.hash.algorithmOid,f.name=v,f}m=r[s.signatureParameters.mgf.algorithmOid];if(m===undefined||e.mgf[m]===undefined){var f=new Error("Unsupported MGF function.");throw f.oid=s.signatureParameters.mgf.algorithmOid,f.name=m,f}m=e.mgf[m].create(e.md[v].create()),v=r[s.signatureParameters.hash.algorithmOid];if(v===undefined||e.md[v]===undefined)throw{message:"Unsupported RSASSA-PSS hash function.",oid:s.signatureParameters.hash.algorithmOid,name:v};d=e.pss.create(e.md[v].create(),m,s.signatureParameters.saltLength)}o=i.publicKey.verify(l.digest().getBytes(),s.signature,d)}return o},i.isIssuer=function(e){var t=!1,n=i.issuer,r=e.subject;if(n.hash&&r.hash)t=n.hash===r.hash;else if(n.attributes.length===r.attributes.length){t=!0;var s,o;for(var u=0;t&&u<n.attributes.length;++u){s=n.attributes[u],o=r.attributes[u];if(s.type!==o.type||s.value!==o.value)t=!1}}return t},i.issued=function(e){return e.isIssuer(i)},i.generateSubjectKeyIdentifier=function(){return n.getPublicKeyFingerprint(i.publicKey,{type:"RSAPublicKey"})},i.verifySubjectKeyIdentifier=function(){var t=r.subjectKeyIdentifier;for(var n=0;n<i.extensions.length;++n){var s=i.extensions[n];if(s.id===t){var o=i.generateSubjectKeyIdentifier().getBytes();return e.util.hexToBytes(s.subjectKeyIdentifier)===o}}return!1},i},n.certificateFromAsn1=function(i,s){var u={},a=[];if(!t.validate(i,o,u,a)){var f=new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");throw f.errors=a,f}if(typeof u.certSignature!="string"){var h="\0";for(var p=0;p<u.certSignature.length;++p)h+=t.toDer(u.certSignature[p]).getBytes();u.certSignature=h}var v=t.derToOid(u.publicKeyOid);if(v!==n.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var m=n.createCertificate();m.version=u.certVersion?u.certVersion.charCodeAt(0):0;var g=e.util.createBuffer(u.certSerialNumber);m.serialNumber=g.toHex(),m.signatureOid=e.asn1.derToOid(u.certSignatureOid),m.signatureParameters=c(m.signatureOid,u.certSignatureParams,!0),m.siginfo.algorithmOid=e.asn1.derToOid(u.certinfoSignatureOid),m.siginfo.parameters=c(m.siginfo.algorithmOid,u.certinfoSignatureParams,!1);var y=e.util.createBuffer(u.certSignature);++y.read,m.signature=y.getBytes();var b=[];u.certValidity1UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity1UTCTime)),u.certValidity2GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)),u.certValidity3UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity3UTCTime)),u.certValidity4GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime));if(b.length>2)throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");if(b.length<2)throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");m.validity.notBefore=b[0],m.validity.notAfter=b[1],m.tbsCertificate=u.tbsCertificate;if(s){m.md=null;if(m.signatureOid in r){var v=r[m.signatureOid];switch(v){case"sha1WithRSAEncryption":m.md=e.md.sha1.create();break;case"md5WithRSAEncryption":m.md=e.md.md5.create();break;case"sha256WithRSAEncryption":m.md=e.md.sha256.create();break;case"RSASSA-PSS":m.md=e.md.sha256.create()}}if(m.md===null){var f=new Error("Could not compute certificate digest. Unknown signature OID.");throw f.signatureOid=m.signatureOid,f}var w=t.toDer(m.tbsCertificate);m.md.update(w.getBytes())}var E=e.md.sha1.create();m.issuer.getField=function(e){return l(m.issuer,e)},m.issuer.addField=function(e){d([e]),m.issuer.attributes.push(e)},m.issuer.attributes=n.RDNAttributesAsArray(u.certIssuer,E),u.certIssuerUniqueId&&(m.issuer.uniqueId=u.certIssuerUniqueId),m.issuer.hash=E.digest().toHex();var S=e.md.sha1.create();return m.subject.getField=function(e){return l(m.subject,e)},m.subject.addField=function(e){d([e]),m.subject.attributes.push(e)},m.subject.attributes=n.RDNAttributesAsArray(u.certSubject,S),u.certSubjectUniqueId&&(m.subject.uniqueId=u.certSubjectUniqueId),m.subject.hash=S.digest().toHex(),u.certExtensions?m.extensions=n.certificateExtensionsFromAsn1(u.certExtensions):m.extensions=[],m.publicKey=n.publicKeyFromAsn1(u.subjectPublicKeyInfo),m},n.certificateExtensionsFromAsn1=function(e){var t=[];for(var r=0;r<e.value.length;++r){var i=e.value[r];for(var s=0;s<i.value.length;++s)t.push(n.certificateExtensionFromAsn1(i.value[s]))}return t},n.certificateExtensionFromAsn1=function(n){var i={};i.id=t.derToOid(n.value[0].value),i.critical=!1,n.value[1].type===t.Type.BOOLEAN?(i.critical=n.value[1].value.charCodeAt(0)!==0,i.value=n.value[2].value):i.value=n.value[1].value;if(i.id in r){i.name=r[i.id];if(i.name==="keyUsage"){var s=t.fromDer(i.value),o=0,u=0;s.value.length>1&&(o=s.value.charCodeAt(1),u=s.value.length>2?s.value.charCodeAt(2):0),i.digitalSignature=(o&128)===128,i.nonRepudiation=(o&64)===64,i.keyEncipherment=(o&32)===32,i.dataEncipherment=(o&16)===16,i.keyAgreement=(o&8)===8,i.keyCertSign=(o&4)===4,i.cRLSign=(o&2)===2,i.encipherOnly=(o&1)===1,i.decipherOnly=(u&128)===128}else if(i.name==="basicConstraints"){var s=t.fromDer(i.value);s.value.length>0&&s.value[0].type===t.Type.BOOLEAN?i.cA=s.value[0].value.charCodeAt(0)!==0:i.cA=!1;var a=null;s.value.length>0&&s.value[0].type===t.Type.INTEGER?a=s.value[0].value:s.value.length>1&&(a=s.value[1].value),a!==null&&(i.pathLenConstraint=t.derToInteger(a))}else if(i.name==="extKeyUsage"){var s=t.fromDer(i.value);for(var f=0;f<s.value.length;++f){var l=t.derToOid(s.value[f].value);l in r?i[r[l]]=!0:i[l]=!0}}else if(i.name==="nsCertType"){var s=t.fromDer(i.value),o=0;s.value.length>1&&(o=s.value.charCodeAt(1)),i.client=(o&128)===128,i.server=(o&64)===64,i.email=(o&32)===32,i.objsign=(o&16)===16,i.reserved=(o&8)===8,i.sslCA=(o&4)===4,i.emailCA=(o&2)===2,i.objCA=(o&1)===1}else if(i.name==="subjectAltName"||i.name==="issuerAltName"){i.altNames=[];var c,s=t.fromDer(i.value);for(var h=0;h<s.value.length;++h){c=s.value[h];var p={type:c.type,value:c.value};i.altNames.push(p);switch(c.type){case 1:case 2:case 6:break;case 7:p.ip=e.util.bytesToIP(c.value);break;case 8:p.oid=t.derToOid(c.value);break;default:}}}else if(i.name==="subjectKeyIdentifier"){var s=t.fromDer(i.value);i.subjectKeyIdentifier=e.util.bytesToHex(s.value)}}return i},n.certificationRequestFromAsn1=function(i,s){var o={},u=[];if(!t.validate(i,f,o,u)){var a=new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");throw a.errors=u,a}if(typeof o.csrSignature!="string"){var h="\0";for(var p=0;p<o.csrSignature.length;++p)h+=t.toDer(o.csrSignature[p]).getBytes();o.csrSignature=h}var v=t.derToOid(o.publicKeyOid);if(v!==n.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var m=n.createCertificationRequest();m.version=o.csrVersion?o.csrVersion.charCodeAt(0):0,m.signatureOid=e.asn1.derToOid(o.csrSignatureOid),m.signatureParameters=c(m.signatureOid,o.csrSignatureParams,!0),m.siginfo.algorithmOid=e.asn1.derToOid(o.csrSignatureOid),m.siginfo.parameters=c(m.siginfo.algorithmOid,o.csrSignatureParams,!1);var g=e.util.createBuffer(o.csrSignature);++g.read,m.signature=g.getBytes(),m.certificationRequestInfo=o.certificationRequestInfo;if(s){m.md=null;if(m.signatureOid in r){var v=r[m.signatureOid];switch(v){case"sha1WithRSAEncryption":m.md=e.md.sha1.create();break;case"md5WithRSAEncryption":m.md=e.md.md5.create();break;case"sha256WithRSAEncryption":m.md=e.md.sha256.create();break;case"RSASSA-PSS":m.md=e.md.sha256.create()}}if(m.md===null){var a=new Error("Could not compute certification request digest. Unknown signature OID.");throw a.signatureOid=m.signatureOid,a}var y=t.toDer(m.certificationRequestInfo);m.md.update(y.getBytes())}var b=e.md.sha1.create();return m.subject.getField=function(e){return l(m.subject,e)},m.subject.addField=function(e){d([e]),m.subject.attributes.push(e)},m.subject.attributes=n.RDNAttributesAsArray(o.certificationRequestInfoSubject,b),m.subject.hash=b.digest().toHex(),m.publicKey=n.publicKeyFromAsn1(o.subjectPublicKeyInfo),m.getAttribute=function(e){return l(m,e)},m.addAttribute=function(e){d([e]),m.attributes.push(e)},m.attributes=n.CRIAttributesAsArray(o.certificationRequestInfoAttributes||[]),m},n.createCertificationRequest=function(){var i={};return i.version=0,i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){d([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.publicKey=null,i.attributes=[],i.getAttribute=function(e){return l(i,e)},i.addAttribute=function(e){d([e]),i.attributes.push(e)},i.md=null,i.setSubject=function(e){d(e),i.subject.attributes=e,i.subject.hash=null},i.setAttributes=function(e){d(e),i.attributes=e},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u){var a=new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");throw a.algorithm=i.md.algorithm,a}i.signatureOid=i.siginfo.algorithmOid=u,i.certificationRequestInfo=n.getCertificationRequestInfo(i);var f=t.toDer(i.certificationRequestInfo);i.md.update(f.getBytes()),i.signature=s.sign(i.md)},i.verify=function(){var s=!1,o=i.md;if(o===null){if(i.signatureOid in r){var u=r[i.signatureOid];switch(u){case"sha1WithRSAEncryption":o=e.md.sha1.create();break;case"md5WithRSAEncryption":o=e.md.md5.create();break;case"sha256WithRSAEncryption":o=e.md.sha256.create();break;case"RSASSA-PSS":o=e.md.sha256.create()}}if(o===null){var a=new Error("Could not compute certification request digest. Unknown signature OID.");throw a.signatureOid=i.signatureOid,a}var f=i.certificationRequestInfo||n.getCertificationRequestInfo(i),l=t.toDer(f);o.update(l.getBytes())}if(o!==null){var c;switch(i.signatureOid){case r.sha1WithRSAEncryption:break;case r["RSASSA-PSS"]:var h,p;h=r[i.signatureParameters.mgf.hash.algorithmOid];if(h===undefined||e.md[h]===undefined){var a=new Error("Unsupported MGF hash function.");throw a.oid=i.signatureParameters.mgf.hash.algorithmOid,a.name=h,a}p=r[i.signatureParameters.mgf.algorithmOid];if(p===undefined||e.mgf[p]===undefined){var a=new Error("Unsupported MGF function.");throw a.oid=i.signatureParameters.mgf.algorithmOid,a.name=p,a}p=e.mgf[p].create(e.md[h].create()),h=r[i.signatureParameters.hash.algorithmOid];if(h===undefined||e.md[h]===undefined){var a=new Error("Unsupported RSASSA-PSS hash function.");throw a.oid=i.signatureParameters.hash.algorithmOid,a.name=h,a}c=e.pss.create(e.md[h].create(),p,i.signatureParameters.saltLength)}s=i.publicKey.verify(o.digest().getBytes(),i.signature,c)}return s},i},n.getTBSCertificate=function(r){var i=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(r.serialNumber)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.siginfo.algorithmOid).getBytes()),m(r.siginfo.algorithmOid,r.siginfo.parameters)]),h(r.issuer),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notBefore)),t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notAfter))]),h(r.subject),n.publicKeyToAsn1(r.publicKey)]);return r.issuer.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.issuer.uniqueId)])),r.subject.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.subject.uniqueId)])),r.extensions.length>0&&i.value.push(n.certificateExtensionsToAsn1(r.extensions)),i},n.getCertificationRequestInfo=function(e){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(e.version).getBytes()),h(e.subject),n.publicKeyToAsn1(e.publicKey),g(e)]);return r},n.distinguishedNameToAsn1=function(e){return h(e)},n.certificateToAsn1=function(e){var r=e.tbsCertificate||n.getTBSCertificate(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),m(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.certificateExtensionsToAsn1=function(e){var r=t.create(t.Class.CONTEXT_SPECIFIC,3,!0,[]),i=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);r.value.push(i);for(var s=0;s<e.length;++s)i.value.push(n.certificateExtensionToAsn1(e[s]));return r},n.certificateExtensionToAsn1=function(e){var n=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);n.value.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.id).getBytes())),e.critical&&n.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255)));var r=e.value;return typeof e.value!="string"&&(r=t.toDer(r).getBytes()),n.value.push(t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,r)),n},n.certificationRequestToAsn1=function(e){var r=e.certificationRequestInfo||n.getCertificationRequestInfo(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),m(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.createCaStore=function(r){function s(t){if(!t.hash){var r=e.md.sha1.create();t.attributes=n.RDNAttributesAsArray(h(t),r),t.hash=r.digest().toHex()}return i.certs[t.hash]||null}var i={certs:{}};i.getIssuer=function(e){var t=s(e.issuer);return t},i.addCertificate=function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t));if(!t.subject.hash){var r=e.md.sha1.create();t.subject.attributes=n.RDNAttributesAsArray(h(t.subject),r),t.subject.hash=r.digest().toHex()}if(t.subject.hash in i.certs){var s=i.certs[t.subject.hash];e.util.isArray(s)||(s=[s]),s.push(t)}else i.certs[t.subject.hash]=t},i.hasCertificate=function(r){var i=s(r.subject);if(!i)return!1;e.util.isArray(i)||(i=[i]);var o=t.toDer(n.certificateToAsn1(r)).getBytes();for(var u=0;u<i.length;++u){var a=t.toDer(n.certificateToAsn1(i[u])).getBytes();if(o===a)return!0}return!1};if(r)for(var o=0;o<r.length;++o){var u=r[o];i.addCertificate(u)}return i},n.certificateError={bad_certificate:"forge.pki.BadCertificate",unsupported_certificate:"forge.pki.UnsupportedCertificate",certificate_revoked:"forge.pki.CertificateRevoked",certificate_expired:"forge.pki.CertificateExpired",certificate_unknown:"forge.pki.CertificateUnknown",unknown_ca:"forge.pki.UnknownCertificateAuthority"},n.verifyCertificateChain=function(t,r,i){r=r.slice(0);var s=r.slice(0),o=new Date,u=!0,a=null,f=0;do{var l=r.shift(),c=null,h=!1;if(o<l.validity.notBefore||o>l.validity.notAfter)a={message:"Certificate is not valid yet or has expired.",error:n.certificateError.certificate_expired,notBefore:l.validity.notBefore,notAfter:l.validity.notAfter,now:o};if(a===null){c=r[0]||t.getIssuer(l),c===null&&l.isIssuer(l)&&(h=!0,c=l);if(c){var p=c;e.util.isArray(p)||(p=[p]);var d=!1;while(!d&&p.length>0){c=p.shift();try{d=c.verify(l)}catch(v){}}d||(a={message:"Certificate signature is invalid.",error:n.certificateError.bad_certificate})}a===null&&(!c||h)&&!t.hasCertificate(l)&&(a={message:"Certificate is not trusted.",error:n.certificateError.unknown_ca})}a===null&&c&&!l.isIssuer(c)&&(a={message:"Certificate issuer is invalid.",error:n.certificateError.bad_certificate});if(a===null){var m={keyUsage:!0,basicConstraints:!0};for(var g=0;a===null&&g<l.extensions.length;++g){var y=l.extensions[g];y.critical&&!(y.name in m)&&(a={message:"Certificate has an unsupported critical extension.",error:n.certificateError.unsupported_certificate})}}if(a===null&&(!u||r.length===0&&(!c||h))){var b=l.getExtension("basicConstraints"),w=l.getExtension("keyUsage");w!==null&&(!w.keyCertSign||b===null)&&(a={message:"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",error:n.certificateError.bad_certificate}),a===null&&b!==null&&!b.cA&&(a={message:"Certificate basicConstraints indicates the certificate is not a CA.",error:n.certificateError.bad_certificate});if(a===null&&w!==null&&"pathLenConstraint"in b){var E=f-1;E>b.pathLenConstraint&&(a={message:"Certificate basicConstraints pathLenConstraint violated.",error:n.certificateError.bad_certificate})}}var S=a===null?!0:a.error,x=i?i(S,f,s):S;if(x!==!0){S===!0&&(a={message:"The application rejected the certificate.",error:n.certificateError.bad_certificate});if(x||x===0)typeof x=="object"&&!e.util.isArray(x)?(x.message&&(a.message=x.message),x.error&&(a.error=x.error)):typeof x=="string"&&(a.error=x);throw a}a=null,u=!1,++f}while(r.length>0);return!0}}var r="x509";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n.pki}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/x509",["require","module","./aes","./asn1","./des","./md","./mgf","./oids","./pem","./pss","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function f(e,t,n,r){var i=[];for(var s=0;s<e.length;s++)for(var o=0;o<e[s].safeBags.length;o++){var u=e[s].safeBags[o];if(r!==undefined&&u.type!==r)continue;if(t===null){i.push(u);continue}u.attributes[t]!==undefined&&u.attributes[t].indexOf(n)>=0&&i.push(u)}return i}function l(t){if(t.composed||t.constructed){var n=e.util.createBuffer();for(var r=0;r<t.value.length;++r)n.putBytes(t.value[r].value);t.composed=t.constructed=!1,t.value=n.getBytes()}return t}function c(e,r,s,o){r=t.fromDer(r,s);if(r.tagClass!==t.Class.UNIVERSAL||r.type!==t.Type.SEQUENCE||r.constructed!==!0)throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");for(var u=0;u<r.value.length;u++){var a=r.value[u],f={},c=[];if(!t.validate(a,i,f,c)){var d=new Error("Cannot read ContentInfo.");throw d.errors=c,d}var v={encrypted:!1},m=null,g=f.content.value[0];switch(t.derToOid(f.contentType)){case n.oids.data:if(g.tagClass!==t.Class.UNIVERSAL||g.type!==t.Type.OCTETSTRING)throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");m=l(g).value;break;case n.oids.encryptedData:m=h(g,o),v.encrypted=!0;break;default:var d=new Error("Unsupported PKCS#12 contentType.");throw d.contentType=t.derToOid(f.contentType),d}v.safeBags=p(m,s,o),e.safeContents.push(v)}}function h(r,i){var s={},o=[];if(!t.validate(r,e.pkcs7.asn1.encryptedDataValidator,s,o)){var u=new Error("Cannot read EncryptedContentInfo.");throw u.errors=o,u}var a=t.derToOid(s.contentType);if(a!==n.oids.data){var u=new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");throw u.oid=a,u}a=t.derToOid(s.encAlgorithm);var f=n.pbe.getCipher(a,s.encParameter,i),c=l(s.encryptedContentAsn1),h=e.util.createBuffer(c.value);f.update(h);if(!f.finish())throw new Error("Failed to decrypt PKCS#12 SafeContents.");return f.output.getBytes()}function p(e,r,i){if(!r&&e.length===0)return[];e=t.fromDer(e,r);if(e.tagClass!==t.Class.UNIVERSAL||e.type!==t.Type.SEQUENCE||e.constructed!==!0)throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");var s=[];for(var u=0;u<e.value.length;u++){var f=e.value[u],l={},c=[];if(!t.validate(f,o,l,c)){var h=new Error("Cannot read SafeBag.");throw h.errors=c,h}var p={type:t.derToOid(l.bagId),attributes:d(l.bagAttributes)};s.push(p);var v,m,g=l.bagValue.value[0];switch(p.type){case n.oids.pkcs8ShroudedKeyBag:g=n.decryptPrivateKeyInfo(g,i);if(g===null)throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");case n.oids.keyBag:try{p.key=n.privateKeyFromAsn1(g)}catch(y){p.key=null,p.asn1=g}continue;case n.oids.certBag:v=a,m=function(){if(t.derToOid(l.certId)!==n.oids.x509Certificate){var e=new Error("Unsupported certificate type, only X.509 supported.");throw e.oid=t.derToOid(l.certId),e}var i=t.fromDer(l.cert,r);try{p.cert=n.certificateFromAsn1(i,!0)}catch(s){p.cert=null,p.asn1=i}};break;default:var h=new Error("Unsupported PKCS#12 SafeBag type.");throw h.oid=p.type,h}if(v!==undefined&&!t.validate(g,v,l,c)){var h=new Error("Cannot read PKCS#12 "+v.name);throw h.errors=c,h}m()}return s}function d(e){var r={};if(e!==undefined)for(var i=0;i<e.length;++i){var s={},o=[];if(!t.validate(e[i],u,s,o)){var a=new Error("Cannot read PKCS#12 BagAttribute.");throw a.errors=o,a}var f=t.derToOid(s.oid);if(n.oids[f]===undefined)continue;r[n.oids[f]]=[];for(var l=0;l<s.values.length;++l)r[n.oids[f]].push(s.values[l].value)}return r}var t=e.asn1,n=e.pki,r=e.pkcs12=e.pkcs12||{},i={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"content"}]},s={name:"PFX",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},i,{name:"PFX.macData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"mac",value:[{name:"PFX.macData.mac",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"macAlgorithm"},{name:"PFX.macData.mac.digestAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,captureAsn1:"macAlgorithmParameters"}]},{name:"PFX.macData.mac.digest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macDigest"}]},{name:"PFX.macData.macSalt",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macSalt"},{name:"PFX.macData.iterations",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,optional:!0,capture:"macIterations"}]}]},o={name:"SafeBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SafeBag.bagId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"bagId"},{name:"SafeBag.bagValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"bagValue"},{name:"SafeBag.bagAttributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,optional:!0,capture:"bagAttributes"}]},u={name:"Attribute",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Attribute.attrId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"oid"},{name:"Attribute.attrValues",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,capture:"values"}]},a={name:"CertBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertBag.certId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certId"},{name:"CertBag.certValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,value:[{name:"CertBag.certValue[0]",tagClass:t.Class.UNIVERSAL,type:t.Class.OCTETSTRING,constructed:!1,capture:"cert"}]}]};r.pkcs12FromAsn1=function(i,o,u){typeof o=="string"?(u=o,o=!0):o===undefined&&(o=!0);var a={},h=[];if(!t.validate(i,s,a,h)){var p=new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");throw p.errors=p,p}var d={version:a.version.charCodeAt(0),safeContents:[],getBags:function(t){var n={},r;return"localKeyId"in t?r=t.localKeyId:"localKeyIdHex"in t&&(r=e.util.hexToBytes(t.localKeyIdHex)),r===undefined&&!("friendlyName"in t)&&"bagType"in t&&(n[t.bagType]=f(d.safeContents,null,null,t.bagType)),r!==undefined&&(n.localKeyId=f(d.safeContents,"localKeyId",r,t.bagType)),"friendlyName"in t&&(n.friendlyName=f(d.safeContents,"friendlyName",t.friendlyName,t.bagType)),n},getBagsByFriendlyName:function(e,t){return f(d.safeContents,"friendlyName",e,t)},getBagsByLocalKeyId:function(e,t){return f(d.safeContents,"localKeyId",e,t)}};if(a.version.charCodeAt(0)!==3){var p=new Error("PKCS#12 PFX of version other than 3 not supported.");throw p.version=a.version.charCodeAt(0),p}if(t.derToOid(a.contentType)!==n.oids.data){var p=new Error("Only PKCS#12 PFX in password integrity mode supported.");throw p.oid=t.derToOid(a.contentType),p}var v=a.content.value[0];if(v.tagClass!==t.Class.UNIVERSAL||v.type!==t.Type.OCTETSTRING)throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");v=l(v);if(a.mac){var m=null,g=0,y=t.derToOid(a.macAlgorithm);switch(y){case n.oids.sha1:m=e.md.sha1.create(),g=20;break;case n.oids.sha256:m=e.md.sha256.create(),g=32;break;case n.oids.sha384:m=e.md.sha384.create(),g=48;break;case n.oids.sha512:m=e.md.sha512.create(),g=64;break;case n.oids.md5:m=e.md.md5.create(),g=16}if(m===null)throw new Error("PKCS#12 uses unsupported MAC algorithm: "+y);var b=new e.util.ByteBuffer(a.macSalt),w="macIterations"in a?parseInt(e.util.bytesToHex(a.macIterations),16):1,E=r.generateKey(u,b,3,w,g,m),S=e.hmac.create();S.start(m,E),S.update(v.value);var x=S.getMac();if(x.getBytes()!==a.macDigest)throw new Error("PKCS#12 MAC could not be verified. Invalid password?")}return c(d,v.value,o,u),d},r.toPkcs12Asn1=function(i,s,o,u){u=u||{},u.saltSize=u.saltSize||8,u.count=u.count||2048,u.algorithm=u.algorithm||u.encAlgorithm||"aes128","useMac"in u||(u.useMac=!0),"localKeyId"in u||(u.localKeyId=null),"generateLocalKeyId"in u||(u.generateLocalKeyId=!0);var a=u.localKeyId,f;if(a!==null)a=e.util.hexToBytes(a);else if(u.generateLocalKeyId)if(s){var l=e.util.isArray(s)?s[0]:s;typeof l=="string"&&(l=n.certificateFromPem(l));var c=e.md.sha1.create();c.update(t.toDer(n.certificateToAsn1(l)).getBytes()),a=c.digest().getBytes()}else a=e.random.getBytes(20);var h=[];a!==null&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.localKeyId).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,a)])])),"friendlyName"in u&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.friendlyName).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.BMPSTRING,!1,u.friendlyName)])])),h.length>0&&(f=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,h));var p=[],d=[];s!==null&&(e.util.isArray(s)?d=s:d=[s]);var v=[];for(var m=0;m<d.length;++m){s=d[m],typeof s=="string"&&(s=n.certificateFromPem(s));var g=m===0?f:undefined,y=n.certificateToAsn1(s),b=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.certBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.x509Certificate).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(y).getBytes())])])]),g]);v.push(b)}if(v.length>0){var w=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,v),E=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(w).getBytes())])]);p.push(E)}var S=null;if(i!==null){var x=n.wrapRsaPrivateKey(n.privateKeyToAsn1(i));o===null?S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.keyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[x]),f]):S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.pkcs8ShroudedKeyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[n.encryptPrivateKeyInfo(x,o,u)]),f]);var T=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[S]),N=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(T).getBytes())])]);p.push(N)}var C=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,p),k;if(u.useMac){var c=e.md.sha1.create(),L=new e.util.ByteBuffer(e.random.getBytes(u.saltSize)),A=u.count,i=r.generateKey(o,L,3,A,20),O=e.hmac.create();O.start(c,i),O.update(t.toDer(C).getBytes());var M=O.getMac();k=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.sha1).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,M.getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,L.getBytes()),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(A).getBytes())])}return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(3).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(C).getBytes())])]),k])},r.generateKey=e.pbe.generatePkcs12Key}var r="pkcs12";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs12",["require","module","./asn1","./hmac","./oids","./pkcs7asn1","./pbe","./random","./rsa","./sha1","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pki=e.pki||{};n.pemToDer=function(t){var n=e.pem.decode(t)[0];if(n.procType&&n.procType.type==="ENCRYPTED")throw new Error("Could not convert PEM to DER; PEM is encrypted.");return e.util.createBuffer(n.body)},n.privateKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PRIVATE KEY"&&i.type!=="RSA PRIVATE KEY"){var s=new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');throw s.headerType=i.type,s}if(i.procType&&i.procType.type==="ENCRYPTED")throw new Error("Could not convert private key from PEM; PEM is encrypted.");var o=t.fromDer(i.body);return n.privateKeyFromAsn1(o)},n.privateKeyToPem=function(r,i){var s={type:"RSA PRIVATE KEY",body:t.toDer(n.privateKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.privateKeyInfoToPem=function(n,r){var i={type:"PRIVATE KEY",body:t.toDer(n).getBytes()};return e.pem.encode(i,{maxline:r})}}var r="pki";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pki",["require","module","./asn1","./oids","./pbe","./pem","./pbkdf2","./pkcs12","./pss","./rsa","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=function(t,n,r,i){var s=e.util.createBuffer(),o=t.length>>1,u=o+(t.length&1),a=t.substr(0,u),f=t.substr(o,u),l=e.util.createBuffer(),c=e.hmac.create();r=n+r;var h=Math.ceil(i/16),p=Math.ceil(i/20);c.start("MD5",a);var d=e.util.createBuffer();l.putBytes(r);for(var v=0;v<h;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),d.putBuffer(c.digest());c.start("SHA1",f);var m=e.util.createBuffer();l.clear(),l.putBytes(r);for(var v=0;v<p;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),m.putBuffer(c.digest());return s.putBytes(e.util.xorBytes(d.getBytes(),m.getBytes(),i)),s},n=function(e,t,n,r){},r=function(t,n,r){var i=e.hmac.create();i.start("SHA1",t);var s=e.util.createBuffer();return s.putInt32(n[0]),s.putInt32(n[1]),s.putByte(r.type),s.putByte(r.version.major),s.putByte(r.version.minor),s.putInt16(r.length),s.putBytes(r.fragment.bytes()),i.update(s.getBytes()),i.digest().getBytes()},i=function(t,n,r){var i=!1;try{var s=t.deflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},s=function(t,n,r){var i=!1;try{var s=t.inflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},o=function(t,n){var r=0;switch(n){case 1:r=t.getByte();break;case 2:r=t.getInt16();break;case 3:r=t.getInt24();break;case 4:r=t.getInt32()}return e.util.createBuffer(t.getBytes(r))},u=function(e,t,n){e.putInt(n.length(),t<<3),e.putBuffer(n)},a={};a.Versions={TLS_1_0:{major:3,minor:1},TLS_1_1:{major:3,minor:2},TLS_1_2:{major:3,minor:3}},a.SupportedVersions=[a.Versions.TLS_1_1,a.Versions.TLS_1_0],a.Version=a.SupportedVersions[0],a.MaxFragment=15360,a.ConnectionEnd={server:0,client:1},a.PRFAlgorithm={tls_prf_sha256:0},a.BulkCipherAlgorithm={none:null,rc4:0,des3:1,aes:2},a.CipherType={stream:0,block:1,aead:2},a.MACAlgorithm={none:null,hmac_md5:0,hmac_sha1:1,hmac_sha256:2,hmac_sha384:3,hmac_sha512:4},a.CompressionMethod={none:0,deflate:1},a.ContentType={change_cipher_spec:20,alert:21,handshake:22,application_data:23,heartbeat:24},a.HandshakeType={hello_request:0,client_hello:1,server_hello:2,certificate:11,server_key_exchange:12,certificate_request:13,server_hello_done:14,certificate_verify:15,client_key_exchange:16,finished:20},a.Alert={},a.Alert.Level={warning:1,fatal:2},a.Alert.Description={close_notify:0,unexpected_message:10,bad_record_mac:20,decryption_failed:21,record_overflow:22,decompression_failure:30,handshake_failure:40,bad_certificate:42,unsupported_certificate:43,certificate_revoked:44,certificate_expired:45,certificate_unknown:46,illegal_parameter:47,unknown_ca:48,access_denied:49,decode_error:50,decrypt_error:51,export_restriction:60,protocol_version:70,insufficient_security:71,internal_error:80,user_canceled:90,no_renegotiation:100},a.HeartbeatMessageType={heartbeat_request:1,heartbeat_response:2},a.CipherSuites={},a.getCipherSuite=function(e){var t=null;for(var n in a.CipherSuites){var r=a.CipherSuites[n];if(r.id[0]===e.charCodeAt(0)&&r.id[1]===e.charCodeAt(1)){t=r;break}}return t},a.handleUnexpected=function(e,t){var n=!e.open&&e.entity===a.ConnectionEnd.client;n||e.error(e,{message:"Unexpected message. Received TLS record out of order.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})},a.handleHelloRequest=function(e,t,n){!e.handshaking&&e.handshakes>0&&(a.queue(e,a.createAlert(e,{level:a.Alert.Level.warning,description:a.Alert.Description.no_renegotiation})),a.flush(e)),e.process()},a.parseHelloMessage=function(t,n,r){var i=null,s=t.entity===a.ConnectionEnd.client;if(r<38)t.error(t,{message:s?"Invalid ServerHello message. Message too short.":"Invalid ClientHello message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var u=n.fragment,f=u.length();i={version:{major:u.getByte(),minor:u.getByte()},random:e.util.createBuffer(u.getBytes(32)),session_id:o(u,1),extensions:[]},s?(i.cipher_suite=u.getBytes(2),i.compression_method=u.getByte()):(i.cipher_suites=o(u,2),i.compression_methods=o(u,1)),f=r-(f-u.length());if(f>0){var l=o(u,2);while(l.length()>0)i.extensions.push({type:[l.getByte(),l.getByte()],data:o(l,2)});if(!s)for(var c=0;c<i.extensions.length;++c){var h=i.extensions[c];if(h.type[0]===0&&h.type[1]===0){var p=o(h.data,2);while(p.length()>0){var d=p.getByte();if(d!==0)break;t.session.extensions.server_name.serverNameList.push(o(p,2).getBytes())}}}}if(t.session.version)if(i.version.major!==t.session.version.major||i.version.minor!==t.session.version.minor)return t.error(t,{message:"TLS version change is disallowed during renegotiation.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}});if(s)t.session.cipherSuite=a.getCipherSuite(i.cipher_suite);else{var v=e.util.createBuffer(i.cipher_suites.bytes());while(v.length()>0){t.session.cipherSuite=a.getCipherSuite(v.getBytes(2));if(t.session.cipherSuite!==null)break}}if(t.session.cipherSuite===null)return t.error(t,{message:"No cipher suites in common.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure},cipherSuite:e.util.bytesToHex(i.cipher_suite)});s?t.session.compressionMethod=i.compression_method:t.session.compressionMethod=a.CompressionMethod.none}return i},a.createSecurityParameters=function(e,t){var n=e.entity===a.ConnectionEnd.client,r=t.random.bytes(),i=n?e.session.sp.client_random:r,s=n?r:a.createRandom().getBytes();e.session.sp={entity:e.entity,prf_algorithm:a.PRFAlgorithm.tls_prf_sha256,bulk_cipher_algorithm:null,cipher_type:null,enc_key_length:null,block_length:null,fixed_iv_length:null,record_iv_length:null,mac_algorithm:null,mac_length:null,mac_key_length:null,compression_algorithm:e.session.compressionMethod,pre_master_secret:null,master_secret:null,client_random:i,server_random:s}},a.handleServerHello=function(e,t,n){var r=a.parseHelloMessage(e,t,n);if(e.fail)return;if(!(r.version.minor<=e.version.minor))return e.error(e,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}});e.version.minor=r.version.minor,e.session.version=e.version;var i=r.session_id.bytes();i.length>0&&i===e.session.id?(e.expect=d,e.session.resuming=!0,e.session.sp.server_random=r.random.bytes()):(e.expect=l,e.session.resuming=!1,a.createSecurityParameters(e,r)),e.session.id=i,e.process()},a.handleClientHello=function(t,n,r){var i=a.parseHelloMessage(t,n,r);if(t.fail)return;var s=i.session_id.bytes(),o=null;if(t.sessionCache){o=t.sessionCache.getSession(s);if(o===null)s="";else if(o.version.major!==i.version.major||o.version.minor>i.version.minor)o=null,s=""}s.length===0&&(s=e.random.getBytes(32)),t.session.id=s,t.session.clientHelloVersion=i.version,t.session.sp={};if(o)t.version=t.session.version=o.version,t.session.sp=o.sp;else{var u;for(var f=1;f<a.SupportedVersions.length;++f){u=a.SupportedVersions[f];if(u.minor<=i.version.minor)break}t.version={major:u.major,minor:u.minor},t.session.version=t.version}o!==null?(t.expect=S,t.session.resuming=!0,t.session.sp.client_random=i.random.bytes()):(t.expect=t.verifyClient!==!1?b:w,t.session.resuming=!1,a.createSecurityParameters(t,i)),t.open=!0,a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createServerHello(t)})),t.session.resuming?(a.queue(t,a.createRecord(t,{type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),t.state.pending=a.createConnectionState(t),t.state.current.write=t.state.pending.write,a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createFinished(t)}))):(a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createCertificate(t)})),t.fail||(a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createServerKeyExchange(t)})),t.verifyClient!==!1&&a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createCertificateRequest(t)})),a.queue(t,a.createRecord(t,{type:a.ContentType.handshake,data:a.createServerHelloDone(t)})))),a.flush(t),t.process()},a.handleCertificate=function(t,n,r){if(r<3)return t.error(t,{message:"Invalid Certificate message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});var i=n.fragment,s={certificate_list:o(i,3)},u,f,l=[];try{while(s.certificate_list.length()>0)u=o(s.certificate_list,3),f=e.asn1.fromDer(u),u=e.pki.certificateFromAsn1(f,!0),l.push(u)}catch(h){return t.error(t,{message:"Could not parse certificate list.",cause:h,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}var p=t.entity===a.ConnectionEnd.client;!p&&t.verifyClient!==!0||l.length!==0?l.length===0?t.expect=p?c:w:(p?t.session.serverCertificate=l[0]:t.session.clientCertificate=l[0],a.verifyCertificateChain(t,l)&&(t.expect=p?c:w)):t.error(t,{message:p?"No server certificate provided.":"No client certificate provided.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}}),t.process()},a.handleServerKeyExchange=function(e,t,n){if(n>0)return e.error(e,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}});e.expect=h,e.process()},a.handleClientKeyExchange=function(t,n,r){if(r<48)return t.error(t,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}});var i=n.fragment,s={enc_pre_master_secret:o(i,2).getBytes()},u=null;if(t.getPrivateKey)try{u=t.getPrivateKey(t,t.session.serverCertificate),u=e.pki.privateKeyFromPem(u)}catch(f){t.error(t,{message:"Could not get private key.",cause:f,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}if(u===null)return t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}});try{var l=t.session.sp;l.pre_master_secret=u.decrypt(s.enc_pre_master_secret);var c=t.session.clientHelloVersion;if(c.major!==l.pre_master_secret.charCodeAt(0)||c.minor!==l.pre_master_secret.charCodeAt(1))throw new Error("TLS version rollback attack detected.")}catch(f){l.pre_master_secret=e.random.getBytes(48)}t.expect=S,t.session.clientCertificate!==null&&(t.expect=E),t.process()},a.handleCertificateRequest=function(e,t,n){if(n<3)return e.error(e,{message:"Invalid CertificateRequest. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});var r=t.fragment,i={certificate_types:o(r,1),certificate_authorities:o(r,2)};e.session.certificateRequest=i,e.expect=p,e.process()},a.handleCertificateVerify=function(t,n,r){if(r<2)return t.error(t,{message:"Invalid CertificateVerify. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});var i=n.fragment;i.read-=4;var s=i.bytes();i.read+=4;var u={signature:o(i,2).getBytes()},f=e.util.createBuffer();f.putBuffer(t.session.md5.digest()),f.putBuffer(t.session.sha1.digest()),f=f.getBytes();try{var l=t.session.clientCertificate;if(!l.publicKey.verify(f,u.signature,"NONE"))throw new Error("CertificateVerify signature does not match.");t.session.md5.update(s),t.session.sha1.update(s)}catch(c){return t.error(t,{message:"Bad signature in CertificateVerify.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure}})}t.expect=S,t.process()},a.handleServerHelloDone=function(t,n,r){if(r>0)return t.error(t,{message:"Invalid ServerHelloDone message. Invalid length.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.record_overflow}});if(t.serverCertificate===null){var i={message:"No server certificate provided. Not enough security.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.insufficient_security}},s=0,o=t.verify(t,i.alert.description,s,[]);if(o!==!0){if(o||o===0)typeof o=="object"&&!e.util.isArray(o)?(o.message&&(i.message=o.message),o.alert&&(i.alert.description=o.alert)):typeof o=="number"&&(i.alert.description=o);return t.error(t,i)}}t.session.certificateRequest!==null&&(n=a.createRecord(t,{type:a.ContentType.handshake,data:a.createCertificate(t)}),a.queue(t,n)),n=a.createRecord(t,{type:a.ContentType.handshake,data:a.createClientKeyExchange(t)}),a.queue(t,n),t.expect=g;var u=function(e,t){e.session.certificateRequest!==null&&e.session.clientCertificate!==null&&a.queue(e,a.createRecord(e,{type:a.ContentType.handshake,data:a.createCertificateVerify(e,t)})),a.queue(e,a.createRecord(e,{type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),e.state.pending=a.createConnectionState(e),e.state.current.write=e.state.pending.write,a.queue(e,a.createRecord(e,{type:a.ContentType.handshake,data:a.createFinished(e)})),e.expect=d,a.flush(e),e.process()};if(t.session.certificateRequest===null||t.session.clientCertificate===null)return u(t,null);a.getClientSignature(t,u)},a.handleChangeCipherSpec=function(e,t){if(t.fragment.getByte()!==1)return e.error(e,{message:"Invalid ChangeCipherSpec message received.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});var n=e.entity===a.ConnectionEnd.client;if(e.session.resuming&&n||!e.session.resuming&&!n)e.state.pending=a.createConnectionState(e);e.state.current.read=e.state.pending.read;if(!e.session.resuming&&n||e.session.resuming&&!n)e.state.pending=null;e.expect=n?v:x,e.process()},a.handleFinished=function(n,r,i){var s=r.fragment;s.read-=4;var o=s.bytes();s.read+=4;var u=r.fragment.getBytes();s=e.util.createBuffer(),s.putBuffer(n.session.md5.digest()),s.putBuffer(n.session.sha1.digest());var f=n.entity===a.ConnectionEnd.client,l=f?"server finished":"client finished",c=n.session.sp,h=12,p=t;s=p(c.master_secret,l,s.getBytes(),h);if(s.getBytes()!==u)return n.error(n,{message:"Invalid verify_data in Finished message.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decrypt_error}});n.session.md5.update(o),n.session.sha1.update(o);if(n.session.resuming&&f||!n.session.resuming&&!f)a.queue(n,a.createRecord(n,{type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),n.state.current.write=n.state.pending.write,n.state.pending=null,a.queue(n,a.createRecord(n,{type:a.ContentType.handshake,data:a.createFinished(n)}));n.expect=f?m:T,n.handshaking=!1,++n.handshakes,n.peerCertificate=f?n.session.serverCertificate:n.session.clientCertificate,a.flush(n),n.isConnected=!0,n.connected(n),n.process()},a.handleAlert=function(e,t){var n=t.fragment,r={level:n.getByte(),description:n.getByte()},i;switch(r.description){case a.Alert.Description.close_notify:i="Connection closed.";break;case a.Alert.Description.unexpected_message:i="Unexpected message.";break;case a.Alert.Description.bad_record_mac:i="Bad record MAC.";break;case a.Alert.Description.decryption_failed:i="Decryption failed.";break;case a.Alert.Description.record_overflow:i="Record overflow.";break;case a.Alert.Description.decompression_failure:i="Decompression failed.";break;case a.Alert.Description.handshake_failure:i="Handshake failure.";break;case a.Alert.Description.bad_certificate:i="Bad certificate.";break;case a.Alert.Description.unsupported_certificate:i="Unsupported certificate.";break;case a.Alert.Description.certificate_revoked:i="Certificate revoked.";break;case a.Alert.Description.certificate_expired:i="Certificate expired.";break;case a.Alert.Description.certificate_unknown:i="Certificate unknown.";break;case a.Alert.Description.illegal_parameter:i="Illegal parameter.";break;case a.Alert.Description.unknown_ca:i="Unknown certificate authority.";break;case a.Alert.Description.access_denied:i="Access denied.";break;case a.Alert.Description.decode_error:i="Decode error.";break;case a.Alert.Description.decrypt_error:i="Decrypt error.";break;case a.Alert.Description.export_restriction:i="Export restriction.";break;case a.Alert.Description.protocol_version:i="Unsupported protocol version.";break;case a.Alert.Description.insufficient_security:i="Insufficient security.";break;case a.Alert.Description.internal_error:i="Internal error.";break;case a.Alert.Description.user_canceled:i="User canceled.";break;case a.Alert.Description.no_renegotiation:i="Renegotiation not supported.";break;default:i="Unknown error."}if(r.description===a.Alert.Description.close_notify)return e.close();e.error(e,{message:i,send:!1,origin:e.entity===a.ConnectionEnd.client?"server":"client",alert:r}),e.process()},a.handleHandshake=function(t,n){var r=n.fragment,i=r.getByte(),s=r.getInt24();if(s>r.length())return t.fragmented=n,n.fragment=e.util.createBuffer(),r.read-=4,t.process();t.fragmented=null,r.read-=4;var o=r.bytes(s+4);r.read+=4,i in q[t.entity][t.expect]?(t.entity===a.ConnectionEnd.server&&!t.open&&!t.fail&&(t.handshaking=!0,t.session={version:null,extensions:{server_name:{serverNameList:[]}},cipherSuite:null,compressionMethod:null,serverCertificate:null,clientCertificate:null,md5:e.md.md5.create(),sha1:e.md.sha1.create()}),i!==a.HandshakeType.hello_request&&i!==a.HandshakeType.certificate_verify&&i!==a.HandshakeType.finished&&(t.session.md5.update(o),t.session.sha1.update(o)),q[t.entity][t.expect][i](t,n,s)):a.handleUnexpected(t,n)},a.handleApplicationData=function(e,t){e.data.putBuffer(t.fragment),e.dataReady(e),e.process()},a.handleHeartbeat=function(t,n){var r=n.fragment,i=r.getByte(),s=r.getInt16(),o=r.getBytes(s);if(i===a.HeartbeatMessageType.heartbeat_request){if(t.handshaking||s>o.length)return t.process();a.queue(t,a.createRecord(t,{type:a.ContentType.heartbeat,data:a.createHeartbeat(a.HeartbeatMessageType.heartbeat_response,o)})),a.flush(t)}else if(i===a.HeartbeatMessageType.heartbeat_response){if(o!==t.expectedHeartbeatPayload)return t.process();t.heartbeatReceived&&t.heartbeatReceived(t,e.util.createBuffer(o))}t.process()};var f=0,l=1,c=2,h=3,p=4,d=5,v=6,m=7,g=8,y=0,b=1,w=2,E=3,S=4,x=5,T=6,N=7,C=a.handleUnexpected,k=a.handleChangeCipherSpec,L=a.handleAlert,A=a.handleHandshake,O=a.handleApplicationData,M=a.handleHeartbeat,_=[];_[a.ConnectionEnd.client]=[[C,L,A,C,M],[C,L,A,C,M],[C,L,A,C,M],[C,L,A,C,M],[C,L,A,C,M],[k,L,C,C,M],[C,L,A,C,M],[C,L,A,O,M],[C,L,A,C,M]],_[a.ConnectionEnd.server]=[[C,L,A,C,M],[C,L,A,C,M],[C,L,A,C,M],[C,L,A,C,M],[k,L,C,C,M],[C,L,A,C,M],[C,L,A,O,M],[C,L,A,C,M]];var D=a.handleHelloRequest,P=a.handleServerHello,H=a.handleCertificate,B=a.handleServerKeyExchange,j=a.handleCertificateRequest,F=a.handleServerHelloDone,I=a.handleFinished,q=[];q[a.ConnectionEnd.client]=[[C,C,P,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,H,B,j,F,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,B,j,F,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,C,j,F,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,C,C,F,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,I],[D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]];var R=a.handleClientHello,U=a.handleClientKeyExchange,z=a.handleCertificateVerify;q[a.ConnectionEnd.server]=[[C,R,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,H,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,U,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,z,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,I],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]],a.generateKeys=function(e,n){var r=t,i=n.client_random+n.server_random;e.session.resuming||(n.master_secret=r(n.pre_master_secret,"master secret",i,48).bytes(),n.pre_master_secret=null),i=n.server_random+n.client_random;var s=2*n.mac_key_length+2*n.enc_key_length,o=e.version.major===a.Versions.TLS_1_0.major&&e.version.minor===a.Versions.TLS_1_0.minor;o&&(s+=2*n.fixed_iv_length);var u=r(n.master_secret,"key expansion",i,s),f={client_write_MAC_key:u.getBytes(n.mac_key_length),server_write_MAC_key:u.getBytes(n.mac_key_length),client_write_key:u.getBytes(n.enc_key_length),server_write_key:u.getBytes(n.enc_key_length)};return o&&(f.client_write_IV=u.getBytes(n.fixed_iv_length),f.server_write_IV=u.getBytes(n.fixed_iv_length)),f},a.createConnectionState=function(e){var t=e.entity===a.ConnectionEnd.client,n=function(){var e={sequenceNumber:[0,0],macKey:null,macLength:0,macFunction:null,cipherState:null,cipherFunction:function(e){return!0},compressionState:null,compressFunction:function(e){return!0},updateSequenceNumber:function(){e.sequenceNumber[1]===4294967295?(e.sequenceNumber[1]=0,++e.sequenceNumber[0]):++e.sequenceNumber[1]}};return e},r={read:n(),write:n()};r.read.update=function(e,t){return r.read.cipherFunction(t,r.read)?r.read.compressFunction(e,t,r.read)||e.error(e,{message:"Could not decompress record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decompression_failure}}):e.error(e,{message:"Could not decrypt record or bad MAC.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_record_mac}}),!e.fail},r.write.update=function(e,t){return r.write.compressFunction(e,t,r.write)?r.write.cipherFunction(t,r.write)||e.error(e,{message:"Could not encrypt record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):e.error(e,{message:"Could not compress record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}),!e.fail};if(e.session){var o=e.session.sp;e.session.cipherSuite.initSecurityParameters(o),o.keys=a.generateKeys(e,o),r.read.macKey=t?o.keys.server_write_MAC_key:o.keys.client_write_MAC_key,r.write.macKey=t?o.keys.client_write_MAC_key:o.keys.server_write_MAC_key,e.session.cipherSuite.initConnectionState(r,e,o);switch(o.compression_algorithm){case a.CompressionMethod.none:break;case a.CompressionMethod.deflate:r.read.compressFunction=s,r.write.compressFunction=i;break;default:throw new Error("Unsupported compression algorithm.")}}return r},a.createRandom=function(){var t=new Date,n=+t+t.getTimezoneOffset()*6e4,r=e.util.createBuffer();return r.putInt32(n),r.putBytes(e.random.getBytes(28)),r},a.createRecord=function(e,t){if(!t.data)return null;var n={type:t.type,version:{major:e.version.major,minor:e.version.minor},length:t.data.length(),fragment:t.data};return n},a.createAlert=function(t,n){var r=e.util.createBuffer();return r.putByte(n.level),r.putByte(n.description),a.createRecord(t,{type:a.ContentType.alert,data:r})},a.createClientHello=function(t){t.session.clientHelloVersion={major:t.version.major,minor:t.version.minor};var n=e.util.createBuffer();for(var r=0;r<t.cipherSuites.length;++r){var i=t.cipherSuites[r];n.putByte(i.id[0]),n.putByte(i.id[1])}var s=n.length(),o=e.util.createBuffer();o.putByte(a.CompressionMethod.none);var f=o.length(),l=e.util.createBuffer();if(t.virtualHost){var c=e.util.createBuffer();c.putByte(0),c.putByte(0);var h=e.util.createBuffer();h.putByte(0),u(h,2,e.util.createBuffer(t.virtualHost));var p=e.util.createBuffer();u(p,2,h),u(c,2,p),l.putBuffer(c)}var d=l.length();d>0&&(d+=2);var v=t.session.id,m=v.length+1+2+4+28+2+s+1+f+d,g=e.util.createBuffer();return g.putByte(a.HandshakeType.client_hello),g.putInt24(m),g.putByte(t.version.major),g.putByte(t.version.minor),g.putBytes(t.session.sp.client_random),u(g,1,e.util.createBuffer(v)),u(g,2,n),u(g,1,o),d>0&&u(g,2,l),g},a.createServerHello=function(t){var n=t.session.id,r=n.length+1+2+4+28+2+1,i=e.util.createBuffer();return i.putByte(a.HandshakeType.server_hello),i.putInt24(r),i.putByte(t.version.major),i.putByte(t.version.minor),i.putBytes(t.session.sp.server_random),u(i,1,e.util.createBuffer(n)),i.putByte(t.session.cipherSuite.id[0]),i.putByte(t.session.cipherSuite.id[1]),i.putByte(t.session.compressionMethod),i},a.createCertificate=function(t){var n=t.entity===a.ConnectionEnd.client,r=null;if(t.getCertificate){var i;n?i=t.session.certificateRequest:i=t.session.extensions.server_name.serverNameList,r=t.getCertificate(t,i)}var s=e.util.createBuffer();if(r!==null)try{e.util.isArray(r)||(r=[r]);var o=null;for(var f=0;f<r.length;++f){var l=e.pem.decode(r[f])[0];if(l.type!=="CERTIFICATE"&&l.type!=="X509 CERTIFICATE"&&l.type!=="TRUSTED CERTIFICATE"){var c=new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');throw c.headerType=l.type,c}if(l.procType&&l.procType.type==="ENCRYPTED")throw new Error("Could not convert certificate from PEM; PEM is encrypted.");var h=e.util.createBuffer(l.body);o===null&&(o=e.asn1.fromDer(h.bytes(),!1));var p=e.util.createBuffer();u(p,3,h),s.putBuffer(p)}r=e.pki.certificateFromAsn1(o),n?t.session.clientCertificate=r:t.session.serverCertificate=r}catch(d){return t.error(t,{message:"Could not send certificate list.",cause:d,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}var v=3+s.length(),m=e.util.createBuffer();return m.putByte(a.HandshakeType.certificate),m.putInt24(v),u(m,3,s),m},a.createClientKeyExchange=function(t){var n=e.util.createBuffer();n.putByte(t.session.clientHelloVersion.major),n.putByte(t.session.clientHelloVersion.minor),n.putBytes(e.random.getBytes(46));var r=t.session.sp;r.pre_master_secret=n.getBytes();var i=t.session.serverCertificate.publicKey;n=i.encrypt(r.pre_master_secret);var s=n.length+2,o=e.util.createBuffer();return o.putByte(a.HandshakeType.client_key_exchange),o.putInt24(s),o.putInt16(n.length),o.putBytes(n),o},a.createServerKeyExchange=function(t){var n=0,r=e.util.createBuffer();return n>0&&(r.putByte(a.HandshakeType.server_key_exchange),r.putInt24(n)),r},a.getClientSignature=function(t,n){var r=e.util.createBuffer();r.putBuffer(t.session.md5.digest()),r.putBuffer(t.session.sha1.digest()),r=r.getBytes(),t.getSignature=t.getSignature||function(t,n,r){var i=null;if(t.getPrivateKey)try{i=t.getPrivateKey(t,t.session.clientCertificate),i=e.pki.privateKeyFromPem(i)}catch(s){t.error(t,{message:"Could not get private key.",cause:s,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}i===null?t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):n=i.sign(n,null),r(t,n)},t.getSignature(t,r,n)},a.createCertificateVerify=function(t,n){var r=n.length+2,i=e.util.createBuffer();return i.putByte(a.HandshakeType.certificate_verify),i.putInt24(r),i.putInt16(n.length),i.putBytes(n),i},a.createCertificateRequest=function(t){var n=e.util.createBuffer();n.putByte(1);var r=e.util.createBuffer();for(var i in t.caStore.certs){var s=t.caStore.certs[i],o=e.pki.distinguishedNameToAsn1(s.subject);r.putBuffer(e.asn1.toDer(o))}var f=1+n.length()+2+r.length(),l=e.util.createBuffer();return l.putByte(a.HandshakeType.certificate_request),l.putInt24(f),u(l,1,n),u(l,2,r),l},a.createServerHelloDone=function(t){var n=e.util.createBuffer();return n.putByte(a.HandshakeType.server_hello_done),n.putInt24(0),n},a.createChangeCipherSpec=function(){var t=e.util.createBuffer();return t.putByte(1),t},a.createFinished=function(n){var r=e.util.createBuffer();r.putBuffer(n.session.md5.digest()),r.putBuffer(n.session.sha1.digest());var i=n.entity===a.ConnectionEnd.client,s=n.session.sp,o=12,u=t,f=i?"client finished":"server finished";r=u(s.master_secret,f,r.getBytes(),o);var l=e.util.createBuffer();return l.putByte(a.HandshakeType.finished),l.putInt24(r.length()),l.putBuffer(r),l},a.createHeartbeat=function(t,n,r){typeof r=="undefined"&&(r=n.length);var i=e.util.createBuffer();i.putByte(t),i.putInt16(r),i.putBytes(n);var s=i.length(),o=Math.max(16,s-r-3);return i.putBytes(e.random.getBytes(o)),i},a.queue=function(t,n){if(!n)return;if(n.type===a.ContentType.handshake){var r=n.fragment.bytes();t.session.md5.update(r),t.session.sha1.update(r),r=null}var i;if(n.fragment.length()<=a.MaxFragment)i=[n];else{i=[];var s=n.fragment.bytes();while(s.length>a.MaxFragment)i.push(a.createRecord(t,{type:n.type,data:e.util.createBuffer(s.slice(0,a.MaxFragment))})),s=s.slice(a.MaxFragment);s.length>0&&i.push(a.createRecord(t,{type:n.type,data:e.util.createBuffer(s)}))}for(var o=0;o<i.length&&!t.fail;++o){var u=i[o],f=t.state.current.write;f.update(t,u)&&t.records.push(u)}},a.flush=function(e){for(var t=0;t<e.records.length;++t){var n=e.records[t];e.tlsData.putByte(n.type),e.tlsData.putByte(n.version.major),e.tlsData.putByte(n.version.minor),e.tlsData.putInt16(n.fragment.length()),e.tlsData.putBuffer(e.records[t].fragment)}return e.records=[],e.tlsDataReady(e)};var W=function(t){switch(t){case!0:return!0;case e.pki.certificateError.bad_certificate:return a.Alert.Description.bad_certificate;case e.pki.certificateError.unsupported_certificate:return a.Alert.Description.unsupported_certificate;case e.pki.certificateError.certificate_revoked:return a.Alert.Description.certificate_revoked;case e.pki.certificateError.certificate_expired:return a.Alert.Description.certificate_expired;case e.pki.certificateError.certificate_unknown:return a.Alert.Description.certificate_unknown;case e.pki.certificateError.unknown_ca:return a.Alert.Description.unknown_ca;default:return a.Alert.Description.bad_certificate}},X=function(t){switch(t){case!0:return!0;case a.Alert.Description.bad_certificate:return e.pki.certificateError.bad_certificate;case a.Alert.Description.unsupported_certificate:return e.pki.certificateError.unsupported_certificate;case a.Alert.Description.certificate_revoked:return e.pki.certificateError.certificate_revoked;case a.Alert.Description.certificate_expired:return e.pki.certificateError.certificate_expired;case a.Alert.Description.certificate_unknown:return e.pki.certificateError.certificate_unknown;case a.Alert.Description.unknown_ca:return e.pki.certificateError.unknown_ca;default:return e.pki.certificateError.bad_certificate}};a.verifyCertificateChain=function(t,n){try{e.pki.verifyCertificateChain(t.caStore,n,function(r,i,s){var o=W(r),u=t.verify(t,r,i,s);if(u!==!0){if(typeof u=="object"&&!e.util.isArray(u)){var f=new Error("The application rejected the certificate.");throw f.send=!0,f.alert={level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate},u.message&&(f.message=u.message),u.alert&&(f.alert.description=u.alert),f}u!==r&&(u=X(u))}return u})}catch(r){var i=r;if(typeof i!="object"||e.util.isArray(i))i={send:!0,alert:{level:a.Alert.Level.fatal,description:W(r)}};"send"in i||(i.send=!0),"alert"in i||(i.alert={level:a.Alert.Level.fatal,description:W(i.error)}),t.error(t,i)}return!t.fail},a.createSessionCache=function(t,n){var r=null;if(t&&t.getSession&&t.setSession&&t.order)r=t;else{r={},r.cache=t||{},r.capacity=Math.max(n||100,1),r.order=[];for(var i in t)r.order.length<=n?r.order.push(i):delete t[i];r.getSession=function(t){var n=null,i=null;t?i=e.util.bytesToHex(t):r.order.length>0&&(i=r.order[0]);if(i!==null&&i in r.cache){n=r.cache[i],delete r.cache[i];for(var s in r.order)if(r.order[s]===i){r.order.splice(s,1);break}}return n},r.setSession=function(t,n){if(r.order.length===r.capacity){var i=r.order.shift();delete r.cache[i]}var i=e.util.bytesToHex(t);r.order.push(i),r.cache[i]=n}}return r},a.createConnection=function(t){var n=null;t.caStore?e.util.isArray(t.caStore)?n=e.pki.createCaStore(t.caStore):n=t.caStore:n=e.pki.createCaStore();var r=t.cipherSuites||null;if(r===null){r=[];for(var i in a.CipherSuites)r.push(a.CipherSuites[i])}var s=t.server||!1?a.ConnectionEnd.server:a.ConnectionEnd.client,o=t.sessionCache?a.createSessionCache(t.sessionCache):null,u={version:{major:a.Version.major,minor:a.Version.minor},entity:s,sessionId:t.sessionId,caStore:n,sessionCache:o,cipherSuites:r,connected:t.connected,virtualHost:t.virtualHost||null,verifyClient:t.verifyClient||!1,verify:t.verify||function(e,t,n,r){return t},getCertificate:t.getCertificate||null,getPrivateKey:t.getPrivateKey||null,getSignature:t.getSignature||null,input:e.util.createBuffer(),tlsData:e.util.createBuffer(),data:e.util.createBuffer(),tlsDataReady:t.tlsDataReady,dataReady:t.dataReady,heartbeatReceived:t.heartbeatReceived,closed:t.closed,error:function(e,n){n.origin=n.origin||(e.entity===a.ConnectionEnd.client?"client":"server"),n.send&&(a.queue(e,a.createAlert(e,n.alert)),a.flush(e));var r=n.fatal!==!1;r&&(e.fail=!0),t.error(e,n),r&&e.close(!1)},deflate:t.deflate||null,inflate:t.inflate||null};u.reset=function(e){u.version={major:a.Version.major,minor:a.Version.minor},u.record=null,u.session=null,u.peerCertificate=null,u.state={pending:null,current:null},u.expect=u.entity===a.ConnectionEnd.client?f:y,u.fragmented=null,u.records=[],u.open=!1,u.handshakes=0,u.handshaking=!1,u.isConnected=!1,u.fail=!e&&typeof e!="undefined",u.input.clear(),u.tlsData.clear(),u.data.clear(),u.state.current=a.createConnectionState(u)},u.reset();var l=function(e,t){var n=t.type-a.ContentType.change_cipher_spec,r=_[e.entity][e.expect];n in r?r[n](e,t):a.handleUnexpected(e,t)},c=function(t){var n=0,r=t.input,i=r.length();if(i<5)n=5-i;else{t.record={type:r.getByte(),version:{major:r.getByte(),minor:r.getByte()},length:r.getInt16(),fragment:e.util.createBuffer(),ready:!1};var s=t.record.version.major===t.version.major;s&&t.session&&t.session.version&&(s=t.record.version.minor===t.version.minor),s||t.error(t,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}})}return n},h=function(e){var t=0,n=e.input,r=n.length();if(r<e.record.length)t=e.record.length-r;else{e.record.fragment.putBytes(n.getBytes(e.record.length)),n.compact();var i=e.state.current.read;i.update(e,e.record)&&(e.fragmented!==null&&(e.fragmented.type===e.record.type?(e.fragmented.fragment.putBuffer(e.record.fragment),e.record=e.fragmented):e.error(e,{message:"Invalid fragmented record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})),e.record.ready=!0)}return t};return u.handshake=function(t){if(u.entity!==a.ConnectionEnd.client)u.error(u,{message:"Cannot initiate handshake as a server.",fatal:!1});else if(u.handshaking)u.error(u,{message:"Handshake already in progress.",fatal:!1});else{u.fail&&!u.open&&u.handshakes===0&&(u.fail=!1),u.handshaking=!0,t=t||"";var n=null;t.length>0&&(u.sessionCache&&(n=u.sessionCache.getSession(t)),n===null&&(t="")),t.length===0&&u.sessionCache&&(n=u.sessionCache.getSession(),n!==null&&(t=n.id)),u.session={id:t,version:null,cipherSuite:null,compressionMethod:null,serverCertificate:null,certificateRequest:null,clientCertificate:null,sp:{},md5:e.md.md5.create(),sha1:e.md.sha1.create()},n&&(u.version=n.version,u.session.sp=n.sp),u.session.sp.client_random=a.createRandom().getBytes(),u.open=!0,a.queue(u,a.createRecord(u,{type:a.ContentType.handshake,data:a.createClientHello(u)})),a.flush(u)}},u.process=function(e){var t=0;return e&&u.input.putBytes(e),u.fail||(u.record!==null&&u.record.ready&&u.record.fragment.isEmpty()&&(u.record=null),u.record===null&&(t=c(u)),!u.fail&&u.record!==null&&!u.record.ready&&(t=h(u)),!u.fail&&u.record!==null&&u.record.ready&&l(u,u.record)),t},u.prepare=function(t){return a.queue(u,a.createRecord(u,{type:a.ContentType.application_data,data:e.util.createBuffer(t)})),a.flush(u)},u.prepareHeartbeatRequest=function(t,n){return t instanceof e.util.ByteBuffer&&(t=t.bytes()),typeof n=="undefined"&&(n=t.length),u.expectedHeartbeatPayload=t,a.queue(u,a.createRecord(u,{type:a.ContentType.heartbeat,data:a.createHeartbeat(a.HeartbeatMessageType.heartbeat_request,t,n)})),a.flush(u)},u.close=function(e){if(!u.fail&&u.sessionCache&&u.session){var t={id:u.session.id,version:u.session.version,sp:u.session.sp};t.sp.keys=null,u.sessionCache.setSession(t.id,t)}if(u.open){u.open=!1,u.input.clear();if(u.isConnected||u.handshaking)u.isConnected=u.handshaking=!1,a.queue(u,a.createAlert(u,{level:a.Alert.Level.warning,description:a.Alert.Description.close_notify})),a.flush(u);u.closed(u)}u.reset(e)},u},e.tls=e.tls||{};for(var V in a)typeof a[V]!="function"&&(e.tls[V]=a[V]);e.tls.prf_tls1=t,e.tls.hmac_sha1=r,e.tls.createSessionCache=a.createSessionCache,e.tls.createConnection=a.createConnection}var r="tls";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/tls",["require","module","./asn1","./hmac","./md","./pem","./pki","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(n,i,s){var o=i.entity===e.tls.ConnectionEnd.client;n.read.cipherState={init:!1,cipher:e.cipher.createDecipher("AES-CBC",o?s.keys.server_write_key:s.keys.client_write_key),iv:o?s.keys.server_write_IV:s.keys.client_write_IV},n.write.cipherState={init:!1,cipher:e.cipher.createCipher("AES-CBC",o?s.keys.client_write_key:s.keys.server_write_key),iv:o?s.keys.client_write_IV:s.keys.server_write_IV},n.read.cipherFunction=u,n.write.cipherFunction=r,n.read.macLength=n.write.macLength=s.mac_length,n.read.macFunction=n.write.macFunction=t.hmac_sha1}function r(n,r){var s=!1,o=r.macFunction(r.macKey,r.sequenceNumber,n);n.fragment.putBytes(o),r.updateSequenceNumber();var u;n.version.minor===t.Versions.TLS_1_0.minor?u=r.cipherState.init?null:r.cipherState.iv:u=e.random.getBytesSync(16),r.cipherState.init=!0;var a=r.cipherState.cipher;return a.start({iv:u}),n.version.minor>=t.Versions.TLS_1_1.minor&&a.output.putBytes(u),a.update(n.fragment),a.finish(i)&&(n.fragment=a.output,n.length=n.fragment.length(),s=!0),s}function i(e,t,n){if(!n){var r=e-t.length()%e;t.fillWithByte(r-1,r)}return!0}function s(e,t,n){var r=!0;if(n){var i=t.length(),s=t.last();for(var o=i-1-s;o<i-1;++o)r=r&&t.at(o)==s;r&&t.truncate(s+1)}return r}function u(n,r){var i=!1;++o;var u;n.version.minor===t.Versions.TLS_1_0.minor?u=r.cipherState.init?null:r.cipherState.iv:u=n.fragment.getBytes(16),r.cipherState.init=!0;var f=r.cipherState.cipher;f.start({iv:u}),f.update(n.fragment),i=f.finish(s);var l=r.macLength,c=e.random.getBytesSync(l),h=f.output.length();h>=l?(n.fragment=f.output.getBytes(h-l),c=f.output.getBytes(l)):n.fragment=f.output.getBytes(),n.fragment=e.util.createBuffer(n.fragment),n.length=n.fragment.length();var p=r.macFunction(r.macKey,r.sequenceNumber,n);return r.updateSequenceNumber(),i=a(r.macKey,c,p)&&i,i}function a(t,n,r){var i=e.hmac.create();return i.start("SHA1",t),i.update(n),n=i.digest().getBytes(),i.start(null,null),i.update(r),r=i.digest().getBytes(),n===r}var t=e.tls;t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA={id:[0,47],name:"TLS_RSA_WITH_AES_128_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=16,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n},t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA={id:[0,53],name:"TLS_RSA_WITH_AES_256_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=32,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n};var o=0}var r="aesCipherSuites";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aesCipherSuites",["require","module","./aes","./tls"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.debug=e.debug||{},e.debug.storage={},e.debug.get=function(t,n){var r;return typeof t=="undefined"?r=e.debug.storage:t in e.debug.storage&&(typeof n=="undefined"?r=e.debug.storage[t]:r=e.debug.storage[t][n]),r},e.debug.set=function(t,n,r){t in e.debug.storage||(e.debug.storage[t]={}),e.debug.storage[t][n]=r},e.debug.clear=function(t,n){typeof t=="undefined"?e.debug.storage={}:t in e.debug.storage&&(typeof n=="undefined"?delete e.debug.storage[t]:delete e.debug.storage[t][n])}}var r="debug";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/debug",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(t,n,r,i){t.generate=function(t,s){var o=new e.util.ByteBuffer,u=Math.ceil(s/i)+r,a=new e.util.ByteBuffer;for(var f=r;f<u;++f){a.putInt32(f),n.start(),n.update(t+a.getBytes());var l=n.digest();o.putBytes(l.getBytes(i))}return o.truncate(o.length()-s),o.getBytes()}}e.kem=e.kem||{};var t=e.jsbn.BigInteger;e.kem.rsa={},e.kem.rsa.create=function(n,r){r=r||{};var i=r.prng||e.random,s={};return s.encrypt=function(r,s){var o=Math.ceil(r.n.bitLength()/8),u;do u=(new t(e.util.bytesToHex(i.getBytesSync(o)),16)).mod(r.n);while(u.equals(t.ZERO));u=e.util.hexToBytes(u.toString(16));var a=o-u.length;a>0&&(u=e.util.fillString(String.fromCharCode(0),a)+u);var f=r.encrypt(u,"NONE"),l=n.generate(u,s);return{encapsulation:f,key:l}},s.decrypt=function(e,t,r){var i=e.decrypt(t,"NONE");return n.generate(i,r)},s},e.kem.kdf1=function(e,t){n(this,e,0,t||e.digestLength)},e.kem.kdf2=function(e,t){n(this,e,1,t||e.digestLength)}}var r="kem";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/kem",["require","module","./util","./random","./jsbn"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.log=e.log||{},e.log.levels=["none","error","warning","info","debug","verbose","max"];var t={},n=[],r=null;e.log.LEVEL_LOCKED=2,e.log.NO_LEVEL_CHECK=4,e.log.INTERPOLATE=8;for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];t[s]={index:i,name:s.toUpperCase()}}e.log.logMessage=function(r){var i=t[r.level].index;for(var s=0;s<n.length;++s){var o=n[s];if(o.flags&e.log.NO_LEVEL_CHECK)o.f(r);else{var u=t[o.level].index;i<=u&&o.f(o,r)}}},e.log.prepareStandard=function(e){"standard"in e||(e.standard=t[e.level].name+" ["+e.category+"] "+e.message)},e.log.prepareFull=function(t){if(!("full"in t)){var n=[t.message];n=n.concat([]||t.arguments),t.full=e.util.format.apply(this,n)}},e.log.prepareStandardFull=function(t){"standardFull"in t||(e.log.prepareStandard(t),t.standardFull=t.standard)};var o=["error","warning","info","debug","verbose"];for(var i=0;i<o.length;++i)(function(t){e.log[t]=function(n,r){var i=Array.prototype.slice.call(arguments).slice(2),s={timestamp:new Date,level:t,category:n,message:r,arguments:i};e.log.logMessage(s)}})(o[i]);e.log.makeLogger=function(t){var n={flags:0,f:t};return e.log.setLevel(n,"none"),n},e.log.setLevel=function(t,n){var r=!1;if(t&&!(t.flags&e.log.LEVEL_LOCKED))for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];if(n==s){t.level=n,r=!0;break}}return r},e.log.lock=function(t,n){typeof n=="undefined"||n?t.flags|=e.log.LEVEL_LOCKED:t.flags&=~e.log.LEVEL_LOCKED},e.log.addLogger=function(e){n.push(e)};if(typeof console!="undefined"&&"log"in console){var u;if(console.error&&console.warn&&console.info&&console.debug){var a={error:console.error,warning:console.warn,info:console.info,debug:console.debug,verbose:console.debug},f=function(t,n){e.log.prepareStandard(n);var r=a[n.level],i=[n.standard];i=i.concat(n.arguments.slice()),r.apply(console,i)};u=e.log.makeLogger(f)}else{var f=function(t,n){e.log.prepareStandardFull(n),console.log(n.standardFull)};u=e.log.makeLogger(f)}e.log.setLevel(u,"debug"),e.log.addLogger(u),r=u}else console={log:function(){}};if(r!==null){var l=e.util.getQueryVariables();"console.level"in l&&e.log.setLevel(r,l["console.level"].slice(-1)[0]);if("console.lock"in l){var c=l["console.lock"].slice(-1)[0];c=="true"&&e.log.lock(r)}}e.log.consoleLogger=r}var r="log";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/log",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function r(r){var i={},s=[];if(!t.validate(r,n.asn1.recipientInfoValidator,i,s)){var o=new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");throw o.errors=s,o}return{version:i.version.charCodeAt(0),issuer:e.pki.RDNAttributesAsArray(i.issuer),serialNumber:e.util.createBuffer(i.serial).toHex(),encryptedContent:{algorithm:t.derToOid(i.encAlgorithm),parameter:i.encParameter.value,content:i.encKey}}}function i(n){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[e.pki.distinguishedNameToAsn1({attributes:n.issuer}),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(n.serialNumber))]),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.encryptedContent.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.encryptedContent.content)])}function s(e){var t=[];for(var n=0;n<e.length;++n)t.push(r(e[n]));return t}function o(e){var t=[];for(var n=0;n<e.length;++n)t.push(i(e[n]));return t}function u(r){var i={},s=[];if(!t.validate(r,n.asn1.signerInfoValidator,i,s)){var o=new Error("Cannot read PKCS#7 SignerInfo. ASN.1 object is not an PKCS#7 SignerInfo.");throw o.errors=s,o}var u={version:i.version.charCodeAt(0),issuer:e.pki.RDNAttributesAsArray(i.issuer),serialNumber:e.util.createBuffer(i.serial).toHex(),digestAlgorithm:t.derToOid(i.digestAlgorithm),signatureAlgorithm:t.derToOid(i.signatureAlgorithm),signature:i.signature,authenticatedAttributes:[],unauthenticatedAttributes:[]},a=i.authenticatedAttributes||[],f=i.unauthenticatedAttributes||[];return u}function a(n){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[e.pki.distinguishedNameToAsn1({attributes:n.issuer}),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(n.serialNumber))]),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.digestAlgorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])]);n.authenticatedAttributesAsn1&&r.value.push(n.authenticatedAttributesAsn1),r.value.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.signatureAlgorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])),r.value.push(t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.signature));if(n.unauthenticatedAttributes.length>0){var i=t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[]);for(var s=0;s<n.unauthenticatedAttributes.length;++s){var o=n.unauthenticatedAttributes[s];i.values.push(c(o))}r.value.push(i)}return r}function f(e){var t=[];for(var n=0;n<e.length;++n)t.push(u(e[n]));return t}function l(e){var t=[];for(var n=0;n<e.length;++n)t.push(a(e[n]));return t}function c(n){var r;if(n.type===e.pki.oids.contentType)r=t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.value).getBytes());else if(n.type===e.pki.oids.messageDigest)r=t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.value.bytes());else if(n.type===e.pki.oids.signingTime){var i=new Date("Jan 1, 1950 00:00:00Z"),s=new Date("Jan 1, 2050 00:00:00Z"),o=n.value;if(typeof o=="string"){var u=Date.parse(o);isNaN(u)?o.length===13?o=t.utcTimeToDate(o):o=t.generalizedTimeToDate(o):o=new Date(u)}o>=i&&o<s?r=t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(o)):r=t.create(t.Class.UNIVERSAL,t.Type.GENERALIZEDTIME,!1,t.dateToGeneralizedTime(o))}return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.type).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[r])])}function h(n){return[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.parameter.getBytes())]),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.content.getBytes())])]}function p(n,r,i){var s={},o=[];if(!t.validate(r,i,s,o)){var u=new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");throw u.errors=u,u}var a=t.derToOid(s.contentType);if(a!==e.pki.oids.data)throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");if(s.encryptedContent){var f="";if(e.util.isArray(s.encryptedContent))for(var l=0;l<s.encryptedContent.length;++l){if(s.encryptedContent[l].type!==t.Type.OCTETSTRING)throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");f+=s.encryptedContent[l].value}else f=s.encryptedContent;n.encryptedContent={algorithm:t.derToOid(s.encAlgorithm),parameter:e.util.createBuffer(s.encParameter.value),content:e.util.createBuffer(f)}}if(s.content){var f="";if(e.util.isArray(s.content))for(var l=0;l<s.content.length;++l){if(s.content[l].type!==t.Type.OCTETSTRING)throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");f+=s.content[l].value}else f=s.content;n.content=e.util.createBuffer(f)}return n.version=s.version.charCodeAt(0),n.rawCapture=s,s}function d(t){if(t.encryptedContent.key===undefined)throw new Error("Symmetric key not available.");if(t.content===undefined){var n;switch(t.encryptedContent.algorithm){case e.pki.oids["aes128-CBC"]:case e.pki.oids["aes192-CBC"]:case e.pki.oids["aes256-CBC"]:n=e.aes.createDecryptionCipher(t.encryptedContent.key);break;case e.pki.oids.desCBC:case e.pki.oids["des-EDE3-CBC"]:n=e.des.createDecryptionCipher(t.encryptedContent.key);break;default:throw new Error("Unsupported symmetric cipher, OID "+t.encryptedContent.algorithm)}n.start(t.encryptedContent.parameter),n.update(t.encryptedContent.content);if(!n.finish())throw new Error("Symmetric decryption failed.");t.content=n.output}}var t=e.asn1,n=e.pkcs7=e.pkcs7||{};n.messageFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PKCS7"){var s=new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');throw s.headerType=i.type,s}if(i.procType&&i.procType.type==="ENCRYPTED")throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");var o=t.fromDer(i.body);return n.messageFromAsn1(o)},n.messageToPem=function(n,r){var i={type:"PKCS7",body:t.toDer(n.toAsn1()).getBytes()};return e.pem.encode(i,{maxline:r})},n.messageFromAsn1=function(r){var i={},s=[];if(!t.validate(r,n.asn1.contentInfoValidator,i,s)){var o=new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");throw o.errors=s,o}var u=t.derToOid(i.contentType),a;switch(u){case e.pki.oids.envelopedData:a=n.createEnvelopedData();break;case e.pki.oids.encryptedData:a=n.createEncryptedData();break;case e.pki.oids.signedData:a=n.createSignedData();break;default:throw new Error("Cannot read PKCS#7 message. ContentType with OID "+u+" is not (yet) supported.")}return a.fromAsn1(i.content.value[0]),a},n.createSignedData=function(){function i(){var n={};for(var i=0;i<r.signers.length;++i){var s=r.signers[i],o=s.digestAlgorithm;o in n||(n[o]=e.md[e.pki.oids[o]].create()),s.authenticatedAttributes.length===0?s.md=n[o]:s.md=e.md[e.pki.oids[o]].create()}r.digestAlgorithmIdentifiers=[];for(var o in n)r.digestAlgorithmIdentifiers.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(o).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]));return n}function s(n){if(r.contentInfo.value.length<2)throw new Error("Could not sign PKCS#7 message; there is no content to sign.");var i=t.derToOid(r.contentInfo.value[0].value),s=r.contentInfo.value[1];s=s.value[0];var o=t.toDer(s);o.getByte(),t.getBerValueLength(o),o=o.getBytes();for(var u in n)n[u].start().update(o);var a=new Date;for(var f=0;f<r.signers.length;++f){var h=r.signers[f];if(h.authenticatedAttributes.length===0){if(i!==e.pki.oids.data)throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.")}else{h.authenticatedAttributesAsn1=t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[]);var p=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[]);for(var d=0;d<h.authenticatedAttributes.length;++d){var v=h.authenticatedAttributes[d];v.type===e.pki.oids.messageDigest?v.value=n[h.digestAlgorithm].digest():v.type===e.pki.oids.signingTime&&(v.value||(v.value=a)),p.value.push(c(v)),h.authenticatedAttributesAsn1.value.push(c(v))}o=t.toDer(p).getBytes(),h.md.start().update(o)}h.signature=h.key.sign(h.md,"RSASSA-PKCS1-V1_5")}r.signerInfos=l(r.signers)}var r=null;return r={type:e.pki.oids.signedData,version:1,certificates:[],crls:[],signers:[],digestAlgorithmIdentifiers:[],contentInfo:null,signerInfos:[],fromAsn1:function(t){p(r,t,n.asn1.signedDataValidator),r.certificates=[],r.crls=[],r.digestAlgorithmIdentifiers=[],r.contentInfo=null,r.signerInfos=[];var i=r.rawCapture.certificates.value;for(var s=0;s<i.length;++s)r.certificates.push(e.pki.certificateFromAsn1(i[s]))},toAsn1:function(){r.contentInfo||r.sign();var n=[];for(var i=0;i<r.certificates.length;++i)n.push(e.pki.certificateToAsn1(r.certificates[i]));var s=[],o=t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.digestAlgorithmIdentifiers),r.contentInfo])]);return n.length>0&&o.value[0].value.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,n)),s.length>0&&o.value[0].value.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,s)),o.value[0].value.push(t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.signerInfos)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),o])},addSigner:function(t){var n=t.issuer,i=t.serialNumber;if(t.certificate){var s=t.certificate;typeof s=="string"&&(s=e.pki.certificateFromPem(s)),n=s.issuer.attributes,i=s.serialNumber}var o=t.key;if(!o)throw new Error("Could not add PKCS#7 signer; no private key specified.");typeof o=="string"&&(o=e.pki.privateKeyFromPem(o));var u=t.digestAlgorithm||e.pki.oids.sha1;switch(u){case e.pki.oids.sha1:case e.pki.oids.sha256:case e.pki.oids.sha384:case e.pki.oids.sha512:case e.pki.oids.md5:break;default:throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: "+u)}var a=t.authenticatedAttributes||[];if(a.length>0){var f=!1,l=!1;for(var c=0;c<a.length;++c){var h=a[c];if(!f&&h.type===e.pki.oids.contentType){f=!0;if(l)break;continue}if(!l&&h.type===e.pki.oids.messageDigest){l=!0;if(f)break;continue}}if(!f||!l)throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.")}r.signers.push({key:o,version:1,issuer:n,serialNumber:i,digestAlgorithm:u,signatureAlgorithm:e.pki.oids.rsaEncryption,signature:null,authenticatedAttributes:a,unauthenticatedAttributes:[]})},sign:function(){if(typeof r.content!="object"||r.contentInfo===null){r.contentInfo=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes())]);if("content"in r){var n;r.content instanceof e.util.ByteBuffer?n=r.content.bytes():typeof r.content=="string"&&(n=e.util.encodeUtf8(r.content)),r.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n)]))}}if(r.signers.length===0)return;var o=i();s(o)},verify:function(){throw new Error("PKCS#7 signature verification not yet implemented.")},addCertificate:function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t)),r.certificates.push(t)},addCertificateRevokationList:function(e){throw new Error("PKCS#7 CRL support not yet implemented.")}},r},n.createEncryptedData=function(){var t=null;return t={type:e.pki.oids.encryptedData,version:0,encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){p(t,e,n.asn1.encryptedDataValidator)},decrypt:function(e){e!==undefined&&(t.encryptedContent.key=e),d(t)}},t},n.createEnvelopedData=function(){var r=null;return r={type:e.pki.oids.envelopedData,version:0,recipients:[],encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){var t=p(r,e,n.asn1.envelopedDataValidator);r.recipients=s(t.recipientInfos.value)},toAsn1:function(){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,o(r.recipients)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,h(r.encryptedContent))])])])},findRecipient:function(e){var t=e.issuer.attributes;for(var n=0;n<r.recipients.length;++n){var i=r.recipients[n],s=i.issuer;if(i.serialNumber!==e.serialNumber)continue;if(s.length!==t.length)continue;var o=!0;for(var u=0;u<t.length;++u)if(s[u].type!==t[u].type||s[u].value!==t[u].value){o=!1;break}if(o)return i}return null},decrypt:function(t,n){if(r.encryptedContent.key===undefined&&t!==undefined&&n!==undefined)switch(t.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:case e.pki.oids.desCBC:var i=n.decrypt(t.encryptedContent.content);r.encryptedContent.key=e.util.createBuffer(i);break;default:throw new Error("Unsupported asymmetric cipher, OID "+t.encryptedContent.algorithm)}d(r)},addRecipient:function(t){r.recipients.push({version:0,issuer:t.issuer.attributes,serialNumber:t.serialNumber,encryptedContent:{algorithm:e.pki.oids.rsaEncryption,key:t.publicKey}})},encrypt:function(t,n){if(r.encryptedContent.content===undefined){n=n||r.encryptedContent.algorithm,t=t||r.encryptedContent.key;var i,s,o;switch(n){case e.pki.oids["aes128-CBC"]:i=16,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes192-CBC"]:i=24,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes256-CBC"]:i=32,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["des-EDE3-CBC"]:i=24,s=8,o=e.des.createEncryptionCipher;break;default:throw new Error("Unsupported symmetric cipher, OID "+n)}if(t===undefined)t=e.util.createBuffer(e.random.getBytes(i));else if(t.length()!=i)throw new Error("Symmetric key has wrong length; got "+t.length()+" bytes, expected "+i+".");r.encryptedContent.algorithm=n,r.encryptedContent.key=t,r.encryptedContent.parameter=e.util.createBuffer(e.random.getBytes(s));var u=o(t);u.start(r.encryptedContent.parameter.copy()),u.update(r.content);if(!u.finish())throw new Error("Symmetric encryption failed.");r.encryptedContent.content=u.output}for(var a=0;a<r.recipients.length;++a){var f=r.recipients[a];if(f.encryptedContent.content!==undefined)continue;switch(f.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:f.encryptedContent.content=f.encryptedContent.key.encrypt(r.encryptedContent.key.data);break;default:throw new Error("Unsupported asymmetric cipher, OID "+f.encryptedContent.algorithm)}}}},r}}var r="pkcs7";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7",["require","module","./aes","./asn1","./des","./oids","./pem","./pkcs7asn1","./random","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(t,n){var r=n.toString(16);r[0]>="8"&&(r="00"+r);var i=e.util.hexToBytes(r);t.putInt32(i.length),t.putBytes(i)}function r(e,t){e.putInt32(t.length),e.putString(t)}function i(){var t=e.md.sha1.create(),n=arguments.length;for(var r=0;r<n;++r)t.update(arguments[r]);return t.digest()}var t=e.ssh=e.ssh||{};t.privateKeyToPutty=function(t,s,o){o=o||"",s=s||"";var u="ssh-rsa",a=s===""?"none":"aes256-cbc",f="PuTTY-User-Key-File-2: "+u+"\r\n";f+="Encryption: "+a+"\r\n",f+="Comment: "+o+"\r\n";var l=e.util.createBuffer();r(l,u),n(l,t.e),n(l,t.n);var c=e.util.encode64(l.bytes(),64),h=Math.floor(c.length/66)+1;f+="Public-Lines: "+h+"\r\n",f+=c;var p=e.util.createBuffer();n(p,t.d),n(p,t.p),n(p,t.q),n(p,t.qInv);var d;if(!s)d=e.util.encode64(p.bytes(),64);else{var v=p.length()+16-1;v-=v%16;var m=i(p.bytes());m.truncate(m.length()-v+p.length()),p.putBuffer(m);var g=e.util.createBuffer();g.putBuffer(i("\0\0\0\0",s)),g.putBuffer(i("\0\0\0",s));var y=e.aes.createEncryptionCipher(g.truncate(8),"CBC");y.start(e.util.createBuffer().fillWithByte(0,16)),y.update(p.copy()),y.finish();var b=y.output;b.truncate(16),d=e.util.encode64(b.bytes(),64)}h=Math.floor(d.length/66)+1,f+="\r\nPrivate-Lines: "+h+"\r\n",f+=d;var w=i("putty-private-key-file-mac-key",s),E=e.util.createBuffer();r(E,u),r(E,a),r(E,o),E.putInt32(l.length()),E.putBuffer(l),E.putInt32(p.length()),E.putBuffer(p);var S=e.hmac.create();return S.start("sha1",w),S.update(E.bytes()),f+="\r\nPrivate-MAC: "+S.digest().toHex()+"\r\n",f},t.publicKeyToOpenSSH=function(t,i){var s="ssh-rsa";i=i||"";var o=e.util.createBuffer();return r(o,s),n(o,t.e),n(o,t.n),s+" "+e.util.encode64(o.bytes())+" "+i},t.privateKeyToOpenSSH=function(t,n){return n?e.pki.encryptRsaPrivateKey(t,n,{legacy:!0,algorithm:"aes128"}):e.pki.privateKeyToPem(t)},t.getPublicKeyFingerprint=function(t,i){i=i||{};var s=i.md||e.md.md5.create(),o="ssh-rsa",u=e.util.createBuffer();r(u,o),n(u,t.e),n(u,t.n),s.start(),s.update(u.getBytes());var a=s.digest();if(i.encoding==="hex"){var f=a.toHex();return i.delimiter?f.match(/.{2}/g).join(i.delimiter):f}if(i.encoding==="binary")return a.getBytes();if(i.encoding)throw new Error('Unknown encoding "'+i.encoding+'".');return a}}var r="ssh";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/ssh",["require","module","./aes","./hmac","./md5","./sha1","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t="forge.task",n=0,r={},i=0;e.debug.set(t,"tasks",r);var s={};e.debug.set(t,"queues",s);var o="?",u=30,a=20,f="ready",l="running",c="blocked",h="sleeping",p="done",d="error",v="stop",m="start",g="block",y="unblock",b="sleep",w="wakeup",E="cancel",S="fail",x={};x[f]={},x[f][v]=f,x[f][m]=l,x[f][E]=p,x[f][S]=d,x[l]={},x[l][v]=f,x[l][m]=l,x[l][g]=c,x[l][y]=l,x[l][b]=h,x[l][w]=l,x[l][E]=p,x[l][S]=d,x[c]={},x[c][v]=c,x[c][m]=c,x[c][g]=c,x[c][y]=c,x[c][b]=c,x[c][w]=c,x[c][E]=p,x[c][S]=d,x[h]={},x[h][v]=h,x[h][m]=h,x[h][g]=h,x[h][y]=h,x[h][b]=h,x[h][w]=h,x[h][E]=p,x[h][S]=d,x[p]={},x[p][v]=p,x[p][m]=p,x[p][g]=p,x[p][y]=p,x[p][b]=p,x[p][w]=p,x[p][E]=p,x[p][S]=d,x[d]={},x[d][v]=d,x[d][m]=d,x[d][g]=d,x[d][y]=d,x[d][b]=d,x[d][w]=d,x[d][E]=d,x[d][S]=d;var T=function(s){this.id=-1,this.name=s.name||o,this.parent=s.parent||null,this.run=s.run,this.subtasks=[],this.error=!1,this.state=f,this.blocks=0,this.timeoutId=null,this.swapTime=null,this.userData=null,this.id=i++,r[this.id]=this,n>=1&&e.log.verbose(t,"[%s][%s] init",this.id,this.name,this)};T.prototype.debug=function(n){n=n||"",e.log.debug(t,n,"[%s][%s] task:",this.id,this.name,this,"subtasks:",this.subtasks.length,"queue:",s)},T.prototype.next=function(e,t){typeof e=="function"&&(t=e,e=this.name);var n=new T({run:t,name:e,parent:this});return n.state=l,n.type=this.type,n.successCallback=this.successCallback||null,n.failureCallback=this.failureCallback||null,this.subtasks.push(n),this},T.prototype.parallel=function(t,n){return e.util.isArray(t)&&(n=t,t=this.name),this.next(t,function(r){var i=r;i.block(n.length);var s=function(t,r){e.task.start({type:t,run:function(e){n[r](e)},success:function(e){i.unblock()},failure:function(e){i.unblock()}})};for(var o=0;o<n.length;o++){var u=t+"__parallel-"+r.id+"-"+o,a=o;s(u,a)}})},T.prototype.stop=function(){this.state=x[this.state][v]},T.prototype.start=function(){this.error=!1,this.state=x[this.state][m],this.state===l&&(this.start=new Date,this.run(this),C(this,0))},T.prototype.block=function(e){e=typeof e=="undefined"?1:e,this.blocks+=e,this.blocks>0&&(this.state=x[this.state][g])},T.prototype.unblock=function(e){return e=typeof e=="undefined"?1:e,this.blocks-=e,this.blocks===0&&this.state!==p&&(this.state=l,C(this,0)),this.blocks},T.prototype.sleep=function(e){e=typeof e=="undefined"?0:e,this.state=x[this.state][b];var t=this;this.timeoutId=setTimeout(function(){t.timeoutId=null,t.state=l,C(t,0)},e)},T.prototype.wait=function(e){e.wait(this)},T.prototype.wakeup=function(){this.state===h&&(cancelTimeout(this.timeoutId),this.timeoutId=null,this.state=l,C(this,0))},T.prototype.cancel=function(){this.state=x[this.state][E],this.permitsNeeded=0,this.timeoutId!==null&&(cancelTimeout(this.timeoutId),this.timeoutId=null),this.subtasks=[]},T.prototype.fail=function(e){this.error=!0,k(this,!0);if(e)e.error=this.error,e.swapTime=this.swapTime,e.userData=this.userData,C(e,0);else{if(this.parent!==null){var t=this.parent;while(t.parent!==null)t.error=this.error,t.swapTime=this.swapTime,t.userData=this.userData,t=t.parent;k(t,!0)}this.failureCallback&&this.failureCallback(this)}};var N=function(e){e.error=!1,e.state=x[e.state][m],setTimeout(function(){e.state===l&&(e.swapTime=+(new Date),e.run(e),C(e,0))},0)},C=function(e,t){var n=t>u||+(new Date)-e.swapTime>a,r=function(t){t++;if(e.state===l){n&&(e.swapTime=+(new Date));if(e.subtasks.length>0){var r=e.subtasks.shift();r.error=e.error,r.swapTime=e.swapTime,r.userData=e.userData,r.run(r),r.error||C(r,t)}else k(e),e.error||e.parent!==null&&(e.parent.error=e.error,e.parent.swapTime=e.swapTime,e.parent.userData=e.userData,C(e.parent,t))}};n?setTimeout(r,0):r(t)},k=function(i,o){i.state=p,delete r[i.id],n>=1&&e.log.verbose(t,"[%s][%s] finish",i.id,i.name,i),i.parent===null&&(i.type in s?s[i.type].length===0?e.log.error(t,"[%s][%s] task queue empty [%s]",i.id,i.name,i.type):s[i.type][0]!==i?e.log.error(t,"[%s][%s] task not first in queue [%s]",i.id,i.name,i.type):(s[i.type].shift(),s[i.type].length===0?(n>=1&&e.log.verbose(t,"[%s][%s] delete queue [%s]",i.id,i.name,i.type),delete s[i.type]):(n>=1&&e.log.verbose(t,"[%s][%s] queue start next [%s] remain:%s",i.id,i.name,i.type,s[i.type].length),s[i.type][0].start())):e.log.error(t,"[%s][%s] task queue missing [%s]",i.id,i.name,i.type),o||(i.error&&i.failureCallback?i.failureCallback(i):!i.error&&i.successCallback&&i.successCallback(i)))};e.task=e.task||{},e.task.start=function(r){var i=new T({run:r.run,name:r.name||o});i.type=r.type,i.successCallback=r.success||null,i.failureCallback=r.failure||null,i.type in s?s[r.type].push(i):(n>=1&&e.log.verbose(t,"[%s][%s] create queue [%s]",i.id,i.name,i.type),s[i.type]=[i],N(i))},e.task.cancel=function(e){e in s&&(s[e]=[s[e][0]])},e.task.createCondition=function(){var e={tasks:{}};return e.wait=function(t){t.id in e.tasks||(t.block(),e.tasks[t.id]=t)},e.notify=function(){var t=e.tasks;e.tasks={};for(var n in t)t[n].unblock()},e}}var r="task";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/task",["require","module","./debug","./log","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){var e="forge";if(typeof n!="function"){if(typeof module!="object"||!module.exports){typeof forge=="undefined"&&(forge={disableNativeCode:!1});return}var r=!0;n=function(e,n){n(t,module)}}var i,s=function(t,n){n.exports=function(n){var r=i.map(function(e){return t(e)});n=n||{},n.defined=n.defined||{};if(n.defined[e])return n[e];n.defined[e]=!0;for(var s=0;s<r.length;++s)r[s](n);return n},n.exports.disableNativeCode=!1,n.exports(n.exports)},o=n;n=function(e,t){return i=typeof e=="string"?t.slice(2):e.slice(2),r?(delete n,o.apply(null,Array.prototype.slice.call(arguments,0))):(n=o,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/forge",["require","module","./aes","./aesCipherSuites","./asn1","./cipher","./cipherModes","./debug","./des","./hmac","./kem","./log","./md","./mgf1","./pbkdf2","./pem","./pkcs7","./pkcs1","./pkcs12","./pki","./prime","./prng","./pss","./random","./rc2","./ssh","./task","./tls","./util"],function(){s.apply(null,Array.prototype.slice.call(arguments,0))})}(),t("js/forge")});
CM.MapFeatureType = {
  Line: 0,
  Polygon: 1,
  Point: 2
};

CM.LabelPlacementMethod = {
  Straight: 0,
  Path: 1
};
/**
 * Created by edwardkimmel on 8/13/15.
 */

var CM = CM || {};
CM.Console = {};

CM.Console.info = function (message) {
  if (CM.Conf.loggingEnabled) {
    console.info(message);
  }
};

CM.Console.warn = function (message) {
  if (CM.Conf.loggingEnabled) {
    console.warn(message);
  }
};

CM.Console.error = function (message) {
  if (CM.Conf.loggingEnabled) {
    console.error(message);
  }
};

CM.Console.log = function (message) {
  if (CM.Conf.loggingEnabled) {
    console.log(message);
  }
};
CM.WorkerBuilder = {
  build: function (url, callback, count) {
    if (CM.Conf.remoteWorkers) {

      var response;

      var count = count || 1;

      if (self.Blob) {
        var req = new XMLHttpRequest();
        req.open("GET", url, true);
        req.onreadystatechange = function () {
          if (req.readyState == 4 && req.status == 200) {
            response = req.responseText;

            var blob;
            try {
              blob = new Blob([response], {type: 'application/javascript'});
            } catch (e) { // Backwards-compatibility
              window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
              blob = new BlobBuilder();
              blob.append(response);
              blob = blob.getBlob();
            }

            var blobUrl = URL.createObjectURL(blob);

            var workers = [];
            for (var i = 0; i < count; i++) {
              workers.push(new Worker(blobUrl));
            }

            callback(workers);
          }
        };
        req.send();
      } else {
        // If Blobs are not supported, then workers probably aren't either, and we'll just use the fallback worker most likely in this case.
        var workers = [];
        for (var i = 0; i < count; i++) {
          workers.push(new Worker(url));
        }

        callback(workers);
      }

    } else {
      var workers = [];
      for (var i = 0; i < count; i++) {
        workers.push(new Worker(url));
      }

      callback(workers);
    }
  }
}
CM.TypedBufferInputStream = function(buffer, offset, size){
  this._buffer = buffer;
  this._offset = offset;
  this._size = size;
  this._cursorBytes = 0;
  this._dataView = new DataView(buffer, offset, size);
};

CM.TypedBufferInputStream.prototype.getUint8 = function() {
  return this._dataView.getUint8(this._cursorBytes++);
};

CM.TypedBufferInputStream.prototype.getInt8 = function() {
  return this._dataView.getInt8(this._cursorBytes++);
};

CM.TypedBufferInputStream.prototype.getUint16 = function(littleEndian) {
  var ret = this._dataView.getUint16(this._cursorBytes, littleEndian);
  this._cursorBytes += 2;
  return ret;
};

CM.TypedBufferInputStream.prototype.getInt16 = function(littleEndian) {
  var ret = this._dataView.getInt16(this._cursorBytes, littleEndian);
  this._cursorBytes += 2;
  return ret;
};

CM.TypedBufferInputStream.prototype.getUint32 = function(littleEndian) {
  var ret = this._dataView.getUint32(this._cursorBytes, littleEndian);
  this._cursorBytes += 4;
  return ret;
};

CM.TypedBufferInputStream.prototype.getInt32 = function(littleEndian) {
  var ret = this._dataView.getInt32(this._cursorBytes, littleEndian);
  this._cursorBytes += 4;
  return ret;
};

CM.TypedBufferInputStream.prototype.getFloat32 = function(littleEndian) {
  var ret = this._dataView.getFloat32(this._cursorBytes, littleEndian);
  this._cursorBytes += 4;
  return ret;
};

CM.TypedBufferInputStream.prototype.getFloat64 = function(littleEndian) {
  var ret = this._dataView.getFloat64(this._cursorBytes, littleEndian);
  this._cursorBytes += 8;
  return ret;
};

CM.TypedBufferInputStream.prototype.getUtf8String = function(byteLength) {
  var out, i, len, c;
  var char2, char3;

  out = "";
  len = byteLength;
  i = 0;
  while(i < byteLength) {
    c = this.getUint8();
    i++;

    switch(c >> 4)
    {
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
      // 0xxxxxxx
      out += String.fromCharCode(c);
      break;
      case 12: case 13:
      // 110x xxxx   10xx xxxx
      char2 = this.getUint8();
      i++;
      out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
      break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = this.getUint8();
        i++;
        char3 = this.getUint8();
        i++;
        out += String.fromCharCode(((c & 0x0F) << 12) |
          ((char2 & 0x3F) << 6) |
          ((char3 & 0x3F) << 0));
        break;
    }
  }

  return out;
};

CM.TypedBufferInputStream.prototype.getUtf16String = function(byteLength) {
  var string = '';
  var shortLength = byteLength / 2;
  for (var i = 0; i < shortLength; i++) {
    string += String.fromCharCode(this.getUint16());
  }
  return string;
};
oneOver180 = 1.0 / 180.0;
piOver360 = Math.PI / 360.0;
piOver180 = Math.PI / 180.0;
oneOverPiOver180 = 1.0 / piOver180;
one80OverPi = 180.0 / Math.PI;

CM.GeoUtils = {
  //MERCATOR_WORLD_BOUNDS: new L.Bounds(new L.Point(-20037508.34, -20037508.34), new L.Point(20037508.34, 20037508.34)),

  MERCATOR_WORLD_WIDTH: 40075016.68,
  MERCATOR_WORLD_HEIGHT: 40075016.68,

  HALF_MERCATOR_WORLD_WIDTH: 20037508.34,
  HALF_MERCATOR_WORLD_HEIGHT: 20037508.34,

  WORLD_RESOLUTION: 156543.03390625,

  WORLD_RADIUS: 6373.0,

  DOTS_PER_INCH: 72.0,

  METERS_PER_MILE: 1609.344,

  INCHES_PER_METER: 39.3701,

  getResolutionForZoom: function (zoom) {
    return CM.GeoUtils.WORLD_RESOLUTION / Math.pow(2, zoom);
  },

  getZoomForResolution: function (resolution) {
    return Math.log(CM.GeoUtils.WORLD_RESOLUTION / resolution) / Math.LN2;
  },

  getBearing: function (p1, p2) {
    /*var dlon = glm::radians(p2.x - p1.x);
     var lat1 = glm::radians(p1.y);
     var lat2 = glm::radians(p2.y);

     double theta = atan2(sin(dlon) * cos(lat2), (cos(lat1) * sin(lat2)) - (sin(lat1) * cos(lat2) * cos(dlon)));
     return glm::degrees(theta);*/
  },

  latLngToMerc: function (point) {
    // half merc / 180
    var newX = point.x * 111319.490778;
    var newY = Math.log(Math.tan((90.0 + point.y) * piOver360)) * oneOverPiOver180;
    newY *= 111319.490778;
    return {
      x: newX,
      y: newY
    };
  },

  latLngToMercOut: function (point, out) {
    out.x = point.x * 111319.490778;
    out.y = Math.log(Math.tan((90.0 + point.y) * piOver360)) * oneOverPiOver180 * 111319.490778;
  },

  mercToLatLng: function (point) {
    var lon = (point.x * 180.0) / 20037508.34;
    var lat = (point.y * 180.0) / 20037508.34;

    lat = (Math.atan(Math.exp(lat * (Math.PI / 180.0))) / (Math.PI / 360.0)) - 90.0;
    return {
      x: lon,
      y: lat
    };
  },

  /**
   @param {point} p1
   @static
   */
  normalize: function (p1) {
    var length = Math.sqrt(p1.x * p1.x + p1.y * p1.y);
    if (length > 0) {
      var oneOverLength = 1. / length;
      p1.x *= oneOverLength;
      p1.y *= oneOverLength;
    }
  },

  /**
   @param {point} p1
   @param {point} out
   @static
   */
  normalizeOut: function (p1, out) {
    var length = Math.sqrt(p1.x * p1.x + p1.y * p1.y);
    if (length > 0) {
      var oneOverLength = 1. / length;
      out.x = p1.x * oneOverLength;
      out.y = p1.y * oneOverLength;
    }
  },

  /**
   @param {array} p1
   @static
   */
  normalizeArray: function (p1) {
    var length = Math.sqrt(p1[0] * p1[0] + p1[1] * p1[1]);
    if (length > 0) {
      var oneOverLength = 1. / length;
      p1[0] = p1[0] * oneOverLength;
      p1[1] = p1[1] * oneOverLength;
    }
  },

  /**
   @param {array} p1
   @param {array} out
   @static
   */
  normalizeArrayOut: function (p1, out) {
    var length = Math.sqrt(p1[0] * p1[0] + p1[1] * p1[1]);
    if (length > 0) {
      var oneOverLength = 1. / length;
      out[0] = p1[0] * oneOverLength;
      out[1] = p1[1] * oneOverLength;
    }
  },

  /**
   * @param {point} p1
   * @param {point} p2
   * @static
   * @return {point}
   */
  perpendicular: function (p1, p2) {
    return new L.Point(-(p2.y - p1.y), p2.x - p1.x);
  },

  /**
   * @param {point} p1
   * @param {point} p2
   * @param {point} perp
   * @static
   * @return {void}
   */
  perpendicularOut: function (p1, p2, perp) {
    perp.x = -(p2.y - p1.y);
    perp.y = p2.x - p1.x;
  },

  /**
   * @param {array} p1
   * @param {array} p2
   * @param {array} perp
   * @static
   * @return {void}
   */
  perpendicularArrayOut: function (p1, p2, perp) {
    perp[0] = -(p2[1] - p1[1]);
    perp[1] = p2[0] - p1[0];
  },

  distance: function (p1, p2) {
    var dx = (p2.x - p1.x);
    var dy = (p2.y - p1.y);

    return Math.sqrt((dx * dx) + (dy * dy));
  },

  angleBetweenPoints: function (p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    if (dx == 0 && dy == 0) {
      return 0.0;
    }
    else {
      return Math.atan2(dy, dx);
    }
  },

  clampAngle: function (angle) {
    if (angle < 0) {
      return (angle % 360) + 360;
    } else {
      return (angle % 360);
    }
  },

  rotatePoint: function (point, angle, origin) {
    var transPoint = point;
    if (origin) {
      transPoint = new L.Point(point.x - origin.x, point.y - origin.y);
    }

    var cos = Math.cos(angle);
    var sin = Math.sin(angle);

    var px = ((transPoint.x * cos) - (transPoint.y * sin));
    var py = ((transPoint.x * sin) + (transPoint.y * cos));

    var rotated = new L.Point(px, py);
    if (origin) {
      rotated = rotated.add(origin);
    }

    return rotated;
  },

  degressToRadians: function(deg) {
    return deg * piOver180
  }

};

if (L) {
  L.Point.prototype.multiply = function(point) {
    return new L.Point(point.x * this.x, point.y * this.y);
  }
}
CM.Network = {
  Request: L.Class.extend({
    url: null,
    options: null,
    status: 0,
    _priority: 100,
    abort: function () {
      CM.Network.cancel(this);
    },
    _networkRequest: null,
  }),
  maxRequests: 15,
  cache: {},
  networkQueue: null,
  cancelledRequests: [],
  activeRequests: [],

  send: function (url, options) {
    options = options || {};

    if (!this.networkQueue) {
      var networkQueueOptions = {
        comparitor: function (a, b) {
          return a._priority - b._priority;
        }
      };
      this.networkQueue = new PriorityQueue(networkQueueOptions);
    }

    if (!options.force && CM.Network.cache[url]) {
      var req = CM.Network.cache[url];

      if (options.success) {
        options.success(req._networkRequest.response, req.status.toString(), req);
      }
      return;
    }

    var req = new CM.Network.Request();
    req.url = url;
    req.options = options;
    req._priority = options.priority || 100;

    this.networkQueue.queue(req);

    if (this.maxRequests > this.activeRequests.length) {
      this._sendNextRequest();
    }
    return req;
  },

  cancel: function (req) {
    var t = this;

    if (t._removeActiveRequest(req)) {

    }
    var index = t.activeRequests.indexOf(req);
    if (index != -1) {
      // Found it in active requests
      req._networkRequest.abort();
    } else {
      // Not found there.
      t.cancelledRequests.push(req);
    }
  },

  _removeActiveRequest: function (req) {
    var t = this;

    var index = t.activeRequests.indexOf(req);
    if (index != -1) {
      t.activeRequests[index] = t.activeRequests[t.activeRequests.length - 1];
      t.activeRequests.pop();
      return true;
    }
    return false;
  },

  _removeCancelledRequest: function (req) {
    var t = this;

    var index = t.cancelledRequests.indexOf(req);
    if (index != -1) {
      t.cancelledRequests[index] = t.cancelledRequests[t.cancelledRequests.length - 1];
      t.cancelledRequests.pop();
      return true;
    }
    return false;
  },

  _sendNextRequest: function () {
    if (this.networkQueue.length > 0) {
      var req = this.networkQueue.dequeue();
      this._send(req);
    }
  },

  _send: function (requestWrapper) {
    var t = this;
    var options = requestWrapper.options;
    var url = requestWrapper.url;

    if (t._removeCancelledRequest(requestWrapper)) {
      // This has been cancelled.
      requestWrapper.status = 0;
      if (options.error) {
        options.error(requestWrapper);
      }
      t._sendNextRequest();
      return;
    }

    t.activeRequests.push(requestWrapper);

    var method = options.method || "GET";
    var data = options.data || null;
    var req;

    if (window.XDomainRequest) {
      req = new XDomainRequest();
      req.open(method, url);
      req.onload = function () {
        if (options.success) {
          requestWrapper.status = 200;
          options.success(req.responseText, "200", requestWrapper);
        }
        t._removeActiveRequest(requestWrapper);
        t._sendNextRequest();
      };
      req.onerror = function () {
        if (options.error) {
          requestWrapper.status = req.status;
          options.error(requestWrapper);
        }
        t._removeActiveRequest(requestWrapper);
        t._sendNextRequest();
      };
      req.send();
    } else {
      req = new XMLHttpRequest();
      req.open(method, url);
      if (options.auth) {
        req.setRequestHeader("Authorization", "Basic " + btoa(options.auth.username + ":" + options.auth.password));
      }

      req.onreadystatechange = function () {
        if (req.readyState == 4) {
          requestWrapper.status = req.status;

          if (req.status == 200) {
            if (options.cache === false) {
              CM.Network.cache[url] = requestWrapper;
            }

            if (options.success) {
              options.success(req.response, req.status.toString(), requestWrapper);
            }
          } else {
            if (options.error) {
              options.error(requestWrapper);
            }
          }
          t._removeActiveRequest(requestWrapper);
          t._sendNextRequest();
        }
      };

      if (options.responseType) {
        req.responseType = options.responseType;
      }
      req.send(data);
    }
    requestWrapper._networkRequest = req;
  },

  loadImage: function (url, options) {
    options = options || {};

    return new Promise(function (resolver) {
      var image = new Image();
      image.crossOrigin = 'anonymous';

      if (!options.noscale) {
        url = CM.Network.getScaledImageURL(url);
      }

      image.src = url;
      image.onload = function () {
        resolver(image);
      };

      image.onerror = function () {
        resolver(null);
      };
    });
  },

  getScaledImageDpr: function () {
    return Math.ceil(CM.Conf.devicePixelRatio || 1);
  },

  getScaledImageURL: function (url) {
    var i = url.lastIndexOf('.');
    var dpr = Math.ceil(CM.Conf.devicePixelRatio || 1);

    if (dpr > 1) {
      var base = url.substring(0, i);
      var ext = url.substring(i + 1);

      url = base + "@" + dpr + "x." + ext;
    }

    return url;
  }
};
CM.NetworkQueue = L.Class.extend({
  maxRequests: 15,
  cache: {},
  networkQueue: null,
  cancelledRequests: [],
  activeRequests: [],

  initialize: function(maxRequests) {
    this.maxRequests = maxRequests || 15;
    var networkQueueOptions = {
      comparitor: function (a, b) {
        return a._priority - b._priority;
      }
    };
    this.networkQueue = new PriorityQueue(networkQueueOptions);
  },

  send: function (url, options) {
    options = options || {};

    var req = new CM.NetworkQueue.Request(this);
    req.url = url;
    req.options = options;
    req._priority = options.priority || 100;

    this.networkQueue.queue(req);

    if (this.maxRequests > this.activeRequests.length) {
      this._sendNextRequest();
    }
    return req;
  },

  cancel: function (req) {
    var t = this;
    var index = t.activeRequests.indexOf(req);
    if (index != -1) {
      CM.Network.cancel(req.request);
      t._removeActiveRequest(req);
    } else {
      // Not found there.
      t.cancelledRequests.push(req);
    }
  },

  _removeActiveRequest: function (req) {
    var t = this;

    var index = t.activeRequests.indexOf(req);
    if (index != -1) {
      t.activeRequests[index] = t.activeRequests[t.activeRequests.length - 1];
      t.activeRequests.pop();
      return true;
    }
    return false;
  },

  _removeCancelledRequest: function (req) {
    var t = this;

    var index = t.cancelledRequests.indexOf(req);
    if (index != -1) {
      t.cancelledRequests[index] = t.cancelledRequests[t.cancelledRequests.length - 1];
      t.cancelledRequests.pop();
      return true;
    }
    return false;
  },

  _sendNextRequest: function () {
    if (this.networkQueue.length > 0) {
      var req = this.networkQueue.dequeue();
      this._send(req);
    }
  },

  _send: function (requestWrapper) {
    var t = this;
    var options = requestWrapper.options;
    var url = requestWrapper.url;

    if (t._removeCancelledRequest(requestWrapper) || (options.continueSend && !options.continueSend())) {
      // This has been cancelled.
      requestWrapper.status = 0;
      if (options.error) {
        options.error(requestWrapper);
      }
      t._sendNextRequest();
      return;
    }

    t.activeRequests.push(requestWrapper);

    requestWrapper.request = CM.Network.send(url, L.extend({}, options, {
      success: function(data, status, req) {
        if (options.success) {
          requestWrapper.status = status;
          options.success(data, status, requestWrapper);
        }
        t._removeActiveRequest(requestWrapper);
        t._sendNextRequest();
      },
      error: function(req) {
        if (options.error) {
          requestWrapper.status = req.status;
          options.error(requestWrapper);
        }
        t._removeActiveRequest(requestWrapper);
        t._sendNextRequest();
      }
    }));
  }
});

CM.NetworkQueue.Request = L.Class.extend({
  url: null,
  options: null,
  status: 0,
  _priority: 100,
  initialize: function(queue) {
    this.networkQueue = queue;
  },
  abort: function () {
    this.networkQueue.cancel(this);
  }
});

CM.PerfTimer = L.Class.extend({
  start: function () {
    this._events = [];

    this.addEvent("Start");
  },

  end: function () {
    this.addEvent("end");
  },

  addEvent: function (name) {
    var time = window.performance ? window.performance.now() : new Date().getTime();

    this._events.push({
      name: name,
      time: time
    });
  },

  print: function (minTime) {
    minTime = minTime || 0;
    for (var i = 1; i < this._events.length; i++) {
      var event = this._events[i];
      var timeSinceLast = event.time - this._events[i - 1].time;
      var timeSinceStart = event.time - this._events[0].time;

      if (timeSinceLast > minTime) {
        CM.Console.log(event.name + " Time Since Start: " + timeSinceStart + ", Time Since Last: " + timeSinceLast);
      }

    }

  }
});
CM.StringUtil = {
  toArrayBuffer: function (str) {
    var buffer = new ArrayBuffer(str.length * 2);
    var view = new Uint16Array(buffer);
    for (var i = 0; i < str.length; i++) {
      view[i] = str.charCodeAt(i);
    }
    return buffer;
  },

  fromArrayBuffer: function (buffer) {
    var view = new Uint16Array(buffer);
    var arr = new Array(view.length);
    for (var i = 0; i < view.length; i++) {
      arr[i] = String.fromCharCode(view[i]);
    }

    //return String.fromCharCode.apply(null, arr);
    return arr.join("");
  },

  URLSafeBase64Encode: function (str) {
    return btoa(str)
      .replace(/=/g, '_')
      .replace(/\//g, '~')
      .replace(/\+/g, '-');
  },

  URLSafeBase64Decode: function (str) {
    //eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly90aWxlLmNpdHltYXBzLmNvbS92ZW51ZS8qIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNDQ1OTkwNTIwfX19XX0_
    return CM.StringUtil.base64toBlob(str.replace('-', '+').replace('~', '/').replace('_', '='));
  },

  base64toBlob: function(base64Data, contentType) {
    contentType = contentType || '';
    var sliceSize = 1024;
    console.log('base 64 data:' + base64Data);
    var byteCharacters = atob(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);

    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
      var begin = sliceIndex * sliceSize;
      var end = Math.min(begin + sliceSize, bytesLength);

      var bytes = new Array(end - begin);
      for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {
        bytes[i] = byteCharacters[offset].charCodeAt(0);
      }
      byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
  },


  SHA1Hash: function (str) {
    var md = forge.md.sha1.create();
    md.update(str);
    return CM.StringUtil.URLSafeBase64Encode(md.digest().toHex());
  },

  getString: function (key, dict, options) {
    var obj = dict[key];
    var locale = options.locale || "_";
    var str = obj[locale] || obj["_"];
    if (options.count && str.plural) {
      var count = options.count;
      if (count == 1) {
        return str.plural.one;
      } else {
        return str.plural.many;
      }
    } else {
      return str.value;
    }
  },

  _componentToHex: function (c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  },

  rgbToHex: function (r, g, b) {
    return "#" + this._componentToHex(Math.round(r * 255)) + this._componentToHex(Math.round(g * 255)) + this._componentToHex(Math.round(b * 255));
  },

  // Returns a vec4 from a hex string
  rgbaFromHex: function (hex, alpha) {
    alpha = alpha || 1;

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) {
      return null;
    }
    return vec4.fromValues(parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255, alpha);
  }
};

String.prototype.hashCode = function () {
  var hash = 0;
  if (this.length == 0) return hash;
  for (i = 0; i < this.length; i++) {
    char = this.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
};

String.prototype.format = function () {
  var theString = this;

  for (var i = 0; i < arguments.length; i++) {
    var regEx = new RegExp("\\{" + i + "\\}", "gm");
    theString = theString.replace(regEx, arguments[i]);
  }

  return theString;
};

/**
 * Created by edwardkimmel on 8/3/15.
 */

var CM = CM || {};
CM.Util = {
  select: function (object, props) {
    var index = -1,
      length = props.length,
      result = {};

    while (++index < length) {
      var key = props[index];
      if (key in object) {
        result[key] = object[key];
      }
    }

    return result;
  },

  hasWorkers: function () {
    return window.Worker !== undefined &&
      window.navigator.userAgent.indexOf("MSIE 10") < 0
  },

  supportsWorkers: function () {
    return CM.Util.supportsWebGL() &&
      CM.Util.hasWorkers();
  },

  supportsWebGL: function (forceRaster) {
    if (!CM.Util.supportsWebGLValue) {

      if (forceRaster) {
        CM.Util.supportsWebGLValue = false;
        return CM.Util.supportsWebGLValue;
      }

      var supportsWebGL = function () {
        var testCanvas = document.createElement("canvas");

        return testCanvas.getContext && !!(testCanvas.getContext("webgl") ||
          testCanvas.getContext("experimental-webgl"));
      };

      var isMobileBrowser = function (user_agent_header) {
        if (!(typeof user_agent_header === 'string')) {
          console.warn("Unknown user agent string passed to isMobileBrowser");
          return false;
        }
        var regex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        var regex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
        return (regex1.test(user_agent_header) || regex2.test(user_agent_header.substr(0, 4)));
      };

      var isBannedDevice = function () {
        var userAgent = window.navigator.userAgent.toLowerCase();
        // Ban iOS devices running mobile safari
        return isMobileBrowser(userAgent);
      };


      var supports = (supportsWebGL() && CM.Util.hasWorkers() && !isBannedDevice());

      if (supports) {
        var webGLBenchmark = CM.WebGLBenchmark.getValue();
        if (webGLBenchmark < 2) {
          supports = false;
        }
      }

      CM.Util.supportsWebGLValue = supports;

    }

    return CM.Util.supportsWebGLValue;
  }
};

CM.CloudfrontPathTransformer = L.Class.extend({
  initialize: function (params) {
    this._url = params.url;
    this._accessKey = params.accessKey;
    this._timeout = params.timeout;

    if (params.urlRegex) {
      try {
        this._urlRegex = new RegExp(params.urlRegex);
      } catch (e) {
        this._urlRegex = null;
      }
    }
    
    this._publicKey = forge.pki.publicKeyFromPem(params.publicKey);
    this._privateKey = forge.pki.privateKeyFromPem(params.privateKey);

    this._refreshSignature();
  },

  generatePath: function (coords, uri) {
    var now = Math.floor(new Date().getTime() / 1000);
    if (now > this._expiration) {
      this._refreshSignature();
    }

    if (this._urlRegex && !this._urlRegex.test(uri)) {
      return uri;
    }

    var qStringChar = uri.search(/\?/g) >= 0 ? '&' : '?';
    var str = uri + qStringChar + this._params;
    return str;
  },

  _refreshSignature: function () {
    var now = Math.floor(new Date().getTime() / 1000);
    this._expiration = now + this._timeout;

    var paddedTimeout = this._expiration + this._timeout;
    var statement = "{\"Statement\":[{\"Resource\":\"" + this._url + "\",\"Condition\":{\"DateLessThan\":{\"AWS:EpochTime\":" + paddedTimeout + "}}}]}";

    var md = forge.md.sha1.create();
    md.update(statement, 'utf-8');
    var signatureBytes = this._privateKey.sign(md);

    // verify data with a public key
    // (defaults to RSASSA PKCS#1 v1.5)
    var verified = this._publicKey.verify(md.digest().bytes(), signatureBytes);
    if (verified) {
      var policy = CM.StringUtil.URLSafeBase64Encode(statement);
      var signature = CM.StringUtil.URLSafeBase64Encode(signatureBytes);
      this._params = "Policy=" + policy + "&Signature=" + signature + "&Key-Pair-Id=" + this._accessKey;
    }
  }
});
CM.WebGLBenchmark = {
  getValue: function () {
    if (!window.performance) {
      return 0;
    }

    var vertexShader = 'attribute vec2 a_position;\
                \
                varying vec2 v_position;\
                \
                uniform mat4 u_mvp;\
                \
                void main()\
                {\
                    v_position = a_position;\
                    gl_Position = u_mvp * vec4(a_position, 0.0, 1.0);\
                }';

    var fragmentShader = 'precision mediump float;\
                varying vec2 v_position;\
                \
                uniform vec4 u_color;\
                \
                void main()\
                {\
                    vec4 a = gl_FragCoord;\
                    float b = 0.0;\
                    vec4 c;\
                    \
                    for (float i = 0.0; i < 3.0; i++) {\
                        b += distance(pow(3.0 + i, a.x), exp(a.y));\
                        c = vec4(pow(2.5, b), pow(exp(b), a.y), mod(a.x, cos(0.748)), distance(atan(2.4), acos(7.3)));\
                    }\
                    gl_FragColor = c;\
                }';

    var dpr = CM.Conf.devicePixelRatio;
    var canvas = document.createElement("canvas");

    var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    //document.body.appendChild(canvas);
    var width = window.outerWidth * dpr;
    var height = window.outerHeight * dpr;

    var device = new CM.GraphicsDevice(canvas, width, height);
    device.setBackgroundColor([1, 0, 0, 1]);

    var renderTarget = new CM.RenderTarget(device, width, height);

    var numTriangles = 10;
    var data = new Float32Array(numTriangles * 6);

    var idx = 0;

    for (var i = 0; i < numTriangles; i++) {
      var x = Math.random() * (width / dpr);
      var y = Math.random() * (height / dpr);
      var twidth = Math.random() * 50 + 20;
      var theight = Math.random() * 50 + 20;

      data[idx] = x;
      data[idx + 1] = y;
      data[idx + 2] = x + twidth;
      data[idx + 3] = y;
      data[idx + 4] = x;
      data[idx + 5] = y + theight;

      idx += 6;
    }
    var buffer = new CM.VertexBuffer(device, device.gl.ARRAY_BUFFER, device.gl.STATIC_DRAW);
    buffer.setData(data);

    var shaderProgram = new CM.ShaderProgram(device);
    shaderProgram.setShader(new CM.Shader(vertexShader, device.gl.VERTEX_SHADER, ["u_mvp"]));
    shaderProgram.setShader(new CM.Shader(fragmentShader, device.gl.FRAGMENT_SHADER, ["u_color"]));

    var inputLayout = new CM.InputLayout();
    inputLayout.addInputElement(device, "a_position", 2, 0, device.gl.FLOAT, false);
    shaderProgram.setInputLayout(inputLayout);

    //shaderProgram.build();


    var matrix = mat4.ortho(mat4.create(), 0, width / dpr, height / dpr, 0, -1, 1);

    var renderState = new CM.RenderState();
    renderState.projection = matrix;
    renderState.pushTransform(mat4.create());

    renderState.setShaderData("u_mvp", renderState.wvpShaderData);
    renderState.setShaderData("u_color", new CM.ShaderData(vec4.fromValues(0, 1, 0, 1), 'vec4'));

    var start, end;
    start = window.performance.now();
    var frames = 0;

    //while (end - start < 1000) {

    renderTarget.activate();

    var iters = 200;
    var elapsed = 0;


    var numFrames = 10;

    for (var i = 0; i < numFrames; i++)
      render(10000);


    end = window.performance.now();
    elapsed = end - start;

    //iters += 200;

    var fps = (1000 / (elapsed / numFrames));
    //}

    end = window.performance.now();

    renderTarget.deactivate();

    function render(iters) {
      device.clear();

      buffer.activate();

      shaderProgram.activate();
      shaderProgram.bindToVertexBuffer();

      for (var i = 0; i < shaderProgram.globalDataList.length; i++) {
        var globalData = shaderProgram.globalDataList[i];
        var shaderData = renderState.getShaderData(globalData.name);
        if (shaderData) {
          shaderProgram.setShaderData(globalData, shaderData);
        }
      }

      for (var i = 0; i < iters; i++) {
        device.gl.drawArrays(device.gl.TRIANGLES, 0, numTriangles * 3);
      }

    }

    buffer.delete();
    shaderProgram.delete();
    renderTarget.delete();
    return fps;
  }

  //getValue: function() {
  //    return new Promise(function(resolve) {
  //        var animationDuration = 500;
  //        var elapsed = 0;
  //        var frames = 0;
  //
  //        var lastFrameTime = 0;
  //
  //        var runTimer = function() {
  //            var time = window.performance.now();
  //            if (lastFrameTime == 0) {
  //                lastFrameTime = time;
  //            }
  //
  //            frames++;
  //            elapsed += time - lastFrameTime;
  //
  //            if (frames == 5) {
  //                console.log(elapsed);
  //                resolve(true);
  //            } else {
  //                requestAnimationFrame(runTimer)
  //            }
  //        };
  //
  //        requestAnimationFrame(runTimer);
  //    });
  //}

};
CM.LineTriangulator = function () {
  this._buffer = [];
  this._index = 0;
};

CM.LineTriangulator.prototype._buffer = null;
CM.LineTriangulator.prototype._index = 0;

CM.LineTriangulator.prototype._ensureCapacity = function(size){
  var length = this._buffer.length;
  for (var i = length; i < size; ++i) {
    this._buffer.push({
      p1: null, // X, Y
      p2: null,
      perp: {x: 0, y: 0}, // Normalized
      length: 0
    });
  }
};

CM.LineTriangulator.prototype.reset = function () {
  this._index = 0;
};

CM.LineTriangulator.prototype.triangulate = function (points, minSegmentLength) {
  if (!points || points.length < 1) {
    return;
  }
  // 0 ensures that we don't run in to degnerate points.
  minSegmentLength = minSegmentLength || 0;

  this._ensureCapacity(this._index + points.length - 1);
  var numPoints = points.length;
  var p1, p2, dx, dy, segmentLength = 0, bufferSegment;

  for (var i = 0; i < numPoints - 1; ++i) {
    segmentLength = 0;
    p1 = points[i];
    while (true) {
      p2 = points[i + 1];
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      segmentLength = Math.sqrt(dx * dx + dy * dy);
      if (segmentLength > minSegmentLength || i == numPoints - 2) {
        break;
      } else {
        ++i;
      }
    }
    bufferSegment = this._buffer[this._index++];
    bufferSegment.p1 = p1;
    bufferSegment.p2 = p2;
    bufferSegment.length = segmentLength;
    CM.GeoUtils.perpendicularOut(p1, p2, bufferSegment.perp);
    CM.GeoUtils.normalize(bufferSegment.perp);
  }
};

CM.LineTriangulator.prototype.data = function () {
  return this._buffer;
};

CM.LineTriangulator.prototype.length = function() {
  return this._index;
};
CM.PolylineBucket = function () {
    this.triangulator = new CM.LineTriangulator();
};

CM.PolylineBucket.prototype.offset = 0;
CM.PolylineBucket.prototype.vertexArray = null;
CM.PolylineBucket.prototype.indexArray = null;
CM.PolylineBucket.prototype.startingIndexArrayIndex = 0;
CM.PolylineBucket.prototype.indexOffset = 0;
CM.PolylineBucket.prototype.int16View = null;
CM.PolylineBucket.prototype.uint8View = null;
CM.PolylineBucket.prototype.triangulator = null;

CM.PolylineBucket.prototype._begin = function (vertexArray, indexArray) {
  this.vertexArray = vertexArray;
  this.indexArray = indexArray;
  this.startingIndexArrayIndex = 0;
  this.indexOffset = 0;
  this.offset = 0;
  this.int16View = new Int16Array(vertexArray.buffer);
  this.uint8View = new Uint8Array(vertexArray.buffer);
};

// 65535 // unit16 max
// 32767 // int16 max
// 16363
// 8191
CM.PolylineBucket.prototype._addSolidVertex = function (pos, perp, distSign, color, size) {
  var array = this.vertexArray;
  var uint8View = this.uint8View;
  var int16View = this.int16View;

  var float32Offset = this.offset;
  var uint8Offset = float32Offset * 4;
  var colorOffset = uint8Offset + 8;
  var perpOffset = float32Offset * 2 + 6;

  array[float32Offset] = pos.x;
  array[float32Offset + 1] = pos.y;
  uint8View[colorOffset] = color[0] || 0;
  uint8View[colorOffset + 1] = color[1] || 0;
  uint8View[colorOffset + 2] = color[2] || 0;
  uint8View[colorOffset + 3] = (color[3] || 0) * 255;
  int16View[perpOffset] = perp.x * 16363;
  int16View[perpOffset + 1] = perp.y * 16363;
  int16View[perpOffset + 2] = distSign * 32767;
  int16View[perpOffset + 3] = size * (32767 / 255);
  this.offset += this.vertexFloatSizeForTechnique('line_solid');
};

CM.PolylineBucket.prototype._addSolidJointVertex = function (pos, color, texX, texY, size) {
  var array = this.vertexArray;
  var uint8View = this.uint8View;
  var int16View = this.int16View;

  var float32Offset = this.offset;
  var uint8Offset = float32Offset * 4;
  var int16Offset = float32Offset * 2;
  var colorOffset = uint8Offset + 8;
  var texCoordOffset = colorOffset + 4;
  var sizeOffset = int16Offset + 7;

  array[float32Offset] = pos.x;
  array[float32Offset + 1] = pos.y;
  uint8View[colorOffset] = color[0] || 0;
  uint8View[colorOffset + 1] = color[1] || 0;
  uint8View[colorOffset + 2] = color[2] || 0;
  uint8View[colorOffset + 3] = (color[3] || 0) * 255;
  uint8View[texCoordOffset] = texX * 255;
  uint8View[texCoordOffset + 1] = texY * 255;
  int16View[sizeOffset] = size * 4;
  this.offset += this.vertexFloatSizeForTechnique('line_solid_joint');
};

CM.PolylineBucket.prototype._addPatternVertex = function (pos, perp, distSign, color, size, length, linePattern) {
  var float32Offset = this.offset;
  var uint8Offset = float32Offset * 4;
  var int16View = this.int16View;

  var colorOffset = uint8Offset + 8;
  var perpOffset = float32Offset * 2 + 6;
  var linePatternOffset = uint8Offset + 20;
  var lengthOffset = float32Offset + 6;

  var array = this.vertexArray;
  var uint8View = this.uint8View;

  array[float32Offset] = pos.x;
  array[float32Offset + 1] = pos.y;
  uint8View[colorOffset] = color[0] || 0;
  uint8View[colorOffset + 1] = color[1] || 0;
  uint8View[colorOffset + 2] = color[2] || 0;
  uint8View[colorOffset + 3] = (color[3] || 0) * 255;
  int16View[perpOffset] = perp.x * 16363;
  int16View[perpOffset + 1] = perp.y * 16363;
  int16View[perpOffset + 2] = distSign * 32767;
  int16View[perpOffset + 3] = size * (32767 / 255);
  uint8View[linePatternOffset] = linePattern[0] || 0;
  uint8View[linePatternOffset + 1] = linePattern[1] || 0;
  uint8View[linePatternOffset + 2] = linePattern[2] || 0;
  uint8View[linePatternOffset + 3] = linePattern[3] || 0;
  array[lengthOffset] = length;

  this.offset += this.vertexFloatSizeForTechnique('line_pattern');
};

CM.PolylineBucket.prototype._pushSegmentIndices = function() {
  var indexArray = this.indexArray;
  var indexArrayIndex = this.startingIndexArrayIndex;
  var nextIndex = this.indexOffset;
  indexArray[indexArrayIndex] = nextIndex;
  indexArray[indexArrayIndex + 1] = nextIndex + 2;
  indexArray[indexArrayIndex + 2] = nextIndex + 1;

  indexArray[indexArrayIndex + 3] = nextIndex + 1;
  indexArray[indexArrayIndex + 4] = nextIndex + 2;
  indexArray[indexArrayIndex + 5] = nextIndex + 3;

  this.startingIndexArrayIndex += 6;
  this.indexOffset += 4;
};

CM.PolylineBucket.prototype._triangulateLine = function(points, style, tech) {

  var color = style.get("line-color");
  var size = style.get("line-width") * 0.5;
  var pattern = style.get("line-dasharray");
  var patternLength = (pattern[0] || 0) + (pattern[1] || 0) + (pattern[2] || 0) + (pattern[3] || 0);
  var patternLengthMerc = patternLength * this.resolution;
  var minSizeBasedOnWidthMerc = size * this.resolution / 2;
  var minLength = 0;//Math.max(minSizeBasedOnWidthMerc, patternLengthMerc / 4);

  this.triangulator.reset();
  this.triangulator.triangulate(points, minLength);
  var data = this.triangulator.data();
  var count = this.triangulator.length();

  if (count > 0) {
    var lineLength = 0;
    var segment,i;
    switch(tech) {
      case 'line_solid':
        for(i = 0; i < count; ++i) {
          segment = data[i];
          this._addSolidVertex(segment.p1, segment.perp, 1, color, size, lineLength);
          this._addSolidVertex(segment.p2, segment.perp, 1, color, size, lineLength + segment.length);
          segment.perp.x = -segment.perp.x;
          segment.perp.y = -segment.perp.y;
          this._addSolidVertex(segment.p1, segment.perp, -1, color, size, lineLength);
          this._addSolidVertex(segment.p2, segment.perp, -1, color, size, lineLength + segment.length);
          lineLength += segment.length;
          this._pushSegmentIndices();
        }
        break;
      case 'line_solid_joint':
        for(i = 0; i < count; ++i) {
          segment = data[i];
          this._addSolidJointVertex(segment.p1, color, 0.0, 0.0, size);
          this._addSolidJointVertex(segment.p1, color, 1.0, 0.0, size);
          this._addSolidJointVertex(segment.p1, color, 0.0, 1.0, size);
          this._addSolidJointVertex(segment.p1, color, 1.0, 1.0, size);
          this._pushSegmentIndices();
        }
        if (count > 0) {
          segment = data[count - 1];
          this._addSolidJointVertex(segment.p2, color, 0.0, 0.0, size);
          this._addSolidJointVertex(segment.p2, color, 1.0, 0.0, size);
          this._addSolidJointVertex(segment.p2, color, 0.0, 1.0, size);
          this._addSolidJointVertex(segment.p2, color, 1.0, 1.0, size);
          this._pushSegmentIndices();
        }
        break;
      case 'line_pattern':
        for(i = 0; i < count; ++i) {
          segment = data[i];
          this._addPatternVertex(segment.p1, segment.perp, 1, color, size, lineLength, pattern);
          this._addPatternVertex(segment.p2, segment.perp, 1, color, size, lineLength + segment.length, pattern);
          segment.perp.x = -segment.perp.x;
          segment.perp.y = -segment.perp.y;
          this._addPatternVertex(segment.p1, segment.perp, -1, color, size, lineLength, pattern);
          this._addPatternVertex(segment.p2, segment.perp, -1, color, size, lineLength + segment.length, pattern);
          lineLength += segment.length;
          this._pushSegmentIndices();
        }
        break;
    }
  }
};

CM.PolylineBucket.prototype.estimateVertexCountForPointCount = function (pointCount, technique) {
  if (technique == 'line_solid_joint') {
    return 4 * pointCount;
  } else {
    return 4 * (pointCount - 1);
  }
};

CM.PolylineBucket.prototype.estimateIndexCountForPointCount = function (pointCount, technique) {
  if (technique == 'line_solid_joint') {
    return 6 * pointCount;
  } else {
    return 6 * (pointCount - 1);
  }
};

CM.PolylineBucket.prototype.vertexFloatSizeForTechnique = function (technique) {
  switch (technique) {
    case 'line_pattern':
      return 7;
      break;
    case 'line_solid_joint':
      return 4;
    case 'line_solid':
    default:
      return 5;
      break;
  }
};

CM.PolylineBucket.prototype._triangulateFeatures = function (features, technique) {
  var triangulateBatches = [];
  var currentBatch = {
    vertexCount: 0,
    indexCount: 0,
    pointCount: 0,
    features: []
  };
  triangulateBatches.push(currentBatch);

  var feature, i, j,offset;

  for (i = 0; i < features.length; ++i) {
    feature = features[i];
    var featureVertexCount = this.estimateVertexCountForPointCount(feature.points.length, technique);

    // Or == thanks to ES3's primitive restart...
    // TODO: Make this based on the actual max index size.
    if (currentBatch.vertexCount + featureVertexCount >= 65535) {
      currentBatch = {
        vertexCount: 0,
        indexCount: 0,
        pointCount: 0,
        features: []
      };
      triangulateBatches.push(currentBatch);
    }
    currentBatch.features.push(feature);
    currentBatch.pointCount += feature.points.length;
    currentBatch.vertexCount += featureVertexCount;
    currentBatch.indexCount += this.estimateIndexCountForPointCount(feature.points.length, technique);
  }

  var vertSize = this.vertexFloatSizeForTechnique(technique);
  var geometryBatches = [];

  var batchFeatures;
  for (i = 0; i < triangulateBatches.length; ++i) {
    var batch = triangulateBatches[i];
    batchFeatures = batch.features;
    var vertexArray = new Float32Array(batch.vertexCount * vertSize);
    var indexArray = new Uint16Array(batch.indexCount);

    this._begin(vertexArray, indexArray);

    for (j = 0; j < batchFeatures.length; ++j) {
      feature = batchFeatures[j];
      this._triangulateLine(feature.points, feature.style, technique);
    }

    if (vertexArray.length > this.offset) {
      vertexArray = new Float32Array(vertexArray.buffer.slice(0, this.offset * 4));
    }

    if (indexArray.length > this.startingIndexArrayIndex) {
      batch.indexCount = this.startingIndexArrayIndex;
      indexArray = new Uint16Array(indexArray.buffer.slice(0, this.startingIndexArrayIndex * 2));
    }

    geometryBatches.push({
      technique: technique,
      vertices: new Uint8Array(vertexArray.buffer),
      indices: new Uint8Array(indexArray.buffer),
      numVerts: batch.indexCount
    });
  }

  return geometryBatches;
};

CM.PolylineBucket.prototype.getTechniqueForLineStyle = function (style) {
  var dashArray = style.get('line-dasharray');
  if (dashArray) {
    var patternLength = (dashArray[0] || 0) + (dashArray[1] || 0) + (dashArray[2] || 0) + (dashArray[3] || 0);
    if (patternLength > 0) {
      return 'line_pattern';
    }
  }
  return 'line_solid';
};

CM.PolylineBucket.prototype.triangulateFeatures = function (features, zoom) {
  this.zoom = zoom;
  if (zoom) {
    this.resolution = CM.GeoUtils.getResolutionForZoom(zoom);
  } else {
    this.resolution = 0;
  }

  var jointsEnabled = zoom >= 13;

  var currentTechnique = null;
  var currentBatch = [];

  var geometryBatches = [];
  for (var i = 0; i < features.length; ++i) {
    var feature = features[i];
    var tech = this.getTechniqueForLineStyle(feature.style);

    if (tech != currentTechnique) {
      if (currentTechnique && currentBatch.length) {
        if (currentTechnique == 'line_solid' && jointsEnabled) {
          geometryBatches = geometryBatches.concat(this._triangulateFeatures(currentBatch, "line_solid_joint"));
        }
        geometryBatches = geometryBatches.concat(this._triangulateFeatures(currentBatch, currentTechnique));
      }
      currentTechnique = tech;
      currentBatch = [];
    }
    currentBatch.push(feature);
  }
  if (currentTechnique && currentBatch.length) {
    if (currentTechnique == 'line_solid' && jointsEnabled) {
      geometryBatches = geometryBatches.concat(this._triangulateFeatures(currentBatch, "line_solid_joint"));
    }
    geometryBatches = geometryBatches.concat(this._triangulateFeatures(currentBatch, currentTechnique));
  }
  return geometryBatches;
};
CM.Box = L.Class.extend({
  initialize: function (position, dimensions, angle) {
    this.position = position;
    this.left = dimensions.left !== undefined ? dimensions.left : -dimensions.x;
    this.top = dimensions.top !== undefined ? dimensions.top : -dimensions.y;
    this.right = dimensions.right !== undefined ? dimensions.right : dimensions.x;
    this.bottom = dimensions.bottom !== undefined ? dimensions.bottom : dimensions.y;
    this.angle = angle;
    this._calculateVertices();
  },

  setPosition: function (position, angle) {
    if (position != undefined) {
      this.position = position;
    }
    if (angle !== undefined) {
      this.angle = angle;
    }
    this._calculateVertices();
  },

  _calculateVertices: function () {
    this.vertices = [
      new L.Point(this.left, this.top),
      new L.Point(this.left, this.bottom),
      new L.Point(this.right, this.top),
      new L.Point(this.right, this.bottom)
    ];

    if (this.angle) {
      for (var i = 0; i < this.vertices.length; i++) {
        var vertex = this.vertices[i];
        var rotatedPoint = CM.GeoUtils.rotatePoint(vertex, this.angle);

        this.vertices[i].x = rotatedPoint.x + this.position.x;
        this.vertices[i].y = rotatedPoint.y + this.position.y;
      }
    } else {
      for (var i = 0; i < this.vertices.length; i++) {
        this.vertices[i].x += this.position.x;
        this.vertices[i].y += this.position.y;
      }
    }
  },

  _obbCalculateAxis2D: function(i, obb, outAxis) {
    var a1 = obb.vertices[i];
    var i2 = i + 1;
    if(i2 >= 4){
      i2 = 0;
    }

    var a2 = obb.vertices[i2];
    outAxis.x = -(a1.y - a2.y);
    outAxis.y = a1.x - a2.x;
  },

  _obbIntersectionTestAxis: function(axis, other) {
    var min1 = Infinity;
    var max1 = -Infinity;
    var min2 = Infinity;
    var max2 = -Infinity;

    for (var j = 0; j < 4; j++) {
      var p1 = this.vertices[j];
      var p2 = other.vertices[j];

      var dot1 = (p1.x * axis.x) + (p1.y * axis.y);
      var dot2 = (p2.x * axis.x) + (p2.y * axis.y);

      min1 = Math.min(min1, dot1);
      min2 = Math.min(min2, dot2);
      max1 = Math.max(max1, dot1);
      max2 = Math.max(max2, dot2);
    }

    return !(min1 > max2 || min2 > max1);
  },

  intersects: function (other) {
    var axis = new L.Point();

    for (var i = 0; i < 4; i++) {
      this._obbCalculateAxis2D(i, this, axis);

      if (!this._obbIntersectionTestAxis(axis, other)) {
        return false;
      }
    }

    for (var i = 0; i < 4; i++) {
      this._obbCalculateAxis2D(i, other, axis);

      if (!this._obbIntersectionTestAxis(axis, other)) {
        return false;
      }
    }
    return true;
  }
});
CM.LinearInterpolator = L.Class.extend({
  initialize: function (start, end) {
    this._start = start;
    this._end = end;
  },

  valueOf: function (t) {
    return this._start + ((this._end - this._start) * t);
  }
});
CM.ValueAnimation = L.Class.extend({
  initialize: function (options) {
    this.options = options || {};
  },

  start: function () {
    var options = this.options;
    var start = options.start || 0;
    var end = options.end || 0;
    var object = options.object;
    var property = options.property;
    var callback = options.callback;
    var complete = options.complete;

    var interpolator = options.interpolator || new CM.LinearInterpolator(start, end);

    var startTime = new Date().getTime();

    var update = (function () {
      var timeNow = new Date().getTime();
      var elapsed = timeNow - startTime;

      var t = Math.min(elapsed / this.options.duration, 1.0);
      var value = interpolator.valueOf(t);

      if (object && property) {
        for (var p in property) {
          object[property[p]] = value;
        }

      }

      if (callback) {
        callback(value);
      }

      if (t < 1.0) {
        window.requestAnimationFrame(update);
      } else {
        if (complete) {
          complete();
        }
      }
    }).bind(this);

    window.requestAnimationFrame(update);
  }
});
/**
 * Created by edwardkimmel on 6/26/15.
 */
'use strict'

var CM = CM || {};
CM.EasingFunctions = {};

CM.EasingFunctions['linear'] = function (t) {
  return t;
};

CM.EasingFunctions['ease-in-quad'] = function (t) {
  return t * t
};

CM.EasingFunctions['ease-out-quad'] = function (t) {
  return t * (2 - t)
};

CM.EasingFunctions['ease-in-out-quad'] = function (t) {
  return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t
};

CM.EasingFunctions['ease-in'] = function (t) {
  return t * t * t
};

CM.EasingFunctions['ease-out'] = function (t) {
  return (--t) * t * t + 1
};

CM.EasingFunctions['ease-in-out-quad'] = function (t) {
  return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
};

CM.EasingFunctions['overshoot'] = function (t) {
  var tension = 2.0;
  t -= 1;
  return t * t * ((tension + 1.0) * t + tension) + 1.0;
};

CM.EasingFunctions['anticipate'] = function (t) {
  var tension = 2.0;
  return t * t * ((tension + 1.0) * t - tension);
};
CM.RunLoop = L.Class.extend({

  initialize: function (callback) {
    this.callback = callback;

    window.requestAnimationFrame(this.step.bind(this));
  },

  step: function (time) {
    if (!this.render) {
      this.render = true;
    }

    if (!this.lastTime) {
      this.lastTime = time;
    }

    var deltaMillis = time - this.lastTime;

    //if (this.render) {
    this.callback(deltaMillis);
    //}

    this.lastTime = time;

    this.render = !this.render;
    //setTimeout(function() {
    window.requestAnimationFrame(this.step.bind(this))
    //}, 30);


  }
})
CM.ShaderData = L.Class.extend({

  initialize: function (data, type, count) {
    this.data = data;
    this.type = type;
    this.count = count || 1;
  }
});
var renderTargetStack = [];
var viewportStack = [];

CM.RenderTarget = L.Class.extend({
  initialize: function (device, width, height, options) {
    options = options || {};

    this._device = device;
    
    this._screenRatio = options.screenRatio || 1;

    this._framebuffer = this._device.gl.createFramebuffer();

    if (width > 0 && height > 0) {
      this.resize(device, width, height, options);
    }
  },

  delete: function() {
    this._device.gl.deleteFramebuffer(this._framebuffer);
    if (this._colorTexture) {
      this._colorTexture.delete();
    }
  },

  resize: function (device, width, height, options) {
    this._framebuffer.width = width * this._screenRatio;
    this._framebuffer.height = height * this._screenRatio;

    this._width = width;
    this._height = height;

    var colorTextureOptions = options.colorTextureOptions || {};

    colorTextureOptions.width = this._framebuffer.width;
    colorTextureOptions.height = this._framebuffer.height;
    colorTextureOptions.initializeTexture = true;

    this._colorTexture = new CM.Texture(device, null, colorTextureOptions);

    this._colorTexture.activate(this._device.gl.TEXTURE0);
    this.activate();
    this._device.gl.framebufferTexture2D(this._device.gl.FRAMEBUFFER, this._device.gl.COLOR_ATTACHMENT0, this._device.gl.TEXTURE_2D, this._colorTexture.getTextureId(), 0);
    this.deactivate();
  },

  activate: function () {
    var viewport = [0, 0, this._width * this._screenRatio, this._height * this._screenRatio];
    this._device.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
    this._device.gl.bindFramebuffer(this._device.gl.FRAMEBUFFER, this._framebuffer);

    renderTargetStack.push(this._framebuffer);
    viewportStack.push(viewport);
  },

  deactivate: function () {
    renderTargetStack.pop();

    var nextActiveTarget = renderTargetStack.length > 0 ? renderTargetStack[renderTargetStack.length - 1] : null;
    this._device.gl.bindFramebuffer(this._device.gl.FRAMEBUFFER, nextActiveTarget);

    var viewport;
    if (nextActiveTarget != null) {
      viewport = viewportStack.pop();
    } else {
      viewport = this._device.getViewport();
    }

    this._device.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
  },

  getColorTexture: function () {
    return this._colorTexture;
  },

  clearRegion: function (rect, clearColor) {
    this._device.gl.enable(this._device.gl.SCISSOR_TEST);
    this._device.gl.scissor(rect.origin.x * this._screenRatio,
      rect.origin.y * this._screenRatio,
      (rect.size.width || rect.size.x) * this._screenRatio,
      (rect.size.height || rect.size.y) * this._screenRatio);

    this._device.gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    this._device.gl.clear(this._device.gl.COLOR_BUFFER_BIT);
    this._device.gl.disable(this._device.gl.SCISSOR_TEST);
  }
});
CM.Pass = L.Class.extend({
  initialize: function (program) {
    this.program = program;
  },

  apply: function (device, state) {

    device.switchShader(this.program);
    this.program.bindToVertexBuffer();

    for (var i = 0; i < this.program.globalDataList.length; i++) {
      var globalData = this.program.globalDataList[i];
      var shaderData = state.getShaderData(globalData.name);
      if (shaderData) {
        this.program.setShaderData(globalData, shaderData);
      } else {
        CM.Console.log("Uniform missing: " + globalData.name);
      }
    }
  }
});

CM.Technique = L.Class.extend({

  initialize: function (name, passes) {
    this.name = name;
    this.passes = passes;
  },

  begin: function () {
    this.currentPass = 0;
  },

  hasNextPass: function () {
    return this.passes.length > this.currentPass;
  },

  processNextPass: function (device, state) {
    if (this.passes.length > this.currentPass) {
      var pass = this.passes[this.currentPass];
      pass.apply(device, state);
      this.currentPass++;
    }
  }
});

CM.Effect = L.Class.extend({

  initialize: function (name, techniques) {
    this.name = name;

    this.techniques = {};

    for (var i = 0; i < techniques.length; i++) {
      this.techniques[techniques[i].name] = techniques[i];
    }

    if (techniques.length > 0) {
      this.currentTechnique = techniques[0].name;
    }
  },

  getCurrentTechnique: function () {
    return this.techniques[this.currentTechnique];
  }
});
CM.MapCamera = L.Class.extend({

  baseResolution: 0.0,

  minZ: 0.0,

  maxZ: 0.0,

  screenSize: {"width": 0, "height": 0},

  aspect: 0,

  fov: 0,

  nearZ: 0,

  farZ: 0,

  initialize: function (aspect, fov, nearZ, farZ) {
    this.aspect = aspect;
    this.fov = fov;
    this.nearZ = nearZ;
    this.farZ = farZ;

    this.inverseViewMatrix = this.viewMatrix = mat4.create();
    this.projectionMatrix = mat4.create();

    mat4.perspective(this.projectionMatrix, glMatrix.toRadian(fov), aspect, nearZ, farZ);
  },

  /**
   * Rotate the view
   *
   * @param rotation a vec3 of the rotation
   */

  rotate: function (rotation) {
    //mat4.rotate(this.viewMatrix, this.viewMatrix, rotation);
  },

  /**
   * Translate the view
   *
   * @param translate a vec3 of the translation
   */

  translate: function (translation) {
    this.viewMatrix = mat4.translate(mat4.create(), this.viewMatrix, translation);
  },

  /**
   * Scale the view
   *
   * @param scale a vec3 of the scale
   */

  scale: function (scale) {
    mat4.scale(this.viewMatrix, this.viewMatrix, scale);
  },

  reset: function () {
    this.viewMatrix = mat4.create();
  },

  zoomToResolution: function (resolution) {
    this.translate(vec3.fromValues(0.0, 0.0, this.getZPosition(resolution)));
  },

  getZPosition: function (resolution) {
    var zPosition = this.baseResolution * resolution;
    zPosition = Math.min(Math.max(zPosition, this.minZ), this.maxZ);

    return zPosition;
  },

  resize: function (width, height) {
    this.screenSize = {"width": width, "height": height};
    this._findCameraZ();
    this.setMinResolution(this.minRes);
    this.setMaxResolution(this.maxRes);
  },

  getViewMatrix: function () {
    return this.viewMatrix;
  },

  getProjectionMatrix: function () {
    return this.projectionMatrix;
  },

  getViewProjectionMatrix: function () {
    return this.viewProjMatrix;
  },

  setMinResolution: function (minRes) {
    this.minRes = minRes;
    this.minZ = this.baseResolution * minRes;
  },

  setMaxResolution: function (maxRes) {
    this.maxRes = maxRes;
    this.maxZ = this.baseResolution * maxRes;
  },

  _findCameraZ: function () {
    this.baseResolution = this.screenSize.height / (2 * Math.tan(glMatrix.toRadian(this.fov * 0.5)));
    this.maxZ = this.baseResolution * CM.GeoUtils.WORLD_RESOLUTION;
  },

  update: function () {
    this.inverseViewMatrix = mat4.invert(mat4.create(), this.viewMatrix);
    this.viewProjMatrix = mat4.multiply(mat4.create(), this.projectionMatrix, this.inverseViewMatrix);
  },

  project: function (point) {
    var pt = vec4.transformMat4(vec4.create(), vec4.fromValues(point.x, point.y, 0.0, 1.0), this.viewProjMatrix);

    var oow = 1.0 / pt[3];
    var dx = (pt[0] * oow);
    var dy = (pt[1] * oow);

    var x = ((dx + 1) * this.screenSize.width) * 0.5;
    var y = ((dy - 1) * this.screenSize.height) * -0.5;

    return new L.Point(x, y);
  }

});

CM.MapCamera.MIN_Z = 50.0;
var id = 1;

var devices = {};

CM.GraphicsDevice = L.Class.extend({

  shadersLoaded: false,

  effectsLoaded: false,

  currentShader: null,
  options: {
    premultipliedAlpha: false,
    alpha: false,
    antialias: false,
    depth: false,
    stencil: true,
    preserveDrawingBuffer: true
  },

  initialize: function (canvas, width, height, options) {
    this.id = id++;
    devices[this.id] = this;

    this.shaders = {};
    this.shaderPrograms = {};
    this.effects = {};

    canvas.preserveDrawingBuffer = false;

    options = L.extend(L.extend({}, this.options), options);

    this.gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);

    if (this.gl == null) {
      throw "Failed to initialize WebGL.  Your browser may not support it.  Please upgrade to IE 10, Chrome, Firefox, or Safari."
    }

    this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
    this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);

    this.backgroundColor = vec4.fromValues(0.0, 0.0, 0.0, 0.0);
    this.resize(width, height);

    glMatrix.setMatrixArrayType(Float64Array);
  },

  cleanup: function() {
    for(var k in this.shaders) {
      this.shaders[k].delete();
    }

    for(var k in this.shaderPrograms) {
      this.shaderPrograms[k].delete();
    }
  },

  getViewport: function () {
    return this._viewport;
  },

  resize: function (width, height) {
    var viewport = [0, 0, width, height];
    this.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);

    this._viewport = viewport;
  },

  setBackgroundColor: function (color) {
    this.backgroundColor = color;
  },

  preRender: function () {
    for (var k in this.shaderPrograms) {
      var program = this.shaderPrograms[k];
      program.resetUniformBindings();
    }
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  },

  clear: function () {
    var color = this.backgroundColor;
    this.gl.clearColor(color[0], color[1], color[2], color[3]);
    this.gl.clearStencil(0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT)
  },

  addShader: function (name, shader) {
    this.shaders[name] = shader;
  },

  addShaderProgram: function (name, shader) {
    this.shaderPrograms[name] = shader;
  },

  addEffect: function (name, effect) {
    this.effects[name] = effect;
  },

  isReady: function () {
    return true;
  },

  getGlobalDataIndex: function (uniformName) {
    return 0;
  },

  switchShader: function(shaderProgram) {
    if (this.currentShader != shaderProgram) {
      shaderProgram.activate(this.currentShader);
      this.currentShader = shaderProgram;
    }
  },

  draw: function (primitiveType, count, start) {
    this.gl.drawArrays(primitiveType, start, count);
  },

  drawIndexed: function (primitiveType, indexType, count, start) {
    this.gl.drawElements(primitiveType, count, this.gl.UNSIGNED_SHORT, start);
  },

  loadShaders: function (config) {
    var shaderData = new DOMParser().parseFromString(CM.Files[config], "text/xml");

    var shaderNodes = shaderData.getElementsByTagName("Shaders")[0].getElementsByTagName("Shader");

    var shadersPromises = [];

    for (var i = 0; i < shaderNodes.length; i++) {
      var shaderNode = shaderNodes[i];

      var shaderName = shaderNode.getAttribute("name");
      var filename = shaderNode.getAttribute("filename");
      var type = shaderNode.getAttribute("type");
      var globals = [];

      var shaderType;

      switch (type) {
        case "vertex":
          shaderType = this.gl.VERTEX_SHADER;
          break;

        case "pixel":
          shaderType = this.gl.FRAGMENT_SHADER;
          break;
      }

      var globalNodes = shaderNode.getElementsByTagName("GlobalData");
      for (var j = 0; j < globalNodes.length; j++) {
        var name = globalNodes[j].getAttribute("name");
        globals.push(name);
      }

      var data = CM.Shaders[filename];
      var shader = new CM.Shader(data, shaderType, globals);
      shader.load(this);
      this.addShader(shaderName, shader);
    }

    var shaderProgramNodes = shaderData.getElementsByTagName("ShaderPrograms")[0].getElementsByTagName("ShaderProgram");

    for (var i = 0; i < shaderProgramNodes.length; i++) {
      var shaderProgramNode = shaderProgramNodes[i];
      var programName = shaderProgramNode.getAttribute("name");

      var shaderNodes = shaderProgramNode.getElementsByTagName("Shader");

      var program = new CM.ShaderProgram(this);

      for (var j = 0; j < shaderNodes.length; j++) {
        var name = shaderNodes[j].getAttribute("name");
        var shader = this.shaders[name];
        if (shader) {
          program.setShader(shader);
        }
      }

      var inputLayoutElement = shaderProgramNode.getElementsByTagName("InputLayout")[0];
      var inputLayout = new CM.InputLayout();

      for (var j = 0; j < inputLayoutElement.childNodes.length; j++) {
        var inputElementNode = inputLayoutElement.childNodes[j];
        if (inputElementNode.nodeName == 'InputElement') {
          var name = inputElementNode.getAttribute("name");
          var size = parseInt(inputElementNode.getAttribute("size"));
          var offset = parseInt(inputElementNode.getAttribute("offset"));
          var normalized = (inputElementNode.getAttribute("normalized") || "false") == "true";
          var type = inputElementNode.getAttribute("type");

          inputLayout.addInputElement(this, name, size, offset, type, normalized);
        }
      }

      program.setInputLayout(inputLayout);

      this.addShaderProgram(programName, program);
    }
  },

  loadEffects: function (shadersConfig, effectsConfig) {
    this.loadShaders(shadersConfig);

    var data = new DOMParser().parseFromString(CM.Files[effectsConfig], "text/xml");

    var effectNodes = data.getElementsByTagName("Effect");

    for (var i = 0; i < effectNodes.length; i++) {
      var effectNode = effectNodes[i];

      var effectName = effectNode.getAttribute("name");

      var techniqueNodes = effectNode.getElementsByTagName("Technique");

      var techniques = [];

      for (var j = 0; j < techniqueNodes.length; j++) {
        var techniqueNode = techniqueNodes[j];

        var techniqueName = techniqueNode.getAttribute("name");

        var passNodes = techniqueNode.getElementsByTagName("Pass");

        var passes = [];

        for (var k = 0; k < passNodes.length; k++) {
          var passNode = passNodes[k];

          var program = passNode.getAttribute("program");

          passes.push(new CM.Pass(this.shaderPrograms[program]));
        }

        techniques.push(new CM.Technique(techniqueName, passes));
      }

      var effect = new CM.Effect(effectName, techniques);
      this.addEffect(effectName, effect);
    }
  }
});
CM.VertexBuffer = L.Class.extend({

  initialize: function (device, type, usage) {
    this._device = device;
    
    this.bufferId = this._device.gl.createBuffer();

    this.type = type;
    this.usage = usage;

    this.bufferSize = 0;
  },

  setData: function (data) {
    this.activate();

    if (data.length > this.bufferSize) {
      this.bufferSize = data.length;
      this._device.gl.bufferData(this.type, data, this.usage);
    } else {
      this._device.gl.bufferSubData(this.type, 0, data);
    }
  },

  delete: function() {
    this._device.gl.deleteBuffer(this.bufferId);
  },

  activate: function () {
    this._device.gl.bindBuffer(this.type, this.bufferId)
  }
});
CM.Texture = L.Class.extend({

  initialize: function (device, image, options) {
    this._device = device;
    
    this._textureId = this._device.gl.createTexture();

    this.options = {
      dataFormat: this._device.gl.RGBA,
      dataType: this._device.gl.UNSIGNED_BYTE,
      internalFormat: this._device.gl.RGBA,
      wrapMode: this._device.gl.CLAMP_TO_EDGE,
      magFilter: this._device.gl.LINEAR,
      minFilter: this._device.gl.LINEAR,
      width: 0,
      height: 0,
      numMipMaps: 0,
      initializeTexture: false
    };

    L.setOptions(this, options);

    if (image || this.options.initializeTexture) {

      var data = image;
      if (!data) {
        var components = 4;
        if (this.options.dataFormat == this._device.gl.ALPHA) {
          components = 1;
        }
        data = new Uint8Array(components * this.options.width * this.options.height);
      }
      this.setImage(data);
    }
  },

  delete: function() {
    this._device.gl.deleteTexture(this._textureId);
    this._textureId = 0;
  },

  setImage: function (image, width, height) {
    this.activate(this._device.gl.TEXTURE0);

    this._device.gl.texParameteri(this._device.gl.TEXTURE_2D, this._device.gl.TEXTURE_MIN_FILTER, this.options.minFilter);
    this._device.gl.texParameteri(this._device.gl.TEXTURE_2D, this._device.gl.TEXTURE_MAG_FILTER, this.options.magFilter);
    this._device.gl.texParameteri(this._device.gl.TEXTURE_2D, this._device.gl.TEXTURE_WRAP_S, this.options.wrapMode);
    this._device.gl.texParameteri(this._device.gl.TEXTURE_2D, this._device.gl.TEXTURE_WRAP_T, this.options.wrapMode);

    width = width || this.options.width;
    height = height || this.options.height;
    if (image instanceof HTMLImageElement)
      this._device.gl.texImage2D(this._device.gl.TEXTURE_2D, 0, this.options.internalFormat, this.options.dataFormat, this.options.dataType, image);
    else
      this._device.gl.texImage2D(this._device.gl.TEXTURE_2D, 0, this.options.internalFormat, width, height, 0, this.options.dataFormat, this.options.dataType, image);

    if (this.options.numMipMaps > 0) {
      this._device.gl.generateMipmap(this._device.gl.TEXTURE_2D);
    }
  },

  setSubData: function (data, offset, size) {
    this.activate(this._device.gl.TEXTURE0);

    if (data instanceof HTMLImageElement) {
      this._device.gl.texSubImage2D(this._device.gl.TEXTURE_2D, 0, offset.x, offset.y, this.options.dataFormat, this.options.dataType, data);
    } else {
      this._device.gl.texSubImage2D(this._device.gl.TEXTURE_2D, 0, offset.x, offset.y, size.x, size.y, this.options.dataFormat, this.options.dataType, data);
    }


    this.deactivate();
  },

  activate: function (slot) {
    this._device.gl.activeTexture(slot);
    this._device.gl.bindTexture(this._device.gl.TEXTURE_2D, this._textureId);
    this.slot = slot;
  },

  deactivate: function () {
    this._device.gl.activeTexture(this.slot);
    this._device.gl.bindTexture(this._device.gl.TEXTURE_2D, null);
  },

  getTextureId: function () {
    return this._textureId;
  }
});

CM.TextureAtlas = L.Class.extend({
  options: {
    padding: new L.Point(0, 0),
    textureOptions: {},
    size: new L.Point(1024, 1024),
    baseData: null
  },

  initialize: function (device, options) {
    options = L.setOptions(this, options);

    this._size = options.size;

    var textureOptions = L.extend({
      width: this._size.x,
      height: this._size.y,
      initializeTexture: true
    }, options.textureOptions);

    this._texture = new CM.Texture(device, options.baseData, textureOptions);
    options.baseData = null;

    this._atlasPosition = this.options.padding.clone();
    this._maxHeight = 0;
    this._objects = {};
  },

  delete: function(){
    this._texture.delete();
  },

  addObject: function (key, object, data, size) {
    if (size.x == 0 || size.y == 0 || data.length == 0) {
      var texCoords = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        absolutePosition: new L.Point(0, 0),
        index: Object.keys(this._objects).length
      };

      this._objects[key] = texCoords;
      return;
    }
    if (this._atlasPosition.x + size.x + this.options.padding.x > this._size.x) {
      this._atlasPosition.x = this.options.padding.x;
      this._atlasPosition.y += this._maxHeight;
      this._maxHeight = 0;
    }

    var textureFrame = {
      position: this._atlasPosition.clone(),
      size: size
    };

    var oneTexelX = 1 / this._size.x;
    var oneTexelY = 1 / this._size.y;
    var halfTexelX = oneTexelX * 0.5;
    var halfTexelY = oneTexelY * 0.5;

    var texCoords = {
      x: textureFrame.position.x * oneTexelX + halfTexelX,
      y: textureFrame.position.y * oneTexelY + halfTexelY,
      width: textureFrame.size.x * oneTexelX - oneTexelX,
      height: textureFrame.size.y * oneTexelY - oneTexelY,
      absolutePosition: new L.Point(textureFrame.position.x, textureFrame.position.y),
      index: Object.keys(this._objects).length
    };

    this._objects[key] = texCoords;

    this._texture.setSubData(data, textureFrame.position, textureFrame.size);

    this._maxHeight = Math.max(this._maxHeight, size.y + this.options.padding.y);
    this._atlasPosition.x += size.x + this.options.padding.x;
  },

  getObjectCoordinates: function (key) {
    return this._objects[key];
  },

  activate: function (slot) {
    this._texture.activate(slot);
  },

  deactivate: function () {
    this._texture.deactivate();
  },

  getTexture: function () {
    return this._texture;
  },

  getObjects: function () {
    return this._objects;
  },

  canFit: function (size) {
    var pos = this._atlasPositionForSize(size);
    return (pos.x + size.x < this._size.x) && (pos.y + size.y < this._size.y);
  },

  _atlasPositionForSize: function (size) {
    var position = new L.Point(this._atlasPosition.x, this._atlasPosition.y);
    if (position.x + size.x + this.options.padding.x > this._size.x) {
      position.x = this.options.padding.x;
      position.y += this._maxHeight;
    }
    return position;
  }
});

CM.TextureAtlas.fromConfiguration = function (device, config) {
  return new Promise(function (resolver) {
    var data = CM.Files[config];

    CM.Network.loadImage(CM.Conf.baseUrl + data.imageUrl).then(function (image) {
      var size = data.size;

      var atlas = new CM.TextureAtlas(device, {
        baseData: image,
        size: new L.Point(size.width, size.height)
      });

      var objects = data.objects;

      for (var i = 0; i < objects.length; i++) {
        var object = objects[i];
        var texCoords = {
          x: object.x / atlas._size.x,
          y: object.y / atlas._size.y,
          width: object.width / atlas._size.x,
          height: object.height / atlas._size.y,
          absolutePosition: new L.Point(object.x, object.y),
          size: new L.Point(object.width, object.height)
        };

        atlas._objects[object.key] = texCoords;
      }

      resolver(atlas);
    });
  });
};
CM.InputElement = L.Class.extend({
  initialize: function (device, name, numComponents, offset, type, normalized) {
    this.name = name;
    this.numComponents = numComponents;
    this.offset = offset;
    this.normalized = normalized;

    var gl = device.gl;

    switch (type) {
      case "uint8":
        this.type = gl.UNSIGNED_BYTE;
        break;

      case "int8":
        this.type = gl.BYTE;
        break;

      case "uint16":
        this.type = gl.UNSIGNED_SHORT;
        break;

      case "int16":
        this.type = gl.SHORT;
        break;

      default:
        this.type = gl.FLOAT;
        break;
    }
  }
});

CM.InputLayout = L.Class.extend({

  stride: 0,

  initialize: function () {
    this.elements = [];
  },

  addInputElement: function (device, name, numComponents, offset, type, normalized) {
    this.elements.push(new CM.InputElement(device, name, numComponents, offset, type, normalized))
    this.stride += numComponents * this.sizeof(type);
  },

  bind: function (device) {
    var gl = device.gl;
    
    for (var i = 0; i < this.elements.length; i++) {
      var element = this.elements[i];
      gl.vertexAttribPointer(i, element.numComponents, element.type, element.normalized,
        this.stride, element.offset);
    }
  },

  sizeof: function (type) {
    switch (type) {
      case "uint8":
      case "int8":
        return 1;

      case "uint16":
      case "int16":
        return 2;

      default:
        return 4;
    }
  }
})
CM.Shader = L.Class.extend({

  initialize: function (data, type, globals) {
    this.data = data;
    this.type = type;
    this.globals = globals || [];
  },

  load: function (device) {
    if (this.loaded) {
      return
    }

    var gl = device.gl;

    this.shaderId = gl.createShader(this.type)

    gl.shaderSource(this.shaderId, this.data)
    gl.compileShader(this.shaderId)

    if (!gl.getShaderParameter(this.shaderId, gl.COMPILE_STATUS)) {
      CM.Console.log(gl.getShaderInfoLog(this.shaderId));
      return null;
    }

    this.loaded = true
  },

  delete: function() {
    if (this.shaderId) {
      gl.deleteShader(this.shaderId);
    }
  },

  isLoaded: function () {
    return this.loaded;
  },

  attachToProgram: function (program) {
    var gl = program._device.gl;
    
    if (!this.isLoaded()) {
      this.load(program._device)
    }

    gl.attachShader(program.programId, this.shaderId)
  }

})
CM.ShaderProgram = L.Class.extend({

  initialize: function (device) {
    this._device = device;
    
    this.programId = this._device.gl.createProgram();

    this.globalDataList = [];
    this.uniformData = {};
    this.built = false;
  },

  delete: function() {
    this._device.gl.deleteProgram(this.programId);
  },

  resetUniformBindings: function () {
    this.uniformData = {};
  },

  setShader: function (shader) {
    if (!this.shaders) {
      this.shaders = {};
    }

    this.shaders[shader.type] = shader;
  },

  setInputLayout: function (inputLayout) {
    this.inputLayout = inputLayout
  },

  build: function () {
    for (var t in this.shaders) {
      this.shaders[t].attachToProgram(this);
    }

    for (var i = 0; i < this.inputLayout.elements.length; i++) {
      this._device.gl.bindAttribLocation(this.programId, i, this.inputLayout.elements[i].name);
    }

    this._device.gl.linkProgram(this.programId);

    if (!this._device.gl.getProgramParameter(this.programId, this._device.gl.LINK_STATUS)) {
      CM.Console.log(this._device.gl.getProgramInfoLog(this.programId));
      return null;
    }

    var maxLocation = 0;
    for (var t in this.shaders) {
      var globalData = this.shaders[t].globals;

      for (var i = 0; i < globalData.length; i++) {
        var location = this._device.gl.getUniformLocation(this.programId, globalData[i]);

        this.globalDataList.push({
          location: location,
          name: globalData[i]
        });
      }
    }

    /*while (it != shaders.end())
     {
     IShader *shader = (*it).second;

     ShaderType type = shader->GetType();
     std::vector<std::pair<int, std::string> > globalData =
     shader->GetGlobalData();
     for (const std::pair<int, std::string>& data : globalData)
     {
     int location = GetGlobalVariableIndex(data.second.c_str(),
     type);
     if (location != -1)
     {
     mGlobalDataList.push_back(
     GlobalData(data.second, data.first, location,
     type));
     }
     }
     it++;
     }*/


  },

  bindToVertexBuffer: function () {
    this.inputLayout.bind(this._device);
  },

  activate: function (prevShader) {
    if (!this.built) {
      this.build();
      this.built = true;
    }

    this._device.gl.useProgram(this.programId);

    var enabled = prevShader ? prevShader.inputLayout.elements : [];
    var required = this.inputLayout.elements;

    for (var i = required.length; i < enabled.length; i++) {
      this._device.gl.disableVertexAttribArray(i);
    }
     for (var j = enabled.length; j < required.length; j++) {
      this._device.gl.enableVertexAttribArray(j);
     }
  },

  _to32Bit: function (data) {
    var outArray = new Float32Array(data.length);

    for (var i = 0; i < data.length; i++) {
      outArray[i] = data[i];
    }

    return outArray;
  },

  _testDataEqual: function (data1, data2) {
    if (!data1 || !data2) {
      return false;
    }

    if (data1 === data2) {
      return true;
    }

    if (data1.length != data2.length) {
      return false;
    }

    for (var i = 0; i < data1.length; ++i) {
      if (data1[i] != data2[i]) {
        return false
      }
    }
    return true;
  },

  setShaderData: function (globalData, shaderData) {
    var type = shaderData.type;
    var location = globalData.location;
    var name = globalData.name;
    var data = shaderData.data;

    var oldData = this.uniformData[name];
    if (oldData == shaderData) {
      return;
    }
    this.uniformData[name] = shaderData;

    if (type == 'int' && shaderData.count == 1) {
      data = new Int32Array([data]);
    } else if (type == 'float' && shaderData.count == 1) {
      data = new Float32Array([data]);
    } else if (!(data instanceof Float32Array) && type != 'texture') {
      data = this._to32Bit(data);
    }

    switch (type) {
      case 'mat4':
        this._device.gl.uniformMatrix4fv(location, false, data);
        break;

      case 'mat3':
        this._device.gl.uniformMatrix3fv(location, false, data);
        break;

      case 'vec2':
        this._device.gl.uniform2fv(location, data);
        break;

      case 'vec3':
        this._device.gl.uniform3fv(location, data);
        break;

      case 'vec4':
        this._device.gl.uniform4fv(location, data);
        break;

      case 'float':
        this._device.gl.uniform1fv(location, data);
        break;

      case 'int':
        this._device.gl.uniform1iv(location, data);
        break;

      case 'texture':
        if (typeof data == "object") {
          this._device.gl.uniform1iv(location, data);
        } else {
          this._device.gl.uniform1i(location, data);
        }
        break;
    }
  }
});
CM.RenderState = L.Class.extend({


  initialize: function () {
    this.transformStack = [];
    this.shaderData = {};
    this.projection = mat4.create();
    this.topTransform = mat4.create();
    this.worldViewProj = mat4.create();
    this.currentShader = null;
    this.wvpShaderData = new CM.ShaderData(mat4.create(), 'mat4');
  },

  pushTransform: function (transform) {
    var newTop = mat4.create();
    mat4.multiply(newTop, this.topTransform, transform);
    this.topTransform = newTop;
    this.transformStack.push(this.topTransform);

    mat4.multiply(this.worldViewProj, this.projection, this.topTransform);
    this.wvpShaderData = new CM.ShaderData(this.worldViewProj, 'mat4');
  },

  popTransform: function () {
    if (this.transformStack.length > 0) {
      this.transformStack.pop();

      if (this.transformStack.length > 0) {
        this.topTransform = this.transformStack[this.transformStack.length - 1];
        mat4.multiply(this.worldViewProj, this.projection, this.topTransform);
        this.wvpShaderData = new CM.ShaderData(this.worldViewProj, 'mat4');
      } else {
        this.topTransform = mat4.create();
        this.worldViewProj = this.projection;
        this.wvpShaderData = new CM.ShaderData(this.worldViewProj, 'mat4');
      }
    }
  },

  setShaderData: function (index, data) {
    this.shaderData[index] = data;
  },

  getShaderData: function (index) {
    return this.shaderData[index];
  },
});
CM.Mesh = L.Class.extend({

  indexed: false,

  initialize: function (device, effect, options) {
    options = options || {};
    var gl = device.gl;

    if (!device) {
      throw "A valid CM.GraphicsDevice object is required";
    }

    if (!effect) {
      throw "A valid effect name is required";
    }

    this.effect = device.effects[effect];

    var vertexBufferUsage = options.vertexBufferUsage || gl.STATIC_DRAW;
    var indexBufferUsage = options.indexBufferUsage || gl.STATIC_DRAW;

    this.vertexBuffer = new CM.VertexBuffer(device, gl.ARRAY_BUFFER, vertexBufferUsage);
    this.indexBuffer = new CM.VertexBuffer(device, gl.ELEMENT_ARRAY_BUFFER, indexBufferUsage);

    this.mvpIndex = device.getGlobalDataIndex("u_mvp");
  },

  cleanup: function() {
    this.vertexBuffer.delete();
    this.indexBuffer.delete();
  },

  setData: function (vertices, numVerts) {
    this.vertexBuffer.setData(vertices);

    this.indexed = false;
    this.numVerts = numVerts;
  },

  setIndexedData: function (vertices, indices, numVerts) {
    this.vertexBuffer.setData(vertices);
    this.indexBuffer.setData(indices);

    this.indexed = true;
    this.numVerts = numVerts;
    this.indexType = ((indices.length * 4) / numVerts);
  },

  setEffect: function (device, effect) {
    this.effect = device.effects[effect];
    this._currentTechnique = null;
  },

  setTechnique: function (technique) {
    this._currentTechnique = technique;
  },

  getTechnique: function () {
    return this._currentTechnique;
  },

  setPrimitiveType: function (primitiveType) {
    this._primitiveType = primitiveType;
  },

  draw: function (device, state, primitiveType) {

    if (this.numVerts == 0) {
      return;
    }

    primitiveType = primitiveType || this._primitiveType;
    if (this.effect) {
      if (this._currentTechnique) {
        this.effect.currentTechnique = this._currentTechnique;
      }

      var technique = this.effect.getCurrentTechnique();

      if (technique) {
        state.setShaderData("u_mvp", state.wvpShaderData);

        technique.begin();

        this.vertexBuffer.activate();
        if (this.indexed) {
          this.indexBuffer.activate();
        }

        while (technique.hasNextPass()) {
          technique.processNextPass(device, state);

          if (this.indexed) {
            device.drawIndexed(primitiveType, this.indexType, this.numVerts, 0);
          } else {
            device.draw(primitiveType, this.numVerts, 0);
          }
        }
      }
    }
  }
});
CM.Sprite = L.Class.extend({

  options: null,
  _imageTexture: null,
  image: null,
  imageLoaded: false,
  _imageChanged: false,
  _dimensions: null,
  _textureDimensions: null,
  _blendColor:null,
  _rotationValues: null,
  _anchorPoint: null,
  _alpha: null,
  blendEnabled: true,
  srcBlend: null,
  dstBlend: null,
  imageDpr: null,

  initialize: function (image, options) {
    this.options = options || {};

    this.image = image;
    this.imageLoaded = !!this.image;
    this._imageChanged = !!this.image;
    this._dimensions = vec4.create();
    this._textureDimensions = vec4.fromValues(0, 0, 1, 1);
    this._blendColor = vec4.fromValues(1, 1, 1, 1);
    this._rotationValues = vec2.fromValues(0, 1);
    this._anchorPoint = vec2.fromValues(0.5, 0.5);
    this._alpha = 1.0;
    this.imageDpr = CM.Conf.devicePixelRatio;
  },

  delete: function(){
    if (this._imageTexture) {
      this._imageTexture.delete();
      this._imageTexture = null;
    }
  },

  setPosition: function (position) {
    this._dimensions[0] = position.x;
    this._dimensions[1] = position.y;
  },

  setSize: function (size) {
    this._dimensions[2] = size.x;
    this._dimensions[3] = size.y;
  },

  setAnchorPoint: function (anchorPoint) {
    this._anchorPoint[0] = anchorPoint.x;
    this._anchorPoint[1] = anchorPoint.y;
  },

  setImage: function (image, width, height) {
    if (this.image && !(this.image === image)) {
      this.image.onload = undefined;
    }
    this.imageLoaded = !!image;

    this.image = image;
    if (image) {
      this.imageWidth = width || image.width;
      this.imageHeight = height || image.height;
    } else {
      this.imageWidth = width || 0;
      this.imageHeight = height || 0;
    }

    this._imageChanged = true;
  },

  setAlpha: function (alpha) {
    this._alpha = alpha;
  },

  getSize: function () {
    return new L.Point(this._dimensions[2], this._dimensions[3]);
  },

  hasUrlSrc: function (url) {
    return this.image && this.image.src == url;
  },

  isDownloadingImage: function () {
    // We have an image object, but our imageLoaded flag isn't set.
    return this.image && this.imageLoaded == false;
  },

  cancelLoading: function () {
    if (this.isDownloadingImage()) {
      this.image.onload = undefined;
      this.imageLoaded = false;
    }
  },

  loadURL: function (url, callback) {

    this.imageLoaded = false;
    this.cancelLoading();
    this.image = new Image();
    this.callback = callback;
    this.image.onload = function (image, e) {
      if (image === this.image) {

        this.imageLoaded = true;
        this.setImage(image);

        if (this._dimensions[2] == 0 && this._dimensions[3] == 0) {
          this.setSize(new L.Point(image.width / this.imageDpr, image.height / this.imageDpr));
        }

        if (this.callback) {
          this.callback(e)
        }
      }
    }.bind(this, this.image);
    this.image.crossOrigin = 'anonymous';
    this.image.src = url;
  },

  setTechnique: function (technique) {
    this._technique = technique;
  },

  draw: function (device, state) {
    if (!this.image) {
      //return;
    }

    var gl = device.gl;

    var srcBlend = this.srcBlend || gl.SRC_ALPHA;
    var dstBlend = this.dstBlend || gl.ONE_MINUS_SRC_ALPHA;

    if (!this.effect) {
      var effect = this.options.effect || "sprite";
      this.effect = device.effects[effect];
      if (this._technique) {
        this.effect.currentTechnique = this._technique;
      }

      if (!CM.Sprite.vertexBuffers[device.id]) {
        var vertexBuffer = new CM.VertexBuffer(device, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        vertexBuffer.setData(new Float32Array([
          0.0, 0.0,
          1.0, 0.0,
          0.0, 1.0,
          1.0, 1.0
        ]));

        CM.Sprite.vertexBuffers[device.id] = vertexBuffer;
      }
    }

    if (this._imageChanged) {
      this._imageChanged = false;
      if (!this._imageTexture) {
        this._imageTexture = new CM.Texture(device, null, this.options.textureOptions);
      }
      this._imageTexture.setImage(this.image, this.imageWidth, this.imageHeight);
    }

    if (!this._imageTexture) {
      console.log('this wont render');
    }

    if (this.effect && this._imageTexture) {
      var technique = this.effect.getCurrentTechnique();

      if (technique) {
        state.setShaderData("u_mvp", state.wvpShaderData);
        state.setShaderData("u_alpha", new CM.ShaderData(this._alpha, 'float'));
        state.setShaderData("u_dimensions", new CM.ShaderData(this._dimensions, 'vec4'));
        state.setShaderData("u_textureDimensions", new CM.ShaderData(this._textureDimensions, 'vec4'));
        state.setShaderData("u_anchorPoint", new CM.ShaderData(this._anchorPoint, 'vec2'));
        state.setShaderData("u_blendColor", new CM.ShaderData(this._blendColor, 'vec4'));
        state.setShaderData("u_rotation", new CM.ShaderData(this._rotationValues, 'vec2'));
        state.setShaderData("u_texture", new CM.ShaderData(0, 'texture'));

        var vertexBuffer = CM.Sprite.vertexBuffers[device.id];
        vertexBuffer.activate();

        this._imageTexture.activate(gl.TEXTURE0);

        technique.begin();

        if (this.blendEnabled) {
          gl.enable(gl.BLEND);
        } else {
          gl.disable(gl.BLEND);
        }
        gl.blendFunc(srcBlend, dstBlend);

        while (technique.hasNextPass()) {
          technique.processNextPass(device, state);

          device.draw(gl.TRIANGLE_STRIP, 4, 0);
        }

        gl.disable(gl.BLEND);
      }
    }
  }
});

CM.Sprite.vertexBuffers = {};
CM.Label = L.Class.extend({
  options: {
    textSize: 12,
    fontFamily: 'HelveticaNeue',
    textColor: vec4.fromValues(0, 0, 0, 1),
    outlineColor: vec4.fromValues(1, 1, 1, 1),
    outlineWidth: 0,
    alpha: 1.0,
    position: new L.Point(0, 0),
    pathPoints: null,
    pathSegment: null,
    advancedPlacement: null,
    textAlignment: 'left',
    textVerticalAlignment: 'top',
    textCharSpacing: 0,
    textLineSpacing: 0,
    ellipsize: true,
    maxLines: 2,
    angle: 0,
    fontWeight: 400,
    textStyle: "regular",
    useAdvancedPlacement: undefined
  },

  initialize: function (options) {
    L.extend(this, L.setOptions(this, options));

    this.font = options.font;

    this.placements = null;
    this.loadState = 0;
    this.placementOptions = {};

    if (options.text) {
      this.setText(options.text);
    }
  },

  setText: function (text) {
    if (text != this._text) {
      this._text = text;
      this.placements = null;
      this._shape = null;
      this._advancedPlacement = null;
      this.loadState = 0;
    }
  },

  setAngle: function (angle) {
    this.angle = angle;
  },

  getText: function () {
    return this._text;
  },
});
CM.Renderer = L.Class.extend({
  initialize: function () {
  },

  render: function (device, camera) {
  },

  isReady: function () {
    return true;
  }
});
CM.BusinessRenderer = CM.Renderer.extend({

  applyTransition: function (bid, transitionKey, completion) {

  },

  cancelTransitions: function (bid) {

  },

  setAttachmentIcon: function (bid, url, persistent) {

  },

  setBlendColor: function (bid, color) {

  },

  setMetaAlpha: function (bid, alpha) {

  },

  setOverrideZ: function (bid, override) {

  }
});

CM.BusinessRenderer.Transition = {};
CM.BusinessRenderer.Transition.MarkerEnter = "marker-enter";
CM.BusinessRenderer.Transition.MarkerLeave = "marker-leave";
CM.BusinessRenderer.Transition.MetaEnter = "meta-enter";
CM.BusinessRenderer.Transition.MetaLeave = "meta-leave";
CM.LabelRenderer = CM.Renderer.extend({
  initialize: function (map, texture) {
    CM.Renderer.prototype.initialize.call(this);
    this.map = map;
    this._fontTexture = texture;

    this._placementloader = new CM.NetworkPlacementLoader();

    this._coords = [
      new L.Point(0.0, 0.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 1.0)
    ];

    this._objects = [];

    var gl = texture._device.gl;

    this.srcBlendOutline = gl.SRC_ALPHA;
    this.dstBlendOutline = gl.ONE_MINUS_SRC_ALPHA;
    this.srcBlendFill = gl.SRC_ALPHA;
    this.dstBlendFill = gl.ONE_MINUS_SRC_ALPHA;
  },

  cleanup: function() {
    if (this._mesh) {
      this._mesh.cleanup();
    }
  },

  addObjects: function(labels) {
    this._objects = this._objects.concat(labels);
  },

  addObject: function (label) {
    this._objects.push(label);
  },

  removeObject: function (label) {
    this._objects = this._objects.filter(function (l) {
      return l != label;
    });
  },

  removeAllObjects: function () {
    this._objects = [];
  },

  getFontTexture: function () {
    return this._fontTexture;
  },

  _loadLabels: function () {
    var objects = this._objects;
    for (var i = 0; i < objects.length; i++) {
      var label = objects[i];
      this.preloadLabel(label);
    }
  },

  isLabelReady: function(label) {
    return label && label.loadState == 2 && label.ellipsisState == 2;
  },

  _gatherReadyLabels: function () {
    var objects = this._objects;

    var ready = [];
    for (var i = 0; i < objects.length; ++i) {
      var label = objects[i];
      if (this.isLabelReady(label)) {
        ready.push(label);
      }
    }
    return ready;
  },

  shapeLabel: function(label) {
    if (this.isLabelReady(label)) {
      return this._shapeLabel(label);
    }
    return null;
  },

  _reorderText: function (drawObjects) {
  },

  _buildLabelPlacements: function (drawObjects) {
    var size = 0;
    for (var i = 0; i < drawObjects.length; i++) {
      var label = drawObjects[i];

      if (!label.placements) {
        label.placements = this._labelPlacement(label) || [];
      }
      size += label.placements.length;
    }
    return size;
  },

  render: function (device, state) {
    this._loadLabels();
    var drawObjects = this._gatherReadyLabels();

    var gl = device.gl;

    if (drawObjects.length) {
      this._reorderText(drawObjects);

      var size = this._buildLabelPlacements(drawObjects);

      if (!this.buffer || this.buffer.byteLength < size) {
        this._vertices = new Float32Array(size);
      }

      var idx = 0;
      for (var i = 0; i < drawObjects.length; i++) {
        var label = drawObjects[i];

        this._vertices.set(label.placements, idx);
        this._updateVertexBuffer(label, this._vertices, idx);

        idx += label.placements.length;
      }

      if (!this._mesh) {
        this._mesh = new CM.Mesh(device, "label", {
          vertexBufferUsage: gl.DYNAMIC_DRAW
        });
      }

      this._mesh.setData(this._vertices, this._vertices.length / this.vertexSize);

      this._preRender(device, state, this._mesh);
      gl.enable(gl.BLEND);
      gl.blendFunc(this.srcBlend, this.dstBlend);

      this._fontTexture.activate(gl.TEXTURE0);
      var textureLocations = [];
      for (var i = 0; i < this._fontTexture.getTextureCount(); i++) {
        textureLocations.push(i);
      }
      state.setShaderData("u_texture[0]", new CM.ShaderData(textureLocations, 'texture'));

      state.setShaderData("u_baseTextSize", new CM.ShaderData(256, 'float'));
      state.setShaderData("u_atlasSize", new CM.ShaderData(vec2.fromValues(2048, 2048), 'vec2'));

      this._mesh.setTechnique(this._getTechnique());
      state.setShaderData("u_outlinePass", new CM.ShaderData(1, 'float'));
      gl.blendFunc(this.srcBlendOutline, this.dstBlendOutline);
      this._mesh.draw(device, state, gl.TRIANGLES);

      state.setShaderData("u_outlinePass", new CM.ShaderData(0, 'float'));
      gl.blendFunc(this.srcBlendFill, this.dstBlendFill);
      this._mesh.draw(device, state, gl.TRIANGLES);
      gl.disable(gl.BLEND);

      // DEBUG //
      //var idx = 0;
      //var debugBounds = new Float32Array(drawObjects.length * this._coords.length * 2);
      //
      //var debugCoords = [
      //    0, 1, 2, 1, 2, 3
      //];
      //
      //for (var i = 0; i < drawObjects.length; i++) {
      //    var bounds = drawObjects[i];
      //
      //    for (var j = 0; j < debugCoords.length; j++) {
      //        debugBounds[idx] = bounds.vertices[debugCoords[j]].x;
      //        debugBounds[idx+1] = bounds.vertices[debugCoords[j]].y;
      //
      //        idx += 2;
      //    }
      //}
      //
      //if (!this._debugMesh) {
      //    this._debugMesh = new CM.Mesh(device, 'debug');
      //}
      //
      //this._debugMesh.setData(debugBounds, debugBounds.length / 2);
      //
      //state.setShaderData("u_color", new CM.ShaderData(vec4.fromValues(1, 0, 0, 0.5), 'vec4'));
      //
      //gl.enable(gl.BLEND);
      //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      //this._debugMesh.draw(device, state, gl.TRIANGLES);
      //gl.disable(gl.BLEND);
    }

    /*if (!this.bigSprite) {
     this.bigSprite = new CM.Sprite();
     this.bigSprite._imageTexture = this._fontTexture._texture;
     this.bigSprite.setPosition(new L.Point(0, 0));
     this.bigSprite.setSize(new L.Point(2048, 2048));
     this.bigSprite.setAnchorPoint(new L.Point(0.0, 0.0));
     }

     this.bigSprite.draw(device, state);*/
  },

  _anchorForLabel: function(label) {
    var anchor = [0.5, 0.5];
    switch(label.textAlignment) {
      case 'left':
        anchor[0] = 0;
        break;
      case 'right':
        anchor[0] = 1;
        break;
    }

    switch(label.textVerticalAlignment) {
      case 'top':
        anchor[1] = 0;
        break;
      case 'bottom':
        anchor[1] = 1;
        break;
    }
    return anchor;
  },

  _shapeLabel: function(label) {
    var text = label.getText();
    var textSize = label.textSize;
    var charSpacing = label.textCharSpacing;
    var lineSpacing = label.textLineSpacing;
    var weight = label.fontWeight || 400;
    var style = label.textStyle || 'regular';
    var maxWidth = label.size ? label.size.x : 0;
    var maxHeight = label.size ? label.size.y : 0;
    var maxLines = label.maxLines;

    var textShaper = new CM.TextShaper();

    var styleProps = new CM.TextShaper.LabelStyle();
    styleProps.textSize = textSize;
    styleProps.textCharSpacing = charSpacing;
    styleProps.textWeight = weight;
    styleProps.textStyle = style;
    styleProps.ellipsize = true;
    styleProps.textLineSpacing = lineSpacing;
    styleProps.maxSize = [maxWidth, maxHeight];
    styleProps.maxLines = maxLines;
    styleProps.textAnchor = this._anchorForLabel(label);
    styleProps.fontFamily = label.fontFamily;

    return textShaper.placeText(label.advancedPlacement && !label.advancedPlacement.failed ? label.advancedPlacement.data.glyphs : text, styleProps, this._fontTexture.glyphCache());
  },

  _labelPlacement: function (label) {
    var placement = label._shape ? label._shape : this._shapeLabel(label);
    label._shape = placement;
    if (placement == null) {
      return null;
    }
    var angleDegrees = label.angle * (180 / Math.PI);
    if (angleDegrees < 0) {
      angleDegrees += 360;
    }

    if (angleDegrees > 90 && angleDegrees < 270) {
      angleDegrees = angleDegrees - 180;
    }
    
    var angleRads = angleDegrees * (Math.PI / 180.);

    var placements = [];

    for(var i = 0; i < placement.glyphs.length; ++i) {
      var placementGlyph = placement.glyphs[i];
      var glyphData = placementGlyph.glyph;

      var atlasPlacement = this._fontTexture.getObjectCoordinates(glyphData.key);

      var textureIndex = atlasPlacement.textureIndex;
      var textureDimensions = atlasPlacement.coords;
      var x0 = placementGlyph.pos[0];
      var y0 = placementGlyph.pos[1];
      var x1 = x0 + placementGlyph.size[0];
      var y1 = y0 - placementGlyph.size[1];

      var s0 = textureDimensions.x;
      var t0 = textureDimensions.y;
      var s1 = textureDimensions.x + textureDimensions.width;
      var t1 = textureDimensions.y + textureDimensions.height;

      var v0 = {
        position: new L.Point(x0, y0),
        texCoord: new L.Point(s0, t1),
        size: {x: placementGlyph.size[0], y: placementGlyph.size[1]},
        textureId: textureIndex,
        angle: angleRads
      };

      var v1 = {
        position: new L.Point(x0, y1),
        texCoord: new L.Point(s0, t0),
        size: {x: placementGlyph.size[0], y: placementGlyph.size[1]},
        textureId: textureIndex,
        angle: angleRads
      };

      var v2 = {
        position: new L.Point(x1, y1),
        texCoord: new L.Point(s1, t0),
        size: {x: placementGlyph.size[0], y: placementGlyph.size[1]},
        textureId: textureIndex,
        angle: angleRads
      };

      var v3 = {
        position: new L.Point(x1, y0),
        texCoord: new L.Point(s1, t1),
        size: {x: placementGlyph.size[0], y: placementGlyph.size[1]},
        textureId: textureIndex,
        angle: angleRads
      };

      // 0, 1, 2, 0, 2, 3
      placements.push(v0);
      placements.push(v1);
      placements.push(v2);
      placements.push(v0);
      placements.push(v2);
      placements.push(v3);
    }
    return this._buildVertexBuffer(label, placements);
  },

  _loadAdvancedPlacementData: function(label, callback) {

    if (label.useAdvancedPlacement === undefined) {
      label.useAdvancedPlacement = CM.LabelRenderer.needsAdvPlacement(label.getText());
    }
    if (label.useAdvancedPlacement) {
      if (!label.advancedPlacement) {
        label.advancedPlacement = {
          ready: false,
          data: null,
          failed: false
        };
        this._placementloader.load(label, function (placement) {
          if (placement) {
            this.ready = true;
            this.data = placement;
          } else {
            this.failed = true;
          }
          callback();
        }.bind(label.advancedPlacement));
      } else {
        if (label.advancedPlacement.ready || label.advancedPlacement.failed) {
          callback();
        }
      }
    } else {
      label.advancedPlacement = {
        ready: false,
        data: null,
        failed: true
      };
      callback();
    }
  },

  _loadAdvancedPlacement: function(label, callback) {
    this._loadAdvancedPlacementData(label, function() {
      if (!label.advancedPlacement || label.advancedPlacement.failed || label.loadState == 2) {
        callback();
        return;
      }

      if (this._fontTexture.placementReady(label.advancedPlacement.data)) {
        label.loadState = 2;
        callback();
      } else if (!label.loadState) {
        label.loadState = 1;
        this._fontTexture.loadPlacement(label.advancedPlacement.data, function() {
          label.loadState = 2;
          callback();
        });
      }
    }.bind(this));
  },

  _loadEllipsis: function(label, callback) {
    if (label.ellipsisState != 2) {
      var requiredGlyphs = CM.LabelRenderer.REQUIRED_GLYPHS;
      if (this._fontTexture.stringReady(requiredGlyphs, label.fontFamily, label.fontWeight, label.textStyle)) {
        label.ellipsisState = 2;
        callback();
      } else if (!label.ellipsisState) {
        label.ellipsisState = 1;
        this._fontTexture.loadGlyphs(requiredGlyphs, label.fontFamily, label.fontWeight, label.textStyle, function() {
          label.ellipsisState = 2;
          callback();
        });
      }
    } else {
      callback();
    }
  },

  _loadCharacters: function(label, callback) {
    if (!label.useAdvancedPlacement || (label.advancedPlacement && label.advancedPlacement.failed)) {
      if (label.loadState != 2) {
        var requiredGlyphs = label.getText(); // Always make sure to include required glyphs in any label

        if (this._fontTexture.stringReady(requiredGlyphs, label.fontFamily, label.fontWeight, label.textStyle)) {
          label.loadState = 2;
          if (callback) {
            callback();
          }
        } else if (!label.loadState) {
          label.loadState = 1;
          this._fontTexture.loadGlyphs(requiredGlyphs, label.fontFamily, label.fontWeight, label.textStyle, function() {
            label.loadState = 2;
            if (callback) {
              callback();
            }
          });
        }
      } else {
        if (callback) {
          callback();
        }
      }
    } else {
      if (callback) {
        callback();
      }
    }
  },

  preloadLabel: function(label, callback) {

    if (this.isLabelReady(label)) {
      if (callback) {
        callback();
      }
      return;
    }

    var cb = function() {
      if (this.isLabelReady(label) && callback) {
        callback();
      }
    }.bind(this);

    if (!label.uuid) {
      label.uuid = Math.floor(Math.random() * 1000000);
    }

    this._loadAdvancedPlacement(label, function() {
      this._loadEllipsis(label, function() {
        this._loadCharacters(label, function() {
          cb();
        })
      }.bind(this));
    }.bind(this));
  },

  _buildVertexBuffer: function (label, placements) {

  },

  _updateVertexBuffer: function (label, buffer, offset) {

  },

  _getTechnique: function () {
    return "label";
  },

  _preRender: function (device, state, mesh) {

  }
});

CM.LabelRenderer.ELLIPSIS = 0x2026;

CM.LabelRenderer.REQUIRED_GLYPH_CHAR_IDS = [
  CM.LabelRenderer.ELLIPSIS
];

CM.LabelRenderer._RTLSearch = function(value, start, end) {
  var mid = Math.floor((start + end) / 2);

  var midRange = CM.LabelRenderer.RTL_RANGES[mid];
  if (midRange[0] <= value && midRange[1] >= value) {
    return true; // Equal
  } else if (end - start < 2) {
    return false;
  } else if (midRange[0] < value) {
    return CM.LabelRenderer._RTLSearch(value, mid, end); // Check upper
  } else{
    return CM.LabelRenderer._RTLSearch(value, start, mid); // Check lower
  }
};

CM.LabelRenderer.isRTL = function(char) {
  return CM.LabelRenderer._RTLSearch(char, 0, CM.LabelRenderer.RTL_RANGES.length);
};

CM.LabelRenderer.needsAdvPlacement = function(str) {
  for(var i = 0; i < str.length; ++i) {
    var codePoint = str.charCodeAt(i);
    if (CM.LabelRenderer.isRTL(codePoint)) {
      return true;
    }
  }
  return false;
};

// Must be ordered by the first element - uses binary search.
CM.LabelRenderer.RTL_RANGES = [
  [0x0590, 0x05FF],
  [0x0600, 0x06FF],
  [0x0750, 0x077F]
];

CM.LabelRenderer.MAX_PLACEMENT_FAILS = 3;

CM.LabelRenderer.REQUIRED_GLYPHS = String.fromCharCode.apply(null, CM.LabelRenderer.REQUIRED_GLYPH_CHAR_IDS);
CM.ScreenLabelRenderer = CM.LabelRenderer.extend({

  _glyphCenter: function(placement, index) {
    var start = index - (index % 6);

    var cx = 0, cy = 0;
    for(var i = start; i < start + 6; ++i) {
      cx += placement[i].position.x;
      cy += placement[i].position.y;
    }
    cx /= 6;
    cy /= 6;
    return {
      x:cx,
      y:cy
    };
  },

  _buildVertexBuffer: function (label, placements) {

    label.straightPlacement = placements;

    this.vertexSize = 8;
    this.vertexSizeBytes = 28;

    var vertexSize = this.vertexSizeBytes;
    var vertexSizeFloats = this.vertexSize;

    var text = label.getText();

    var shortMax = 32767;
    var ushortMax = 65535;

    var color = label.textColor;
    var outlineColor = label.outlineColor;

    var textSize = label.textSize;
    var outlineWidth = label.outlineWidth;

    var size = text.length * vertexSizeFloats * this._coords.length;

    var floatView = new Float32Array(size);
    var int16View = new Int16Array(floatView.buffer);
    var uint16View = new Uint16Array(floatView.buffer);
    var int8View = new Int8Array(floatView.buffer);
    var uint8View = new Uint8Array(floatView.buffer);

    var idx = 0;

    for (var p = 0; p < placements.length; p++) {
      var offset8 = idx * 4;
      var offset16 = idx * 2;
      var offset32 = idx;
      var glyphCenter = this._glyphCenter(placements, p);
      var placement = placements[p];

      int16View[offset16] = placement.position.x * 4;
      int16View[offset16 + 1] = placement.position.y * 4;

      uint16View[offset16 + 2] = placement.texCoord.x * ushortMax;
      uint16View[offset16 + 3] = placement.texCoord.y * ushortMax;

      uint8View[offset8 + 8] = color[0] * 255;
      uint8View[offset8 + 9] = color[1] * 255;
      uint8View[offset8 + 10] = color[2] * 255;
      uint8View[offset8 + 11] = color[3] * 255;

      uint8View[offset8 + 12] = outlineColor[0] * 255;
      uint8View[offset8 + 13] = outlineColor[1] * 255;
      uint8View[offset8 + 14] = outlineColor[2] * 255;
      uint8View[offset8 + 15] = outlineColor[3] * 255;

      uint8View[offset8 + 16] = textSize;
      uint8View[offset8 + 17] = outlineWidth * 4;
      uint8View[offset8 + 18] = 0;
      uint8View[offset8 + 19] = placement.textureId;

      uint8View[offset8 + 20] = placement.size.x;
      uint8View[offset8 + 21] = placement.size.y;
      int16View[offset16 + 11] = placement.angle * 1000;
      int16View[offset16 + 12] = 0;
      int16View[offset16 + 13] = 0;
      int16View[offset16 + 14] = glyphCenter.x * 4;
      int16View[offset16 + 15] = glyphCenter.y * 4;
      idx += vertexSizeFloats;
    }

    return floatView;
  },

  _writeFollowRoadData: function(outPlacements, label, glyphIndex, anchor, newOffset, angle) {
    var placements = label.straightPlacement;
    var placementStartingIndex = glyphIndex * 6;
    var oldOffset = placements[placementStartingIndex].position.x;
    var dx = newOffset - oldOffset;

    for(var i = 0; i < 6; ++i) {
      var straightPlacement = placements[placementStartingIndex + i];
      var outPlacement = outPlacements[placementStartingIndex + i];
      outPlacement.position.x = straightPlacement.position.x + dx;
      outPlacement.position.y = straightPlacement.position.y;
      outPlacement.anchor = anchor;
      outPlacement.angle = angle;
    }
  },

  _copyPlacement: function(label) {
    var copy = [];
    for(var i = 0; i < label.straightPlacement.length; ++i) {
      var original = label.straightPlacement[i];
      copy.push({
        position: {
          x: original.position.x,
          y: original.position.y
        },
        anchor: original.anchor,
        texCoord: original.texCoord,
        size: original.size,
        textureId: original.textureId,
        angle: original.angle
      });
    }
    return copy;
  },

  _followRoads: function(label) {

    if (label._followRoadFailed) {
      return null;
    }

    if (!label._followRoadPlacement) {
      label._followRoadPlacement = this._copyPlacement(label);
    }

    var followRoadPlacements = label._followRoadPlacement;

    var placements = label.straightPlacement;
    var numGlyphs = placements.length / 6;
    var path = label.pathPoints;
    var failed = false;
    var startingSegment = label.pathSegment;

    var featureIsUpsidedown = path[startingSegment + 1].x < path[startingSegment].x;

    var startingAnchor = label.position;

    var map = this.map;

    var prevBackAngle = null;
    var prevForwardAngle = null;
    var endIndex, offset, leftHalf, forward, end, newAnchorPoint;

    var distanceFunc = function(p1, p2) {
      var dx = p1.x - p2.x;
      var dy = p1.y - p2.y;
      return Math.sqrt((dx * dx) + (dy * dy));
    };

    var glyphXFunc = function(placements, index) {
      return placements[index * 6].position.x;
    };

    var MAX_ANGLES_DEGS = label._followRoadFailed ? 30 : 35;
    var MAX_ANGLE = MAX_ANGLES_DEGS / 360. * Math.PI;

    var tooSmallSegmentsCount = 0;

    var MAX_SMALL_SEGMENTS = 1;

    for(var glyph = 0; glyph < numGlyphs; ++glyph) {
       endIndex = startingSegment;
       offset = glyphXFunc(placements, glyph);
       leftHalf = offset < 0;
       forward = !leftHalf;
       tooSmallSegmentsCount = 0;
       if (featureIsUpsidedown) {
         forward = !forward;
       }
       if (forward) {
         endIndex++;
       }

      end = map.screenProject(path[endIndex]);
      newAnchorPoint = startingAnchor;

      offset = Math.abs(offset);
      while(true) {
        var distance = distanceFunc(end, newAnchorPoint);
        var tooSmall = distance < 3;
        var enoughDistance = distance > offset;

        if (enoughDistance && tooSmall) {
          tooSmallSegmentsCount++;
        }
        if (!tooSmall && enoughDistance) {
          if (leftHalf) {
            var dx = newAnchorPoint.x - end.x;
            var dy = newAnchorPoint.y - end.y;
            var angle = Math.atan2(dy, dx);
            if (prevBackAngle !== null && Math.abs(angle - prevBackAngle) > MAX_ANGLE) {
              failed = true;
              break;
            }
            prevBackAngle = angle;
            this._writeFollowRoadData(followRoadPlacements, label, glyph, newAnchorPoint, -offset, angle);
          } else {
            var dx = end.x - newAnchorPoint.x;
            var dy = end.y - newAnchorPoint.y;
            var angle = Math.atan2(dy, dx);

            var backToFrontFail = prevForwardAngle === null && Math.abs(angle - prevBackAngle) > MAX_ANGLE;
            var frontFail = prevForwardAngle !== null && Math.abs(angle - prevForwardAngle) > MAX_ANGLE;
            if (backToFrontFail || frontFail) {
              failed = true;
              break;
            }
            prevForwardAngle = angle;
            this._writeFollowRoadData(followRoadPlacements, label, glyph, newAnchorPoint, offset, angle);
          }
          break;
        } else {
          newAnchorPoint = end;
          endIndex += forward ? 1 : -1;
          if (tooSmallSegmentsCount > MAX_SMALL_SEGMENTS || endIndex < 0 || endIndex >= path.length) {
            failed = true;
            break;
          }
          offset -= distance;
          end = map.screenProject(path[endIndex]);
        }
      }
      if (failed) {
        break;
      }
    }
    label._followRoadFailed = failed;
    return failed ? null : followRoadPlacements;
  },

  _writeFailedPlacement: function(label, buffer, offset) {
    var int16View = new Int16Array(buffer.buffer);
    var uint8View = new Uint8Array(buffer.buffer);

    for (var p = 0; p < label.placements.length; p += this.vertexSize) {
      var offset16 = offset * 2;
      var offset8 = offset16 * 2;

      int16View[offset16 + 12] = -4000;
      int16View[offset16 + 13] = -4000;
      uint8View[offset8 + 18] = 0;

      offset += this.vertexSize;
    }
  },

  _writeFollowRoadPlacement: function(label, placements, buffer, offset) {
    var int16View = new Int16Array(buffer.buffer);
    var uint8View = new Uint8Array(buffer.buffer);

    for (var p = 0; p < placements.length; p++) {

      var placement = placements[p];
      var glyphCenter = this._glyphCenter(placements, p);

      var offset16 = offset * 2;
      var offset8 = offset16 * 2;

      // Local position
      int16View[offset16] = placement.position.x * 4;
      int16View[offset16 + 1] = placement.position.y * 4;

      // Anchor position
      int16View[offset16 + 12] = placement.anchor.x * 4;
      int16View[offset16 + 13] = placement.anchor.y * 4;

      // Angle
      int16View[offset16 + 11] = placement.angle * 1000;

      // Alpha
      uint8View[offset8 + 18] = label.alpha * 255;

      // Glyph center
      int16View[offset16 + 14] = glyphCenter.x * 4;
      int16View[offset16 + 15] = glyphCenter.y * 4;
      offset += this.vertexSize;
    }
  },

  _updateVertexBuffer: function (label, buffer, offset) {

    if (label.pathPoints && label.pathSegment !== null) {
      // follow road

      var followRoadPlacement = this._followRoads(label);
      if (!followRoadPlacement) {
        this._writeFailedPlacement(label, buffer, offset);
      } else {
        this._writeFollowRoadPlacement(label, followRoadPlacement, buffer, offset);
      }
    }
    else {
      var int16View = new Int16Array(buffer.buffer);
      var uint8View = new Uint8Array(buffer.buffer);

      for (var p = 0; p < label.placements.length; p += this.vertexSize) {
        var offset16 = offset * 2;
        var offset8 = offset16 * 2;

        // Anchor
        int16View[offset16 + 12] = label.position.x * 4;
        int16View[offset16 + 13] = label.position.y * 4;

        // Alpha
        uint8View[offset8 + 18] = label.alpha * 255;
        offset += this.vertexSize;
      }
    }
  }
});
CM.MapLabelRenderer = CM.LabelRenderer.extend({
  initialize: function (map, texture) {
    CM.LabelRenderer.prototype.initialize.call(this, texture);

    this._map = map;
  },

  _buildVertexBuffer: function (label, placements) {
    this.vertexSize = 7;

    var text = label.getText();

    var shortMax = 32767;
    var ushortMax = 65535;

    var color = label.textColor;
    var outlineColor = label.outlineColor;

    var textSize = label.textSize;
    var outlineWidth = label.outlineWidth;

    var vertexSize = 28;
    var vertexSizeFloats = vertexSize / 4;

    var size = text.length * vertexSizeFloats * this._coords.length;

    var floatView = new Float32Array(size);
    var int16View = new Int16Array(floatView.buffer);
    var uint16View = new Uint16Array(floatView.buffer);
    var int8View = new Int8Array(floatView.buffer);
    var uint8View = new Uint8Array(floatView.buffer);

    var idx = 0;

    for (var p = 0; p < placements.length; p++) {
      var offset8 = idx * 4;
      var offset16 = idx * 2;
      var offset32 = idx;

      var placement = placements[p];

      floatView[offset32] = label.position.lng;
      floatView[offset32 + 1] = label.position.lat;

      int16View[offset16 + 4] = placement.position.x * 4;
      int16View[offset16 + 5] = placement.position.y * 4;

      uint16View[offset16 + 6] = placement.texCoord.x * ushortMax;
      uint16View[offset16 + 7] = placement.texCoord.y * ushortMax;

      uint8View[offset8 + 16] = color[0] * 255;
      uint8View[offset8 + 17] = color[1] * 255;
      uint8View[offset8 + 18] = color[2] * 255;
      uint8View[offset8 + 19] = color[3] * 255;

      uint8View[offset8 + 20] = outlineColor[0] * 255;
      uint8View[offset8 + 21] = outlineColor[1] * 255;
      uint8View[offset8 + 22] = outlineColor[2] * 255;
      uint8View[offset8 + 23] = outlineColor[3] * 255;

      uint8View[offset8 + 24] = textSize;
      uint8View[offset8 + 25] = outlineWidth;

      idx += vertexSizeFloats;
    }

    return floatView;
  },

  _updateVertexBuffer: function (label, placements, buffer) {
  },

  _getTechnique: function () {
    return "map";
  },

  _preRender: function (device, state, mesh) {
    var bounds = this._map.getBounds();
    var lonRadius = (bounds.getEast() - bounds.getWest());
    var latRadius = (bounds.getNorth() - bounds.getSouth());

    var screenSize = this._map.getSize();

    var mapBounds = vec4.fromValues(bounds.getWest(), Math.sin(glMatrix.toRadian(bounds.getSouth())), lonRadius, latRadius);
    var mapSize = vec2.fromValues(screenSize.x, screenSize.y);

    state.setShaderData("u_mapBounds", new CM.ShaderData(mapBounds, 'vec4'));
    state.setShaderData("u_mapSize", new CM.ShaderData(mapSize, 'vec2'));
  }
});
CM.FixedSizeAtlasRenderer = CM.Renderer.extend({
  initialize: function (device, options) {

    this._textures = [];
    this._device = device;
    this._activeTextureSlots = {};
    this.options = options;
    this.size = options.size;
    this.slotSize = options.slotSize;

    this._slots = [];

    this._addTexture(device);
  },

  _addTexture: function (device) {
    var slots = this._slots;
    var gl = device.gl;

    for (var i = this.size.y - this.slotSize.y; i >= 0; i -= this.slotSize.y) {
      for (var j = this.size.x - this.slotSize.x; j >= 0; j -= this.slotSize.x) {
        slots.push({
          x: j / this.size.x,
          y: i / this.size.y,
          absolutePosition: new L.Point(j, i),
          textureId: this._textures.length,
          persistent:false,
          key:false,
          usages:0,
          width:0,
          height:0
        });
      }
    }

    var options = {
      screenRatio: Math.ceil(CM.Conf.devicePixelRatio || 1),
      colorTextureOptions: this.options.textureOptions
    };

    var target = new CM.RenderTarget(device, this.size.x, this.size.y, options);

    this._textures.push({
      target: target,
      texture: target.getColorTexture()
    });
  },

  delete: function() {
    for(var i = 0; i < this._textures.length; ++i) {
      var tex = this._textures[i];
      tex.target.delete();
    }
  },

  getTextureCount: function () {
    return this._textures.length;
  },

  findTexture: function (key, size, persistent) {
    var texture = this._activeTextureSlots[key];
    if (texture) {
      texture.usages += 1;
      return texture;
    } else {
      var slots = this._slots;
      if (slots.length > 0) {
        texture = slots.pop();
        texture.persistent = persistent;
        texture.key = key;
        texture.usages = 1;

        if (size) {
          texture.width = size.x / this.size.x;
          texture.height = size.y / this.size.y;
        } else {
          texture.width = this.slotSize.x / this.size.x;
          texture.height = this.slotSize.y / this.size.y;
        }

        this._activeTextureSlots[key] = texture;

        return texture;
      }

      // If we got here, then all slots are filled, so add another texture and repeat the process
      this._addTexture(this._device);
      return this.findTexture(key, size, persistent);
    }
  },

  returnTexture: function (key) {
    if (key in this._activeTextureSlots) {
      var texture = this._activeTextureSlots[key];
      texture.usages -= 1;

      if (texture.usages <= 0 && !texture.persistent) {
        texture.loaded = false;
        texture.drawn = false;
        texture.key = null;

        texture.usages = 0;

        this._slots.push(texture);
        delete this._activeTextureSlots[key];
      }
    }
  },

  renderTexture: function (device, texture, clearColor, bgColor, callback) {
    var gl = device.gl;
    
    var atlasState = new CM.RenderState();
    atlasState.projection = mat4.ortho(mat4.create(), 0.0, this.size.x, 0.0, this.size.y, -1.0, 1.0);
    atlasState.pushTransform(mat4.create());

    var target = this._textures[texture.textureId].target;
    target.activate();

    var rect = {
      origin: texture.absolutePosition,
      size: this.slotSize
    };

    target.clearRegion(rect, clearColor);

    gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);

    callback(device, atlasState);

    target.deactivate();

    texture.drawn = true;
  },

  resizeTexture: function (texture, size) {
    texture.width = size.x / this.size.x;
    texture.height = size.y / this.size.y;
  },

  getRenderTarget: function (i) {
    return this._textures[i].target;
  },

  getRenderTexture: function (i) {
    return this._textures[i].texture;
  }
});
CM.SpriteRenderer = CM.Renderer.extend({

  _mesh: null,
  _objects: null,
  _floatArray: null,
  _textureAtlas: null,
  _objectCount: 0,

  initialize: function (device) {
    this._floatArray = new Float32Array(0);

    var gl = device.gl;
    this._mesh = new CM.Mesh(device, "sprite_batch", {
      vertexBufferUsage: gl.DYNAMIC_DRAW
    });
    this._mesh.setTechnique("src_alpha");
  },

  /*
    objects: array
    See SpriteRenderer.Object for the fields expected for each object.
   */

  setObjects: function (objects, textureAtlas) {

    this._textureAtlas = textureAtlas;
    this._objectCount = objects.length;

    var coords = CM.SpriteRenderer.VERTS;

    var numFloats = objects.length * CM.SpriteRenderer.VERT_FLOAT_SIZE * coords.length;
    this._floatArray = new Float32Array(numFloats);

    //if (this._floatArray.length < numFloats) {
    //  this._floatArray = new Float32Array(numFloats);
    //}

    var floatArray = this._floatArray;
    var uint8Array = new Uint8Array(floatArray.buffer);
    var uint16Array = new Uint16Array(floatArray.buffer);
    var int16Array = new Int16Array(floatArray.buffer);

    var ushortMax = 65535;

    var idx = 0;

    for(var i = 0; i < objects.length; ++i) {
      var object = objects[i];

      if (!object.slotName || !object.position || !object.size) {
        continue;
      }

      var slot = textureAtlas.getObjectCoordinates(object.slotName);
      if (!slot) {
        continue;
      }

      var origin = object.position.add(object.anchorPoint.multiply(object.size));

      for (var j = 0; j < coords.length; j++) {
        var offset16 = idx * 2;
        var offset8 = idx * 4;

        var point = object.position.add(coords[j].multiply(object.size));
        var rotatedPoint = CM.GeoUtils.rotatePoint(point, object.angle, origin);

        int16Array[offset16] = rotatedPoint.x * 4;
        int16Array[offset16 + 1] = rotatedPoint.y * 4;

        uint16Array[offset16 + 2] = (slot.x + (slot.width * coords[j].x)) * ushortMax;
        uint16Array[offset16 + 3] = (slot.y + (slot.height * coords[j].y)) * ushortMax;

        uint8Array[offset8 + 8] = object.blendColor[0] * 255;
        uint8Array[offset8 + 9] = object.blendColor[1] * 255;
        uint8Array[offset8 + 10] = object.blendColor[2] * 255;
        uint8Array[offset8 + 11] = object.blendColor[3] * 255;

        uint8Array[offset8 + 12] = object.alpha * 255;
        uint8Array[offset8 + 13] = 0;

        idx += CM.SpriteRenderer.VERT_FLOAT_SIZE;
      }
    }

    this._mesh.setData(floatArray, numFloats / CM.SpriteRenderer.VERT_FLOAT_SIZE);
  },

  cleanup: function() {
    if (this._mesh) {
      this._mesh.cleanup();
    }
  },

  render: function(device, state) {
    var gl = device.gl;

    if (this._textureAtlas && this._objectCount > 0) {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      this._textureAtlas.activate(gl.TEXTURE0);
      state.setShaderData('u_texture[0]', new CM.ShaderData(0, 'texture'));

      this._mesh.draw(device, state, gl.TRIANGLES);
      gl.disable(gl.BLEND);
    }
  }
});

CM.SpriteRenderer.Object = L.Class.extend({
  position: null,
  size: null,
  slotName: undefined,
  alpha: 1,
  blendColor: [1,1,1,1],
  angle: 0,
  anchorPoint: new L.Point(0.5, 0.5),

  initialize: function(extend) {
    this.position = extend.position;
    this.size = extend.size;
    this.slotName = extend.slotName;
    this.alpha = extend.alpha !== undefined ? extend.alpha : this.alpha;
    this.blendColor = extend.blendColor || this.blendColor;
    this.angle = extend.angle || 0;
  }
});

CM.SpriteRenderer.VERT_BYTE_SIZE = 16;
CM.SpriteRenderer.VERT_FLOAT_SIZE = 4;

CM.SpriteRenderer.VERTS = [
  new L.Point(0.0, 0.0),
  new L.Point(1.0, 0.0),
  new L.Point(0.0, 1.0),
  new L.Point(1.0, 0.0),
  new L.Point(0.0, 1.0),
  new L.Point(1.0, 1.0)
];
CM.VectorRenderer = CM.Renderer.extend({

  _map: null,
  _tiles: null,
  _labelRenderer: null,
  _spriteRenderer: null,
  _iconRenderer: null,

  initialize: function (map, device) {

    this._map = map;

    this._tiles = [];
    this._icons = [];
    this._badges = [];
    this._labels = [];
    this._iconRequests = {};

    this._style = new CM.VectorStyle();
    this._style.setData(DEFAULT_MAP_STYLE);
    this._loadRemoteFiles();

    this._labelRenderer = new CM.ScreenLabelRenderer(map, map._engine.getFontTexture());
    this._iconRenderer = new CM.SpriteRenderer(device);

    this._iconAtlas = new CM.TextureAtlas(device, {
      size: new L.Point(512, 512),
      baseData: new Uint8Array(512 * 512 * 4)
    });
  },

  cleanup: function() {
    if (this._iconAtlas) {
      this._iconAtlas.delete();
    }
    if (this._labelRenderer) {
      this._labelRenderer.cleanup();
    }
    if (this._iconRenderer) {
      this._iconRenderer.cleanup();
    }
  },

  reloadStyle: function() {
    this._remoteFilesLoaded = false;
    this._polygonTextureAtlas = null;
    this._loadRemoteFiles();
  },

  clear: function() {
    this._tiles = [];
    this._icons = [];
    this._labels = [];
  },

  addVectorTile: function(tile) {
    this._tiles.push(tile);
  },

  addIcon: function(sprite) {
    this._icons.push(sprite);
  },

  addLabel: function(label) {
    this._labels.push(label);
  },

  isReady: function () {
    return this._remoteFilesLoaded;
  },

  _loadRemoteFiles: function () {
    var promises = [],
      remoteFiles = this._style.profile.remote_files;

    this._remoteFiles = {};

    if (remoteFiles.length > 0) {

      for (var i = 0; i < remoteFiles.length; i++) {
        var file = remoteFiles[i];
        promises.push(new Promise(function (file, resolver) {
          var image = new Image();
          image.crossOrigin = 'anonymous';
          image.src = file;
          image.onload = function (file, resolver) {
            this._remoteFiles[file] = image;
            resolver();
          }.bind(this, file, resolver);

          image.onerror = function (file, resolver) {
            this._remoteFiles[file] = null;
            resolver();
          }.bind(this, file, resolver);
        }.bind(this, file)));
      }

      Promise.all(promises).then(function () {
        this._remoteFilesLoaded = true;
      }.bind(this));
    } else {
      this._remoteFilesLoaded = true;
    }
  },

  _loadIconIfNeeded: function(assetName) {
    if (this._iconAtlas.getObjectCoordinates(assetName)) {
      return;
    }
    if (this._iconRequests[assetName]) {
      return;
    }

    this._iconRequests[assetName] = true;

    CM.Network.loadImage(CM.Conf.baseUrl + "/assets/images/" + assetName + ".png").then(function (assetName, image) {
      if (image) {
        this._iconAtlas.addObject(assetName, image, image, new L.Point(image.width, image.height));
      }
    }.bind(this, assetName));
  },

  getPolygonTextureAtlasObjects: function() {
    return this._polygonTextureAtlas ? this._polygonTextureAtlas.getObjects() : null;
  },

  _notifyRemoteFilesAtlasComplete: function() {
    this._map.fire(CM.VectorRenderer.REMOTE_FILES_FINISHED_EVENT, {
      textures: this._polygonTextureAtlas.getObjects()
    });
  },

  _createPolygonAtlas: function(device) {
    if (!this._polygonTextureAtlas) {
      var textureSize = CM.VectorRenderer.TEXTURE_ATLAS_SIZE;

      this._polygonTextureAtlas = new CM.TextureAtlas(device, {
        width: textureSize,
        height: textureSize,
        baseData: new Uint8Array(textureSize * textureSize * 4),
        textureOptions: {}
      });

      for (var filename in this._remoteFiles) {
        var image = this._remoteFiles[filename];
        if (image) {
          this._polygonTextureAtlas.addObject(filename, image, image, new L.Point(image.width, image.height))
        } else {
          CM.Console.log("ERROR LOADING IMAGE");
        }
      }

      this._notifyRemoteFilesAtlasComplete();
    }
  },

  _renderTiles: function(deltaMillis, device, state) {
    var gl = device.gl;

    state.setShaderData("u_texture", new CM.ShaderData(0, 'texture'));
    this._polygonTextureAtlas.activate(gl.TEXTURE0);

    var resolutionData = new CM.ShaderData(this._map._resolution, 'float');
    state.setShaderData("u_resolution", resolutionData);

    var baseResolution = CM.GeoUtils.getResolutionForZoom(Math.floor(this._map.getZoom()));
    state.setShaderData("u_baseResolution", new CM.ShaderData(baseResolution, 'float'));

    // The padding needs to always be one pixel. Resolution above caps at zoom 18, not max. need to use correct res here
    var paddingData = new CM.ShaderData(this._map._resolution, 'float');
    state.setShaderData("u_aaPadding", paddingData);

    var hillshadeLayer = this._style.getLayerByName("hillshade");
    var hasHillshade = false;

    if (hillshadeLayer) {
      var hillshadeStyle = this._style.getStyleForFeature(this._style.getLayerIndexForId(hillshadeLayer.id), {},
        this._map.getZoom(), 0, 0);

      var azimuth = hillshadeStyle.get("hillshade-azimuth-angle") || 0;
      var altitude = hillshadeStyle.get("hillshade-altitude") || 0;
      var zFactor = hillshadeStyle.get("hillshade-z-factor") || 0;
      var hillshadeFactor = hillshadeStyle.get("hillshade-factor") || 0;
      var colorFactor = hillshadeStyle.get("hillshade-color-factor") || 0;

      if (altitude > 0) {
        hasHillshade = true;
      }

      var minZoom = CM.Conf.elevation.minLandCoverZoom;
      var maxZoom = CM.Conf.elevation.maxLandCoverZoom;
      var landFactor = Math.max(0, Math.min(1.0 - ((this._map.getZoom() - minZoom) / (maxZoom - minZoom)), 1.0));

      state.setShaderData("u_azimuthAngle", new CM.ShaderData(CM.GeoUtils.degressToRadians(360.0 - azimuth + 90.0), 'float'));
      state.setShaderData("u_zenithAngle", new CM.ShaderData(CM.GeoUtils.degressToRadians(90.0 - altitude), 'float'));
      state.setShaderData("u_zFactor", new CM.ShaderData(zFactor, 'float'));
      state.setShaderData("u_hillshadeFactor", new CM.ShaderData(hillshadeFactor, 'float'));
      state.setShaderData("u_colorFactor", new CM.ShaderData(colorFactor, 'float'));
      state.setShaderData("u_landFactor", new CM.ShaderData(landFactor, 'float'));
      

    }

    var landLayerIdx = this._style.getLayerIndexForName("land");
    state.setShaderData("u_landLayerId", new CM.ShaderData(landLayerIdx, 'float'));

    var polygonTextures = this._polygonTextureAtlas.getObjects();
    var numTextures = Object.keys(polygonTextures).length;
    var textureDimensions = new Float32Array(numTextures * 4);
    for (var i in polygonTextures) {
      var texture = polygonTextures[i];

      var index = texture.index * 4;
      textureDimensions[index] = texture.x;
      textureDimensions[index + 1] = texture.y;
      textureDimensions[index + 2] = texture.width;
      textureDimensions[index + 3] = texture.height;
    }
    state.setShaderData("u_texDimensions", new CM.ShaderData(textureDimensions, 'vec4', numTextures));

    var maxPolyPass = 0, maxLinePass = 0, maxTransparentPolyPass = 0;
    var key, tile, pass;
    for (key in this._tiles) {
      tile = this._tiles[key];
      maxPolyPass = Math.max(maxPolyPass, tile.numOpaquePolygonPasses());
      maxLinePass = Math.max(maxLinePass, tile.numLinePasses());
      maxTransparentPolyPass = Math.max(maxTransparentPolyPass, tile.numTransparentPolygonPasses());
    }

    var tileSize = this._map.getBaseLayer().options.tileSize;

    gl.disable(gl.BLEND);


    for (pass = 0; pass < maxPolyPass; ++pass) {
      for (key in this._tiles) {
        tile = this._tiles[key];
        if (tile.isReady()) {
          thisTileSize = tileSize * Math.pow(2, Math.floor(this._map.getZoom()) - tile.coords.z);
          state.setShaderData("u_tileSize", new CM.ShaderData(thisTileSize, 'float'));
          tile.renderOpaquePolygons(deltaMillis, device, state, pass, hasHillshade);
        }
      }
    }

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.STENCIL_TEST);
    gl.stencilFunc(gl.NOTEQUAL, 1, 1111111);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    var lastTileSize = 0;

    for (pass = 0; pass < maxTransparentPolyPass; ++pass) {
      for (key in this._tiles) {
        tile = this._tiles[key];
        if (tile.isReady()) {
          var thisTileSize = tileSize * Math.pow(2, Math.floor(this._map.getZoom()) - tile.coords.z);
          if (thisTileSize != lastTileSize) {
            state.setShaderData("u_tileSize", new CM.ShaderData(thisTileSize, 'float'));
            lastTileSize = thisTileSize;
          }
          var tileHasHillshade = hasHillshade;
          if (tile.coords.z > CM.Conf.elevation.maxZoom) {
            tileHasHillshade = false;
          }
          tile.renderTransparentPolygons(deltaMillis, device, state, pass, tileHasHillshade);
        }
      }
    }
    gl.disable(gl.STENCIL_TEST);

    for (pass = 0; pass < maxLinePass; ++pass) {
      for (key in this._tiles) {
        tile = this._tiles[key];
        if (tile.isReady()) {
          tile.renderLines(deltaMillis, device, state, pass);
        }
      }
    }

    gl.disable(gl.BLEND);
  },

  render: function(deltaMillis, device, state, orthoState) {

    if (!this.isReady()) {
      return;
    }
    this._createPolygonAtlas(device);
    this._renderTiles(deltaMillis, device, state);

    for(var i = 0; i < this._icons.length; ++i) {
      this._loadIconIfNeeded(this._icons[i].slotName);
    }

    if (this._iconAtlas) {
      this._iconRenderer.setObjects(this._icons, this._iconAtlas);
      this._iconRenderer.render(device, orthoState);
    }

    this._labelRenderer.removeAllObjects();
    this._labelRenderer.addObjects(this._labels);
    this._labelRenderer.render(device, orthoState);
  }
});

CM.VectorRenderer.TEXTURE_ATLAS_SIZE = 1024;
CM.VectorRenderer.REMOTE_FILES_FINISHED_EVENT = 'vector_renderer_remote_files_finished';
CM.GlyphCache = L.Class.extend({
  initialize: function () {
    this._glyphs = {};
    this._glyphLoader = new CM.NetworkGlyphLoader();
    this._stringCache = {};
    this._callbacks = {};

  },

  loadGlyph: function (glyphDesc, callback) {
    var gkey = CM.GlyphCache.keyFor(glyphDesc);

    var glyph = this._glyphs[gkey];

    if (glyph && glyph.ready) {
      if (callback) {
        callback(glyph);
      }
      return;
    }

    this._addGlyphCallback(gkey, callback);
    if (glyph) {
      return;
    }

    glyph = new CM.Glyph();
    glyph.key = gkey;
    this._addGlyph(glyph);
    this._glyphLoader.load(glyph, glyphDesc, function() {
      this._notifyCallbacks(gkey, glyph);
    }.bind(this));
  },

  _addGlyphCallback: function(key, callback) {
      var list = this._callbacks[key];
      if (!list) {
        list = [callback];
        this._callbacks[key] = list;
      } else {
        list.push(callback);
      }
  },

  _notifyCallbacks: function(key, glyph) {
    var list = this._callbacks[key];
    if (list) {
      for(var i = 0; i < list.length; ++i) {
        list[i](glyph);
      }
      delete this._callbacks[key];
    }
  },

  loadGlyphs: function (string, font, weight, style, callback) {

    var skey = CM.GlyphCache.stringKeyFor(string, font, weight, style);

    if (this.stringReady(string, font, weight, style)) {
      if (callback) {
        callback();
      }
      return;
    }

    var glyphDesc = new CM.GlyphDesc();
    glyphDesc.style = style;
    glyphDesc.weigh = weight;
    glyphDesc.font = font;

    var returned = 0;

    for (var i = 0; i < string.length; i++) {
      glyphDesc.charCode = string.charCodeAt(i);

      this.loadGlyph(glyphDesc, function () {
        returned += 1;
        if (returned == string.length) {
          console.log("string is loaded " + skey);
          if (callback) {
            callback();
          }
        }
      });
    }
  },

  _addGlyph: function (glyph) {
    this._glyphs[glyph.key] = glyph;
  },

  getGlyph: function (glyphDesc) {
    var gkey = glyphDesc.key ? glyphDesc.key : CM.GlyphCache.keyFor(glyphDesc);
    var glyph = this._glyphs[gkey];
    return (glyph && glyph.ready) ? glyph : null;
  },

  isGlyphLoaded: function (glyphDesc) {
    var gkey = glyphDesc.key ? glyphDesc.key : CM.GlyphCache.keyFor(glyphDesc);
    var glyph = this._glyphs[gkey];
    return glyph && glyph.ready;
  },

  placementReady: function(placement) {
    var glyphDesc = new CM.GlyphDesc();

    for(var i = 0; i < placement.glyphs.length; ++i) {
      var glyph = placement.glyphs[i];
      glyphDesc.fontFace = glyph.fontFace;
      glyphDesc.glyphIndex = glyph.glyphIndex;
      if (!this.isGlyphLoaded(glyphDesc)) {
        return false;
      }
    }
    return true;
  },

  stringReady: function (string, font, weight, style) {
    weight = weight || 400;
    style = style || 'regular';

    var stringCacheKey = CM.GlyphCache.stringKeyFor(string, font, weight, style);

    if (this._stringCache.hasOwnProperty(stringCacheKey)) {
      return true;
    }

    var glyphDesc = new CM.GlyphDesc();
    glyphDesc.style = style;
    glyphDesc.weight = weight;
    glyphDesc.font = font;

    for (var i = 0; i < string.length; i++) {
      glyphDesc.charCode = string.charCodeAt(i);
      if (!this.isGlyphLoaded(glyphDesc)) {
        return false;
      }
    }
    this._stringCache[stringCacheKey] = true;
    return true;
  }
});

CM.GlyphCache.stringKeyFor = function (string, font, weight, style) {
    return string + ":" + font + ":" + weight + ":" + style;
};

CM.GlyphCache.keyFor = function (glyphDesc) {
  if (glyphDesc.fontFace) {
    return glyphDesc.fontFace + ":" + glyphDesc.glyphIndex;
  } else {
    return glyphDesc.font + ":" + glyphDesc.charCode + ":" + (glyphDesc.weight || 400) + ":" + (glyphDesc.style ? glyphDesc.style : '');
  }
};


CM.Glyph = L.Class.extend({

  setData: function (data) {
    var view = new DataView(data);
    var cursor = 0;

    this.baseTextSize = view.getInt32(cursor, true);
    cursor += 4;

    this.baseSize = new L.Point(view.getFloat32(cursor, true), view.getFloat32(cursor + 4, true));
    cursor += 8;

    this.baseBearing = new L.Point(view.getFloat32(cursor, true), view.getFloat32(cursor + 4, true));
    cursor += 8;

    this.baseAdvance = view.getFloat32(cursor, true);
    cursor += 4;

    this.bitmapSize = new L.Point(view.getInt32(cursor, true), view.getInt32(cursor + 4, true));
    cursor += 8;

    this.lineHeight = view.getInt32(cursor, true);
    cursor += 4;

    this.kerningPairs = {};
    var numKerningPairs = view.getInt32(cursor, true);
    cursor += 4;

    if (isNaN(this.baseBearing.x)) {
      this.baseBearing.x = 0;
    }
    if (isNaN(this.baseBearing.y)) {
      this.baseBearing.y = 0;
    }
    if (isNaN(this.baseSize.x)) {
      this.baseSize.x = 0;
    }
    if (isNaN(this.baseSize.y)) {
      this.baseSize.y = 0;
    }

    for (var i = 0; i < numKerningPairs; i++) {
      var char = view.getInt32(cursor, true);
      cursor += 4;
      var distance = view.getInt32(cursor, true);
      cursor += 4;

      this.kerningPairs[char] = distance;
    }

    // The rest is the data
    this.data = new Uint8Array(view.buffer.slice(cursor));
  },

  calculateMetrics: function (textSize) {
    var ratio = textSize / this.baseTextSize;

    return {
      size: this.baseSize.multiplyBy(ratio),
      bearing: this.baseBearing.multiplyBy(ratio),
      advance: this.baseAdvance * ratio,
      lineHeight: this.lineHeight * ratio
    }
  },

  setBlank: function() {
    this.baseTextSize = 0;
    this.baseSize = new L.Point(0,0);
    this.baseBearing = new L.Point(0,0);
    this.baseAdvance = 0;
    this.bitmapSize = new L.Point(0,0);
    this.lineHeight = 0;
    this.kerningPairs = {};
    this.data = new Uint8Array(0);
  }
});
CM.GlyphDesc = L.Class.extend({
  charCode: 0,
  style: 'regular',
  weight: 400,
  font: null,
  fontFace: null,
  glyphIndex: 0
});
CM.NetworkPlacement = L.Class.extend({

  initialize: function () {

  },

  setData: function (data) {

    data = JSON.parse(data);

    var glyphs = [];

    for(var i = 0; i < data.glyphs.length; ++i) {
      var dataGlyph = data.glyphs[i];
      glyphs.push({
        fontFace: dataGlyph.font_file,
        charCode: dataGlyph.char_code,
        glyphIndex: dataGlyph.glyph_index,
        offset: dataGlyph.offset,
        advance: dataGlyph.advance,
        lineNumber: dataGlyph.line_number || 0
      })
    }
    this.glyphs = glyphs;
  }
});
CM.GlyphLoader = L.Class.extend({
  load: function (glyph, callback) {
  }
});
CM.NetworkGlyphLoader = CM.GlyphLoader.extend({
  initialize: function (baseUrl) {},

  load: function (glyph, glyphDesc, callback) {

    var url;
    if (glyphDesc.fontFace) {
      url = CM.Conf.glyphPathByIndex.replace('{file}', glyphDesc.fontFace).replace('{index}', glyphDesc.glyphIndex);
    } else {
      if (CM.NetworkGlyphLoader.BLACKLISTED_GLYPH_CHAR_IDS[glyphDesc.charCode]) {
        glyph.setBlank();
        if (callback) {
          callback(glyph);
        }
        return;
      }
      url = CM.Conf.glyphPathForChar + glyphDesc.font + "/" + glyphDesc.charCode + "?style=" + glyphDesc.style + "&weight=" + glyphDesc.weight + "&version=" + CM.NetworkGlyphLoader.VERSION;
    }

    CM.Network.send(url, {
      success: function (data) {
        glyph.setData(data);
        glyph.ready = true;
        if (callback) {
          callback(glyph);
        }
      },
      responseType: 'arraybuffer'
    });
  }
});

CM.NetworkGlyphLoader.VERSION = "09112015";

// ETK - These are the unicode bidi glyphs. They are all non-visual and don't really need to be loaded.
CM.NetworkGlyphLoader.BLACKLISTED_GLYPH_CHAR_IDS = {
  0x202A: true,
  0x202B: true,
  0x202C: true,
  0x202D: true,
  0x202E: true,
  0x2066: true,
  0x2067: true,
  0x2068: true,
  0x2069: true,
  0x200E: true,
  0x200F: true,
  0x061C: true
};

CM.NetworkPlacementLoader = L.Class.extend({
  initialize: function () {
    this.failCount = 0;
    this.maxFails = 3;
    this.networkQueue = new CM.NetworkQueue(8);
  },

  load: function (label, callback) {

    var t = this;
    var maxWidth = label.size ? label.size.x : 0;
    var maxHeight = label.size ? label.size.y : 0;
    var params = {
      font: label.fontFamily,
      text: encodeURIComponent(label.getText()),
      size: label.textSize,
      weight: label.fontWeight || 400,
      style: label.textStyle || 'regular',
      char_spacing: 0,
      line_spacing: label.textLineSpacing || 0,
      ellipsize: true,
      max_width: maxWidth,
      max_height: maxHeight
    };

    var paramStrs = [];
    for(var k in params) {
      var val = params[k];
      if (val != null) {
        paramStrs.push(k + "=" + val);
      }
    }
    var qs = paramStrs.join('&');
    var url = CM.Conf.labelPlacementPath + "?" + qs;

    this.networkQueue.send(url, {
      success: function (data) {
        if (data) {
          var labelPlacement = new CM.NetworkPlacement();
          labelPlacement.setData(data);
          if (callback) {
            callback(labelPlacement);
          }
        } else {
          callback(null);
        }
      }.bind(this),
      error: function(data) {
        t.failCount++;
        callback(null);
      },
      continueSend: function() {
        return t.failCount < t.maxFails;
      }
    });
  },
});
CM.FontTexture = L.Class.extend({
  initialize: function (device) {
    var gl = device.gl;

    this._atlasOptions = {
      size: CM.FontTexture.atlasSize,
      padding: new L.Point(2, 2),
      textureOptions: {
        dataFormat: gl.ALPHA,
        internalFormat: gl.ALPHA,
        minFilter: gl.NEAREST,
        magFilter: gl.NEAREST
      }
    };

    this._device = device;
    this._glyphCache = new CM.GlyphCache();
    this._textures = [];

    this._addPage();
    this._activePage = 0;
  },

  _addPage: function () {
    this._textures.push(new CM.TextureAtlas(this._device, this._atlasOptions));
    this._activePage += 1;
  },

  delete: function() {
    for(var i = 0; i < this._textures.length; ++i) {
      this._textures[i].delete();
    }
  },

  loadGlyph: function (glyphDesc, callback) {
    if (this._glyphCache.isGlyphLoaded(glyphDesc)) {
      if (callback) {
        callback();
      }
      return;
    }

    this._glyphCache.loadGlyph(glyphDesc, function (glyph) {
      if (glyph.textureId == undefined) {
        var key = glyph.key;
        var texture = this._textures[this._activePage];
        if (!texture.canFit(glyph.bitmapSize)) {
          this._addPage();
          texture = this._textures[this._activePage];
        }
        if (!texture._objects.hasOwnProperty(key)) {
          texture.addObject(key, glyph, glyph.data, glyph.bitmapSize);
          glyph.textureId = this._activePage;
        }
      }
      if (callback) {
        callback(glyph);
      }
    }.bind(this));
  },

  glyphCache: function() {
    return this._glyphCache;
  },

  getGlyph: function (glyphDesc) {
    return this._glyphCache.getGlyph(glyphDesc);
  },

  placementReady: function(placement) {
    return this._glyphCache.placementReady(placement);
  },

  loadPlacement: function(placement, callback) {
    var nReturned = 0;
    var count = placement.glyphs.length;

    var glyphDesc = new CM.GlyphDesc();

    for (var i = 0; i < count; i++) {
      var placementGlyph = placement.glyphs[i];

      glyphDesc.fontFace = placementGlyph.fontFace;
      glyphDesc.glyphIndex = placementGlyph.glyphIndex;

      this.loadGlyph(glyphDesc, function () {
        nReturned++;
        if (nReturned == count) {
          if (callback) {
            callback();
          }
        }
      }.bind(this));
    }
  },

  stringReady: function (string, font, weight, style) {
    return this._glyphCache.stringReady(string, font, weight, style);
  },

  loadGlyphs: function (string, font, weight, style, callback) {
    var nReturned = 0;
    var count = string.length;

    var glyphDesc = new CM.GlyphDesc();
    glyphDesc.font = font;
    glyphDesc.style = style;
    glyphDesc.weight = weight;

    for (var i = 0; i < string.length; i++) {
      glyphDesc.charCode = string.charCodeAt(i);

      this.loadGlyph(glyphDesc, function () {
        nReturned++;
        if (nReturned == count) {
          if (callback) {
            callback();
          }
        }
      }.bind(this));
    }
  },

  activate: function (slot) {
    for (var i = 0; i < this._textures.length; i++) {
      this._textures[i].activate(slot + i);
    }
  },

  getObjectCoordinates: function (key) {
    for (var i = 0; i < this._textures.length; i++) {
      var texture = this._textures[i];
      var object = texture.getObjectCoordinates(key);
      if (object) {
        return {
          textureIndex: i,
          coords: object
        };
      }
    }

    return null;
  },

  getTextureCount: function () {
    return this._textures.length;
  }
});

CM.FontTexture.atlasSize = new L.Point(2048, 2048);
CM.FontTexture.slotSize = new L.Point(64, 64);
CM.FontTexture.maxPages = 4;
CM.TextShaper = L.Class.extend({
  initialize: function () {
  },

  placeText: function (labelOrGlyphs, styleProps, glyphCache) {

    var isString = typeof labelOrGlyphs === 'string';
    var placement;
    if (isString) {
      placement = this._placeTextNormal(labelOrGlyphs, styleProps, glyphCache);
    } else {
      placement = this._placeTextAdvanced(labelOrGlyphs, styleProps, glyphCache);
    }

    if (placement != null) {
      if (placement.glyphs.length == 0) {
        placement.minX = placement.minY = placement.maxX = placement.maxY = 0;
      } else {
        placement.minX = placement.minY = placement.maxX = placement.maxY = undefined;
      }
      for(var i = 0; i < placement.glyphs.length; ++i) {
        var g = placement.glyphs[i];

        placement.minX = placement.minX === undefined ? g.pos[0] : Math.min(placement.minX, g.pos[0]);
        placement.minY = placement.minY === undefined ? (g.pos[1] - g.size[1]) : Math.min(placement.minY, g.pos[1] - g.size[1]);
        placement.maxX = placement.maxX === undefined ? (g.pos[0] + g.size[0]) : Math.max(placement.maxX, g.pos[0] + g.size[0]);
        placement.maxY = placement.maxY === undefined ? g.pos[1] : Math.max(placement.maxY, g.pos[1]);
      }
    }
    return placement;
  },

  _placeTextNormal: function(label, styleProps, glyphCache) {
    var placement = this._placeText(label, 0, label.length, styleProps, glyphCache);
    if (placement == null) {
      return null;
    }
    var lineDetails = this._breakIntoLines(placement, styleProps);
    this._ellipsizeText(placement, lineDetails, styleProps, glyphCache);
    this._adjustGlyphsForLines(placement, lineDetails, styleProps);

    return placement;
  },

  _placeTextAdvanced: function(glyphs, styleProps, glyphCache) {
    var placement = this._placeText(glyphs, 0, glyphs.length, styleProps, glyphCache);
    if (placement == null) {
      return null;
    }
    var lineDetails = this._breakIntoLinesAdvanced(placement, glyphs, styleProps);
    this._adjustGlyphsForLines(placement, lineDetails, styleProps);

    return placement;
  },

  _placeText: function(labelOrGlyphs, begin, end, lineParams, glyphCache) {

    var placement = new CM.TextShaper.Placement();

    var textSize = lineParams.textSize;
    var charSpacing = lineParams.textCharSpacing;
    var weight = lineParams.textWeight;
    var style = lineParams.textStyle;

    var x = 0;
    var y = textSize;

    var glyphDesc = new CM.GlyphDesc();

    var isString = typeof labelOrGlyphs === 'string';
    if (isString) {
      glyphDesc.style = style;
      glyphDesc.weight = weight;
      glyphDesc.font = lineParams.fontFamily;
    }

    for(var i = begin; i < end; ++i) {
      var advPlacement = null;
      if (isString) {
        glyphDesc.charCode = labelOrGlyphs.charCodeAt(i);
      } else {
        advPlacement = labelOrGlyphs[i];
        glyphDesc.charCode = advPlacement.charCode;
        glyphDesc.glyphIndex = advPlacement.glyphIndex;
        glyphDesc.fontFace = advPlacement.fontFace;
      }
      var placedGlyph = this._placeGlyph(glyphDesc, charSpacing, textSize, glyphCache, x, y, advPlacement);
      if (placedGlyph == null) {
        return null;
      }
      placement.glyphs.push(placedGlyph);

      var x1 = placedGlyph.pos[0] + placedGlyph.size[0];
      var y1 = placedGlyph.pos[1] - placedGlyph.size[1];
      x += placedGlyph.advance[0];
      y += placedGlyph.advance[1];
    }

    placement.cursorX = x;
    placement.cursorY = y;
    return placement;
  },

  _placeGlyph: function(glyphDesc, charSpacing, textSize, glyphCache, x, y, advPlacement) {
    var glyph = glyphCache.getGlyph(glyphDesc);
    if (!glyph) {
      return null;
    }
    var metrics = glyph.calculateMetrics(textSize);
    var xa = 0, ya = 0, xo = 0, yo = 0;

    if (advPlacement) {
      xo = advPlacement.offset.x;
      yo = advPlacement.offset.y;
      xa = advPlacement.advance.x;
      ya = advPlacement.advance.y;
    } else {
      xa = charSpacing + metrics.advance;
    }

    var x0 = x + xo + metrics.bearing.x;
    var y0 = y + yo - (metrics.bearing.y - metrics.size.y);
    var placedGlyph = new CM.TextShaper.Glyph();
    placedGlyph.glyph = glyph;
    placedGlyph.charCode = glyphDesc.charCode;
    placedGlyph.pos = [x0, y0];
    placedGlyph.size = [metrics.size.x, metrics.size.y];
    placedGlyph.advance = [xa, ya];
    placedGlyph.cursor = [x,y];
    return placedGlyph;
  },

  _breakIntoLinesAdvanced: function(placement, glyphs, labelStyle) {
    var response = {
      ellipsize: false,
      lines: []
    };

    var lineHeight = labelStyle.textSize + labelStyle.textLineSpacing;

    var currentLine = 0;
    var currentLineStart = 0;

    for(var glyphIndex = 0; glyphIndex < glyphs.length; ++glyphIndex) {
      var glyph = glyphs[glyphIndex];
      if (currentLine != glyph.lineNumber) {
        currentLine = glyph.lineNumber;
        response.lines.push({
          start:currentLineStart,
          end: glyphIndex
        });
        currentLineStart = glyphIndex;
        var dx = -placement.glyphs[glyphIndex].cursor[0];
        for(var placementIndex = glyphIndex; placementIndex < placement.glyphs.length; ++placementIndex) {
          var glyphToAdjust = placement.glyphs[placementIndex];
          glyphToAdjust.pos[0] += dx;
          glyphToAdjust.pos[1] += lineHeight;
          glyphToAdjust.cursor[0] += dx;
          glyphToAdjust.cursor[1] += lineHeight;
        }
      }
    }
    response.lines.push({
      start:currentLineStart,
      end: glyphs.length
    });

    return response;
  },

  _breakIntoLines: function(placement, labelStyle) {

    var response = {
      ellipsize: false,
      lines: []
    };


    if (labelStyle.maxSize[0] < 1) {
      var lastGlyph = placement.glyphs[placement.glyphs.length - 1];

      response.lines.push({
        start: 0,
        end: placement.glyphs.length
      });
      return response;
    }

    var lastSafeBreak = -1;
    var maxWidth = labelStyle.maxSize[0];
    var lineHeight = labelStyle.textSize + labelStyle.textLineSpacing;
    var numLines = labelStyle.maxSize[1] < 1 ? -1 : Math.floor(labelStyle.maxSize[1] / lineHeight);

    if (numLines == 0) {
      return response;
    }

    var currentLine = 0;
    var lineStart = 0;

    var lastSafeBreakGlyph = null;

    for(var i = 0; i < placement.glyphs.length; ++i) {
      var glyph = placement.glyphs[i];

      if (glyph.charCode == CM.TextShaper.SpaceCharCode) {
        lastSafeBreak = i;
      }
      if (lineStart != i && glyph.pos[0] > maxWidth) {

        if (lastSafeBreak == -1) {
          // Didn't find anywhere to break, kill the line.
          lastSafeBreakGlyph = placement.glyphs[i - 1];
          response.lines.push({
            start: lineStart,
            end: i
          });
        } else {
          // gotta break.
          lastSafeBreakGlyph = placement.glyphs[lastSafeBreak - 1];
          response.lines.push({
            start: lineStart,
            end: lastSafeBreak
          });
        }

        if (lastSafeBreak == -1 || currentLine + 1 == numLines) {
          response.ellipsize = labelStyle.ellipsize;
          return response;
        }
        lineStart = lastSafeBreak + 1;
        currentLine++;
        lastSafeBreak = -1;

        // Glyph where the new line starts need to be reset back to x = 0;
        // All glyphs starting with the new line need to be bumped down to the next line as well.
        var dx = -placement.glyphs[lineStart].cursor[0];

        for(var j = lineStart; j < placement.glyphs.length; ++j) {
          var newLineGlyph = placement.glyphs[j];

          newLineGlyph.pos[0] += dx;
          newLineGlyph.pos[1] += lineHeight;
          newLineGlyph.cursor[0] += dx;
          newLineGlyph.cursor[1] += lineHeight;
        }
      }
    }

    if (lineStart != placement.glyphs.length && !response.ellipsize) {
      var lastGlyph = placement.glyphs[placement.glyphs.length - 1];
      response.lines.push({
        start: lineStart,
        end: placement.glyphs.length
      });
    }

    return response;
  },

  _ellipsizeText: function(placement, lineDetails, styleParams, glyphCache) {
    if (lineDetails.ellipsize) {
      var lastLine = lineDetails.lines[lineDetails.lines.length - 1];
      var textSize = styleParams.textSize;
      var charSpacing = styleParams.textCharSpacing;

      var glyphDesc = new CM.GlyphDesc();
      glyphDesc.style = styleParams.textStyle;
      glyphDesc.weight = styleParams.textWeight;
      glyphDesc.font = styleParams.fontFamily;
      glyphDesc.charCode = 0x2026; // ellipsis

      var lastGlyph = placement.glyphs[lastLine.end - 1];
      var ellipX = lastGlyph.cursor[0] + lastGlyph.advance[0];
      var ellipY = lastGlyph.cursor[1];
      var placedGlyph = this._placeGlyph(glyphDesc, charSpacing, textSize, glyphCache, ellipX, ellipY);
      placement.glyphs.length = lastLine.end;
      placement.glyphs.push(placedGlyph);
      lastLine.end++;
    }
  },

  _adjustGlyphsForLines: function(placement, lineDetails, styleParams) {

    if (lineDetails.lines.length == 0) {
      return;
    }

    var glyphs = [];

    var maxHeight = 0;
    var lastLine = lineDetails.lines[lineDetails.lines.length - 1];

    for(var glyphIndex = lastLine.start; glyphIndex < lastLine.end; ++glyphIndex) {
      var glyph = placement.glyphs[glyphIndex];
      maxHeight = Math.max(glyph.pos[1], maxHeight);
    }

    var dy = -maxHeight * styleParams.textAnchor[1];
    for(var lineIndex = 0; lineIndex < lineDetails.lines.length; ++lineIndex) {
      var line = lineDetails.lines[lineIndex];

      var endOfLine = placement.glyphs[line.end - 1].pos[0] + placement.glyphs[line.end - 1].size[0];
      var beginningOfLine = placement.glyphs[line.start].pos[0];

      var lineWidth = endOfLine - beginningOfLine;
      var dx = beginningOfLine + lineWidth * styleParams.textAnchor[0];

      dx *= -1;

      for(var glyphIndex = line.start; glyphIndex < line.end; ++glyphIndex) {
        var glyph = placement.glyphs[glyphIndex];
        glyph.pos[0] += dx;
        glyph.pos[1] += dy;
        glyphs.push(glyph);
      }
    }

    placement.glyphs = glyphs;
  }
});

CM.TextShaper.SpaceCharCode = " ".charCodeAt(0);

CM.TextShaper.Placement = L.Class.extend({
  glyphs: null,
  minX: 0,
  minY: 0,
  maxX: 0,
  maxY: 0,
  cursorX: 0,
  cursorY: 0,

  initialize: function() {
    this.glyphs = [];
  }
});

CM.TextShaper.Glyph = L.Class.extend({
  glyph: null,
  pos: null,
  size: null
});

CM.TextShaper.LineStyle = L.Class.extend({
  textSize: 12,
  textCharSpacing: 0,
  textWeight: 400,
  textStyle: null,
  fontFamily: 'HelveticaNeue',
  ellipsize: false
});

CM.TextShaper.LabelStyle = CM.TextShaper.LineStyle.extend({
  textAnchor: [0.5, 0.5],
  textLineSpacing: 0,
  maxSize: [0, 0],
});
L.Layer.prototype.isVisible = function () {
  return this._visible !== false; // Assume true if undefined
};

L.Layer.prototype.setVisible = function (visible) {
  this._visible = visible;
  
  if (this._map) {
    this._map.setNeedsRender();
  }
};

L.Layer.prototype.setRenderLayer = function(layer) {
  this._renderLayer = layer;
};

L.Layer.prototype.getRenderLayer = function() {
  return this._renderLayer;
};

L.Layer.RenderLayerUnrenderable = -1;
L.Layer.RenderLayerMap = 0;
L.Layer.RenderLayerMapOverlay = 1;
L.Layer.RenderLayerAnnotation = 2;
L.Layer.RenderLayerCount = 3;


CM.MarkerWebGLExt = {
  _initIcon: function () {
    var icon = this.options.icon.createIcon(this._icon);

    if (!this._sprite && icon.nodeName == "IMG") {
      this._sprite = new CM.Sprite();

      var devicePixelRatio = CM.Conf.devicePixelRatio;
      var inverseRatio = 1.0 / devicePixelRatio;

      var size = this.options.icon.iconSize || this.options.icon.options.iconSize || new L.Point(0, 0);
      if (size) {
        this._size = new L.Point(size.x * inverseRatio, size.y * inverseRatio);
      }

      this._anchor = new L.Point(0, 0);

      icon.onload = function (e) {
        this._sprite.setImage(icon);
        if (!this._size) {
          this._size = new L.Point(icon.width * inverseRatio, icon.height * inverseRatio);
        }

        this._sprite.setSize(this._size);

        var anchor = this.options.icon.iconAnchor;
        if (anchor) {
          this._anchor = new L.Point(anchor.x / this._size.x, anchor.y / this._size.y);
        }
      }.bind(this);
    } else {
      // Original marker code

      var options = this.options,
        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

      var icon = options.icon.createIcon(this._icon),
        addIcon = false;

      // if we're not reusing the icon, remove the old one and init new one
      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }
        addIcon = true;

        if (options.title) {
          icon.title = options.title;
        }
        if (options.alt) {
          icon.alt = options.alt;
        }
      }

      L.DomUtil.addClass(icon, classToAdd);

      if (options.keyboard) {
        icon.tabIndex = '0';
      }

      this._icon = icon;
      this._initInteraction();

      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      var newShadow = options.icon.createShadow(this._shadow),
        addShadow = false;

      if (newShadow !== this._shadow) {
        this._removeShadow();
        addShadow = true;
      }

      if (newShadow) {
        L.DomUtil.addClass(newShadow, classToAdd);
      }
      this._shadow = newShadow;


      if (options.opacity < 1) {
        this._updateOpacity();
      }


      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }
      if (newShadow && addShadow) {
        this.getPane('shadowPane').appendChild(this._shadow);
      }
    }
  },

  update: function () {
    if (!this.sprite) {
      if (this._icon) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();
        this._setPos(pos);
      }
    }

    return this;
  },

  _animateZoom: function (opt) {
    if (!this.sprite) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

      this._setPos(pos);
    }
  },

  setOpacity: function (opacity) {
    if (this.sprite) {
      this._alpha = opacity;
    } else {
      this.options.opacity = opacity;
      if (this._map) {
        this._updateOpacity();
      }
    }

    return this;
  },

  render: function (deltaMillis, device, renderState, spriteState) {
    if (this._sprite) {
      var mercPoint = L.Projection.SphericalMercator.project(this._latlng);
      var screenPoint = this._map.screenProject(mercPoint);
      this._sprite.setPosition(screenPoint);

      this._screenPosition = screenPoint;

      if (!this._alpha) {
        this._alpha = this.options.opacity || 1.0;
      }

      this._sprite.setAlpha(this._alpha);
      this._sprite.draw(device, spriteState);
    }
  },

  handleMouseEvent: function (e) {
    if (this._sprite && this._screenPosition) {
      var bounds = this.calculateMarkerBounds(this._screenPosition, this._size, this._anchor);

      var mousePoint = new L.Point(e.x, e.y);
      if (bounds.contains(mousePoint)) {
        this.fire(e.type, this);
        return true;
      }
    }

    return false;
  },

  calculateMarkerBounds: function (position, size, anchor) {
    var min = new L.Point(position.x - (anchor.x * size.x), position.y - (anchor.y * size.y));
    var max = new L.Point(min.x + size.y, min.y + size.x);

    return new L.Bounds(min, max);
  }
};


/*
 Contains the common logic for all CM tile layers.

 New Options
 - noWrap - Enable this to prevent tiles outside the world bounds from being loaded.

 Registers to events
 - tileloadstart - When this is called, the layer will begin the network request to load the data for this tile.
 - tileloadsuccess - When this is called, the layer will prune tiles.

 New events
 - tiledataloaded - called when a tile's data has been retrieved from the network.
 - Contains 2 keys, 'tile' and 'response'
 - tiledatafailed - called when a tile's data fails to be loaded
 - Contains 2 keys, 'tile' and 'status'
 - tileloadsuccess - Requires the subclass to call this once the tile has been loaded (tile.loaded = true)
 */

CM.TileLayer = L.TileLayer.extend({

  _defaultOptions: {
    loadWhilePanning: true,
    loadWhileZooming: true,
    minZoom: 1,
    maxZoom: 30,
    networkPriority: 50
  },

  initialize: function (url, options) {

    options = L.extend(this._defaultOptions, options);
    L.TileLayer.prototype.initialize.call(this, url, options);

    this.LODZooms = options.LODZooms;

    this.on('tileloadstart', this._onTileLoad.bind(this));
    this.on('tileloadsuccess', function (e) {
      this._pruneTiles();
    }.bind(this));

    this._xhr = {};
    this._tileCache = {};
    this._maxCacheSize = options.maxCacheSize || 0;
    this.responseType = undefined;
    this._pathTransformers = [];
    this._updatesEnabled = true;
    this._waitingForMovementToEnd = false;
    this._tileLayerReady = true;
  },

  addTo: function (map) {
    L.TileLayer.prototype.addTo.call(this, map);
    map.on('scalezoomend', this.onScaleZoomEnd, this);
  },

  onRemove: function (map) {
    L.TileLayer.prototype.onRemove.call(this, map);
    map.off('scalezoomend', this.onScaleZoomEnd, this)
  },

  onScaleZoomEnd: function() {
    this._update();
    this._pruneTiles();
  },

  setTileLayerReady: function (ready) {
    this._tileLayerReady = ready;
    if (ready) {
      this._update();
    }
  },

  setUrl: function (url, noRedraw) {
    if (!this._url != url) {
      L.TileLayer.prototype.setUrl.call(this, url, noRedraw);
      this.clearTiles();
      this.clearCache();
      this._update();
      if (this._map) {
        this._map.setNeedsRender();
      }
    }
  },

  setUpdatesEnabled: function (enabled) {
    this._updatesEnabled = enabled;
  },

  clearCache: function () {
    if (this._tileCache) {
      for (var k in this._tileCache) {
        var tile = this._tileCache[k];
        delete this._tileCache[k];
        this._onTileRemovedFromCache(k, tile);
      }
    }
  },

  clearTiles: function () {
    if (this._tiles) {
      var keys = Object.keys(this._tiles);
      for (var k = 0; k < keys.length; ++k) {
        this._removeTile(keys[k]);
      }
    }
  },

  getLODTileRange: function (center, zoom) {
    return this._calcLodTileRange(center, zoom);
  },

  getLODZoom: function (zoom) {
    zoom = zoom || this._map.getZoom();
    return this._findLODZoom(zoom) || zoom;
  },

  setLODZooms: function (zooms) {
    this.LODZooms = zooms;
    if (this._map) {
      this._reset(this._map.getCenter(), this._map.getZoom());
      this._update();
      this._map.setNeedsRender();
    }
  },

  tileCoordsToKey: function (coords) {
    return this._tileCoordsToKey(coords);
  },

  keyToTileCoords: function (key) {
    return this._keyToTileCoords(key);
  },

  createTile: function (coords) {
    var key = this._tileCoordsToKey(coords);
    var tile = {
      loaded: false,
      key: key
    };
    return tile;
  },

  _addTiles: function (bounds) {
    var map = this._map;

    if (map.getZoom() < this.options.minZoom) {
      return;
    }

    if (!this.options.loadWhilePanning && map.isMoving()) {
      return
    }

    if (!this.options.loadWhileZooming && map.isZooming()) {
      return;
    }

    this._tileZoom = this._findLODZoom(this._map.getZoom());

    L.TileLayer.prototype._addTiles.call(this, bounds);
  },

  _addTile: function (coords, container) {
    if (this._map.getZoom() < this.options.minZoom) {
      return;
    }

    if (!this._tileLayerReady) {
      return;
    }

    var key = this._tileCoordsToKey(coords);

    var tile = this._tileCache[key];
    var cache = false;
    if (!tile) {
      tile = this.createTile(coords);
      tile.key = key;
    } else {
      cache = true;
      delete this._tileCache[key];
    }

    tile.coords = coords;
    tile.lastUsed = new Date().getTime();

    this._tiles[key] = tile;

    if (!cache) {
      this.fire('tileloadstart', {
        tile: this._tiles[key],
        coords: coords
      });
    } else {
      this._onTileLoadedFromCache(tile);
      this._map.setNeedsRender(true);
    }
  },

  _removeTile: function (key) {
    var request = this._xhr[key];
    if (request) {
      delete this._xhr[key];
      request.abort();
    }

    var tile = this._tiles[key];
    if (!tile) {
      return;
    }

    if (tile.loaded) {
      this._pruneCacheIfNeeded();
      if (this._maxCacheSize > 0) {
        this._tileCache[key] = tile;
      } else {
        // We aren't caching, this tile is done.
        this._onTileRemovedFromCache(key, tile);
      }
    }

    this._map.setNeedsRender(true);
    delete this._tiles[key];
    this.fire('tileunload', {
      tile: tile,
      coords: this._keyToTileCoords(key)
    });
  },

  _abortLoading: function () {
    //for(var k in this._xhr) {
    //    this._xhr[k].abort();
    //}
    //this._xhr = {};
  },

  _pruneCacheIfNeeded: function () {
    if (this._maxCacheSize < 1) {
      this._tileCache = {};
    } else {
      while (Object.keys(this._tileCache).length > this._maxCacheSize) {
        var oldest = {
          time: new Date().getTime() + 1,
          key: null
        };

        for (var k in this._tileCache) {
          var tile = this._tileCache[k];
          if (tile.lastUsed < oldest.time) {
            oldest.time = tile.lastUsed;
            oldest.key = k;
          }
        }

        if (oldest.key) {
          var tile = this._tileCache[oldest.key];
          delete this._tileCache[oldest.key];
          this._onTileRemovedFromCache(oldest.key, tile);
        }
      }
    }
  },

  _onTileLoadedFromCache: function (tile) {
  },

  _onTileRemovedFromCache: function (key, tile) {
  },

  _onTileLoad: function (e) {

    var layer = this;
    var url = this.getTileUrl(e.coords);

    this._xhr[e.tile.key] = CM.Network.send(url, {
      success: function (response, status, request) {
        var key = e.tile.key;
        delete this._xhr[key];
        var tile = this._tiles[key];
        if (tile) {
          this.fire('tiledataloaded', {
            tile: this._tiles[key],
            response: response,
            status: status,
            request: request
          });
          this._map.setNeedsRender(true);
        }
      }.bind(this),

      error: function (finishedRequest) {
        var key = e.tile.key;

        var request = this._xhr[key];

        if (finishedRequest != request) {
          // This wasn't our request..maybe an old tile url?
          return;
        }

        var tile = this._tiles[key];
        if (request) {
          // Uh oh, actual error
          delete this._xhr[key];
          tile.loaded = true;
          this.fire('tiledatafailed', {
            tile: tile,
            status: request.status,
            cancelled: false
          });
          this._pruneTiles();
        } else {
          // Aborted / cancelled
          delete this._tiles[key];
          this.fire('tiledatafailed', {
            tile: tile,
            status: 0,
            cancelled: true
          });
        }

        this._map.setNeedsRender(true);
      }.bind(this),
      responseType: this.responseType,
      priority: this.options.networkPriority,
      auth: this.options.auth
    });
  },

  _reset: function (center, zoom, hard, noPrune, noUpdate) {
    zoom = this._findLODZoom(zoom);

    if (hard) {
      this._tileCache = {};
    }

    L.TileLayer.prototype._reset.call(this, center, zoom, hard, noPrune, noUpdate);
  },

  _findLODZoom: function (zoom) {
    if (this.options.minZoom > zoom) {
      zoom = this.options.minZoom;
    }

    if (this.LODZooms) {
      var mapZoom = zoom;
      if (mapZoom < this.LODZooms[0]) {
        return this.LODZooms[0];
      } else {
        for (var i = this.LODZooms.length - 1; i >= 0; i--) {
          if (this.LODZooms[i] <= mapZoom) {
            return this.LODZooms[i];
          }
        }
      }
    }

    return zoom;
  },

  _pruneTiles: function () {

    if (!this._updatesEnabled) {
      return;
    }

    var map = this._map;

    if (!map) {
      return;
    }

    if (!this.options.loadWhilePanning && map.isMoving()) {
      return
    }

    if (!this.options.loadWhileZooming && map.isZooming()) {
      return;
    }

    var removed = [];

    // Following leaflet's loading zoom
    var zoom = Math.floor(map.getZoom());

    var lodZoom = this._findLODZoom(zoom);

    var tileRange = this._calcLodTileRange();

    for (var k in this._tiles) {
      var tile = this._tiles[k];
      if (this._shouldRemoveTile(tile, lodZoom, tileRange)) {
        removed.push(k);
      }
    }

    for (var i in removed) {
      this._removeTile(removed[i]);
    }

    map.setNeedsRender(true);
  },

  _shouldRemoveTile: function (tile, zoom, bounds) {
    var coords = tile.coords;

    if (coords.z == zoom) {
      if (!bounds.contains(coords)) {
        return true;
      }
    } else {
      var isLoaded = function(tile) {
        if (tile.isReady) {
          return tile.isReady();
        } else {
          return tile.loaded;
        }
      };

      if (!isLoaded(tile)) {
        return true;
      }
      
      if (coords.z > zoom) {
        var factor = 1 << (coords.z - zoom);
        var modTile = new L.Point(Math.floor(coords.x / factor), Math.floor(coords.y / factor));
        modTile.z = zoom;

        if (!bounds.contains(modTile)) {
          return true;
        } else {
          var parentTile = this._tiles[this._tileCoordsToKey(modTile)];
          if (parentTile && isLoaded(parentTile)) {
            return true;
          }
        }
      } else {
        var dif = zoom - coords.z;
        var factor = 1 << dif;
        var modTileMin = new L.Point(Math.floor(coords.x * factor), Math.floor(coords.y * factor));
        modTileMin.z = zoom;

        var childBounds = new L.Bounds(
          new L.Point(modTileMin.x, modTileMin.y),
          new L.Point(modTileMin.x + (factor - 1), modTileMin.y + (factor - 1))
        );

        var ready = false;

        if (bounds.intersects(childBounds)) {
          var total = 0, totalReady = 0;
          for (var x = bounds.min.x; x <= bounds.max.x; x++) {
            for (var y = bounds.min.y; y <= bounds.max.y; y++) {
              if (childBounds.contains(new L.Point(x, y))) {
                var tile = new L.Point(x, y);
                tile.z = zoom;

                var childTile = this._tiles[this._tileCoordsToKey(tile)];
                if (childTile) {
                  total++;
                  if (isLoaded(childTile)) {
                    totalReady++;
                  }
                }
              }
            }
          }

          if (total == totalReady) {
            ready = true;
          }
        } else {
          ready = true;
        }

        if (ready) {
          return true;
        }
      }
    }

    return false;
  },

  _update: function (center, zoom) {
    if (!this._map) {
      return;
    }

    var map = this._map;

    if (!this._updatesEnabled) {
      return;
    }

    if (!this.options.loadWhilePanning && map.isMoving()) {
      return
    }

    if (!this.options.loadWhileZooming && map.isZooming()) {
      return;
    }

    zoom = zoom || this._map.getZoom();
    if (zoom > this.options.maxZoom ||
      zoom < this.options.minZoom) {
      this._removeAllTiles();
      return;
    }
    this._lodTileRange = this._calcLodTileRange();
    zoom = this._findLODZoom(zoom);
    this._tileZoom = zoom;
    L.TileLayer.prototype._update.call(this, center, zoom);
  },

  _isValidTile: function (coords) {

    if (!L.TileLayer.prototype._isValidTile.call(this, coords)) {
      return false;
    }
    var lodRange = this._lodTileRange;
    if (this.options.noWrap) {
      var max = (1 << coords.z);
      if (coords.x < 0 || coords > max) {
        return false;
      }
    }
    return !(lodRange.min.x > coords.x || lodRange.min.y > coords.y || lodRange.max.x < coords.x || lodRange.max.y < coords.y);
  },

  _calcLodTileRange: function (center, zoom) {
    var map = this._map;
    if (map) {
      zoom = zoom || this._map.getZoom();
      center = center || this._map.getCenter();
      zoom = Math.floor(zoom);
      var lodZoom = this._findLODZoom(zoom);
      var pixelBounds = this._map.getPixelBounds(center, zoom);
      var factor = Math.pow(2, zoom - lodZoom);
      pixelBounds.min = pixelBounds.min.divideBy(factor);
      pixelBounds.max = pixelBounds.max.divideBy(factor);
      var tileRange = this._pxBoundsToTileRange(pixelBounds);
      return tileRange;
    } else {
      return new L.Bounds();
    }
  },

  handleMouseEvent: function (e) {
    return false;
  },

  getTileUrl: function (coords) {
    var newCoords = coords.clone();
    newCoords.z = coords.z;

    var maxTile = (1 << coords.z);
    if (coords.x < 0) {
      newCoords.x = (coords.x % maxTile);
      if (newCoords.x < 0) {
        newCoords.x += maxTile;
      }
    } else if (coords.x >= maxTile) {
      newCoords.x = coords.x % maxTile;
    }

    var uri = L.TileLayer.prototype.getTileUrl.call(this, newCoords);
    for (var i = 0; i < this._pathTransformers.length; i++) {
      uri = this._pathTransformers[i].generatePath(newCoords, uri);
    }

    return uri;
  },

  addPathTransformer: function (transformer) {
    this._pathTransformers.push(transformer);
  }
});
CM.FeatureStyle = L.Class.extend({
  initialize: function (defaultStyle) {
    this._fragments = [defaultStyle];
    this._cache = {};
  },

  addFragment: function (fragment) {
    this._fragments.push(fragment);
  },

  get: function (prop) {
    if (this._cache[prop] !== undefined) {
      return this._cache[prop];
    }
    var fragments = this._fragments;
    var length = fragments.length;
    for (var i = length - 1; i >= 0; i--) {
      var fragment = fragments[i];
      var value = fragment[prop];
      if (value !== undefined) {
        this._cache[prop] = value;
        return value;
      }
    }
    return undefined;
  },

  has: function (prop) {
    var fragments = this._fragments;
    for (var i = fragments.length - 1; i >= 0; i--) {
      var fragment = fragments[i];
      if (fragment[prop] !== undefined) {
        this._cache[prop] = fragment[prop];
        return true;
      }
    }

    this._cache[prop] = null;
    return false;
  },

  select: function (fields) {
    var obj = {};
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      obj[field] = this.get(field);
    }

    return obj;
  }
});
CM.VectorStyle = L.Class.extend({
  initialize: function (url, readyCallback) {
    this.rules = {};

    if (url) {
      CM.Network.send(url, {
        success: function (data, status, req) {
          this.setData(data);

          readyCallback();
        }.bind(this)
      });
    }
  },

  setData: function (data, options) {
    options = options || {};

    this.data = data;
    this.profile = data.profile;
    this.defaultStyle = this.profile.default_style;
    this.backgroundColor = data.profile['background-color'];

    for(var l = 0; l < this.profile.layers.length; ++l) {
      var layer = this.profile.layers[l];
      for(var g = 0; g < layer.groups.length; ++g) {
        var group = layer.groups[g];

        for(var i = 0; i < group.instances.length; ++i) {
          var instance = group.instances[i];
          instance.zoomStyleCache = new Array(30);

          for(var z = 0; z < 30; ++z) {
            var rules = new CM.FeatureStyle(this.defaultStyle);
            var filters = [];
            this._buildStyle({}, instance.styles, z, rules, filters);
            instance.zoomStyleCache[z] = rules;
          }
        }
      }
    }
  },

  getStyleForFeature: function (layerIndex, meta, zoom, groupId, instanceId) {
    groupId = groupId || 0;
    instanceId = instanceId || 0;
    meta = meta || {};

    var layer = this.getLayerByIndex(layerIndex);

    if (layer) {
      var group = layer.groups[groupId];
      if (group && group.instances) {
        var instance = group.instances[instanceId];
        if (instance) {
          var cachedStyle = instance.zoomStyleCache[zoom];
          if (!cachedStyle || Object.keys(meta).length > 0) {
            var rules = new CM.FeatureStyle(this.defaultStyle);
            var filters = [];
            this._buildStyle(meta, instance.styles, zoom, rules, filters);
            return rules;
          } else {
            return cachedStyle;
          }
        }
      }
    }

    return null;
  },

  getLayerIndexForName: function (name) {
    var layers = this.profile.layers;
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      if (layer.name == name) {
        return i;
      }
    }
    
    return -1;
  },

  getLayerIndexForId: function (layerId) {
    var layers = this.profile.layers;
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      if (layer.id == layerId) {
        return i;
      }
    }

    return -1;
  },

  getLayerByIndex: function (index) {
    return this.profile.layers[index];
  },

  getLayerByName: function (name) {
    var layers = this.profile.layers;
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      if (layer.name == name) {
        return layer;
      }
    }

    return null;
  },

  getLayerById: function (id) {
    var index = this.getLayerByIndex(id);
    if (index >= 0) {
      return this.getLayerByIndex(index);
    }

    return null;
  },

  getLayerCount: function () {
    return this.profile.layers.length;
  },

  _buildStyle: function (meta, style, zoom, rules) {
    if (style instanceof Array) {
      for (var i = 0; i < style.length; i++) {
        this._buildStyle(meta, style[i], zoom, rules);
      }
    } else {
      if (this._matchesStyle(meta, style, zoom)) {
        rules.addFragment(style.rules);

        var childStyles = style.styles;

        for (var i = 0; i < childStyles.length; i++) {
          this._buildStyle(meta, childStyles[i], zoom, rules);
        }
      }
    }
  },

  _matchesFilter: function (meta, filter, zoom) {
    var conditions = filter.conditions;

    for (var j = 0; j < conditions.length; j++) {
      var condition = conditions[j];
      var value = condition.value;
      var key = condition.key;
      var valid = false;

      var metaValue = undefined;
      if (key == 'zoom') {
        metaValue = zoom;
      } else {
        var keyValue = meta[key];
        if (keyValue !== undefined) {
          metaValue = meta[key];
        }
      }

      if (metaValue) {
        switch (condition.op) {
          case ">=":
            valid = metaValue >= value;
            break;

          case "<=":
            valid = metaValue <= value;
            break;

          case ">":
            valid = metaValue > value;
            break;

          case "<":
            valid = metaValue < value;
            break;

          case "==":
            valid = metaValue == value;
            break;

          case "!=":
            valid = metaValue != value;
        }
      }

      if (!valid) {
        return false;
      }
    }

    return true;
  },

  _matchesStyle: function (meta, style, zoom) {
    var filters = style.filters;
    var length = filters.length;

    if (length > 0) {
      for (var i = 0; i < length; i++) {
        if (this._matchesFilter(meta, filters[i], zoom)) {
          return true;
        }
      }

      return false;
    } else {
      return true;
    }
  },

  colorIsTransparent: function (color) {
    return !color || color[3] <= 0;
  },

  lineFeatureIsRenderable: function (style) {
    return style && Object.keys(style).length > 0 &&
      style.get('line-width') > 0 && !this.colorIsTransparent(style.get('line-color'));
  },

  polygonFeatureIsRenderable: function (style) {
    return style && style.get('polygon-opacity') > 0 && !this.colorIsTransparent([style.get('polygon-fill')]);
  },

  textIsRenderable: function(style) {
    return style && style.get('text-fill')[3] > 0 && style.get('text-size') > 0;
  },

  iconIsRenderable: function(style) {
    return style && style.get('icon-image') != null && style.get('icon-opacity') > 0 && style.get('icon-color')[3] > 0 && style.get('icon-size')[0] > 0 && style.get('icon-size')[1] > 0;
  },

  layerIsStyleable: function(layer) {
    for (var g = 0; g < layer.groups.length; g++) {
      var group = layer.groups[g];
      for (var i = 0; i < group.instances.length; i++) {
        var instance = group.instances[i];
        if (instance.styles.length == 0) {
          return false;
        }
      }
    }

    return true;
  }
});

CM.VectorStyle.colorToNormalized = function (colorFromStyle) {
  var r = colorFromStyle[0] / 255.0;
  var g = colorFromStyle[1] / 255.0;
  var b = colorFromStyle[2] / 255.0;
  var a = colorFromStyle[3];

  return [r, g, b, a];
};

CM.VectorStyle.colorToVec4 = function (encodedColor) {
  var r = ((0x00FF0000 & encodedColor) >> 16) / 255.0;
  var g = ((0x0000FF00 & encodedColor) >> 8) / 255.0;
  var b = (0x000000FF & encodedColor) / 255.0;
  var a = 1.0;

  return vec4.fromValues(r, g, b, a);
};

CM.VectorStyle.anchorPointForTextStyle = function (style) {
  var vertAlignment = style.get ? style.get('text-vertical-alignment') : style['text-vertical-alignment'];
  var horiAlignment = style.get ? style.get('text-align') : style['text-align'];
  var anchorPoint = new L.Point(0.5, 0.5);
  switch (vertAlignment) {
    case 'bottom':
      anchorPoint.y = 1;
      break;
    case 'middle':
      anchorPoint.y = 0.5;
    case 'top':
    default:
      anchorPoint.y = 0;
      break;
  }

  switch (horiAlignment) {

    case 'right':
      anchorPoint.x = 1;
      break;
    case 'center':
      anchorPoint.x = 0.5;
      break;
    case 'left':
    default:
      anchorPoint.x = 0;
      break;
  }

  return anchorPoint;
};

CM.VectorStyle.polygonProperties = [
  'polygon-fill',
  'polygon-pattern-file'
];

CM.VectorStyle.lineProperties = [
  'line-color',
  'line-width',
  'line-dasharray',
  'line-offset'
];

CM.VectorStyle.symbolProperties = [
  'symbol-placement',
  'icon-image',
  'icon-optional',
  'icon-offset',
  'icon-size',
  'icon-color',
  'icon-margin',
  'text-weight',
  'text-style',
  'text-size',
  'text-wrap-width',
  'text-line-spacing',
  'text-character-spacing',
  'text-spacing',
  'text-max-character-angle-delta',
  'text-fill',
  'text-halo-fill',
  'text-halo-radius',
  'text-dx',
  'text-dy',
  'text-vertical-alignment',
  'text-align',
  'text-margin',
  'text-min-path-length',
  'text-transform',
  'text-face-name',
  'text-optional',
  'label-priority'
];

CM.VectorTile = L.Class.extend({
  coords: null,

  features: [],

  tileBounds: null,

  loaded: false,

  initialize: function (coords) {
    this.coords = coords;
    this.tileBounds = this._calculateTileBounds();
    this._tileOrigin = vec2.fromValues(this.tileBounds.min.x, this.tileBounds.min.y);

    var model = mat4.create();
    mat4.translate(model, model, vec3.fromValues(this.tileBounds.min.x, this.tileBounds.min.y, 0.0));
    this._modelMatrix = model;
  },
  
  isReady: function() {
    return this.loaded && (this.coords.z > CM.Conf.elevation.maxZoom || this.elevationImage || this.elevationImageFailed)
  },

  setLayer: function (layer) {
    this._layer = layer;
  },

  _calculateTileBounds: function () {
    var mercBounds = L.Projection.SphericalMercator.bounds;

    var tileLength = 256 * CM.GeoUtils.getResolutionForZoom(this.coords.z);
    var left = mercBounds.getBottomLeft().x + ((this.coords.x) * tileLength);
    var right = left + tileLength;
    var top = mercBounds.getBottomLeft().y - ((this.coords.y) * tileLength);
    var bottom = top - tileLength;

    return new L.Bounds(new L.Point(left, bottom), new L.Point(right, top));
  },

  setData: function (data) {
    this.loaded = true;

    this._cleanupMeshes();
    this.polygonPasses = data.polygonVertices.opaque;
    this.polygonTransparentPasses = data.polygonVertices.transparent;

    this.linePasses = data.lineVertices;
    this.polygonMeshes = new Array(this.polygonPasses.length);
    this.polygonTransparentMeshes = new Array(this.polygonTransparentPasses.length);

    this.lineMeshes = new Array(this.linePasses.length);
  },

  setElevationImage: function(image) {
    this.elevationImage = image;
  },

  setElevationImageFailed: function() {
    this.elevationImageFailed = true;
  },

  _cleanupMeshes: function() {
    var passIndex,meshIndex,arrayIndex;
    var passesArrays = [this.polygonMeshes, this.polygonTransparentMeshes, this.lineMeshes].filter(function(t){return !!t;});

    for(arrayIndex = 0; arrayIndex < passesArrays.length; ++arrayIndex) {
      var array = passesArrays[arrayIndex];
      for(passIndex = 0; passIndex < array.length; ++passIndex) {
        var passMeshes = array[passIndex];
        if (passMeshes) {
          for(meshIndex = 0; meshIndex < passMeshes.length; ++meshIndex) {
            var mesh = passMeshes[meshIndex];
            mesh.cleanup();
          }
        }
      }
    }
  },

  numOpaquePolygonPasses: function () {
    return this.polygonPasses ? this.polygonPasses.length : 0;
  },

  numTransparentPolygonPasses: function() {
    return this.polygonTransparentPasses ? this.polygonTransparentPasses.length : 0;
  },

  numLinePasses: function () {
    return this.linePasses ? this.linePasses.length : 0;
  },

  _prepareOpaquePolygonPass: function (device, pass) {
    var polyPass = this.polygonPasses[pass],
      passMeshes = this.polygonMeshes[pass];

    if (!passMeshes) {
      passMeshes = new Array(polyPass.length);
      this.polygonMeshes[pass] = passMeshes;
      for (var i = 0; i < polyPass.length; ++i) {
        var batch = polyPass[i];
        var mesh = new CM.Mesh(device, batch.technique);
        passMeshes[i] = mesh;
        mesh.setIndexedData(batch.vertices, batch.indices, batch.numVerts);
      }
    }
  },

  _prepareTransparentPolygonPass: function(device, pass) {
    var polyPass =  this.polygonTransparentPasses[pass],
      passMeshes = this.polygonTransparentMeshes[pass];

    if (!passMeshes) {
      passMeshes = new Array(polyPass.length);
      this.polygonTransparentMeshes[pass] = passMeshes;
      for (var i = 0; i < polyPass.length; ++i) {
        var batch = polyPass[i];
        var mesh = new CM.Mesh(device, batch.technique);
        passMeshes[i] = mesh;
        mesh.setIndexedData(batch.vertices, batch.indices, batch.numVerts);
      }
    }
  },

  _prepareLinePass: function (device, pass) {
    var gl = device.gl;
    
    var linePass = this.linePasses[pass];
    var passMeshes = this.lineMeshes[pass];

    if (!passMeshes) {
      passMeshes = new Array(linePass.length);
      this.lineMeshes[pass] = passMeshes;
      for (var i = 0; i < linePass.length; ++i) {
        var batch = linePass[i];
        var mesh = new CM.Mesh(device, batch.technique);
        passMeshes[i] = mesh;
        var indexed = batch.indices && batch.indices.length > 0;

        if (indexed) {
          mesh.setIndexedData(batch.vertices, batch.indices, batch.numVerts);
          mesh.setPrimitiveType(gl.TRIANGLES);
        } else {
          mesh.setData(batch.vertices, batch.numVerts);
          mesh.setPrimitiveType(gl.TRIANGLE_STRIP);
        }
      }
    }
  },

  _bindOriginShaderData: function(state) {
    var mapCenter = this._layer._map.getProjectedCenter();

    state.setShaderData('u_origin', new CM.ShaderData(
      vec2.fromValues(
        this.tileBounds.min.x - mapCenter.x,
        this.tileBounds.min.y - mapCenter.y
      ), 'vec2')
    );
  },

  renderOpaquePolygons: function (deltaMillis, device, state, pass, hillshadeEnabled) {

    if (this.loaded && this.numOpaquePolygonPasses() > pass) {
      var gl = device.gl;
      var renderHillshade = false;
      this._prepareOpaquePolygonPass(device, pass);
      var passMeshes = this.polygonMeshes[pass];
      if (this.elevationImage && hillshadeEnabled) {
        if (!this.elevationTexture) {
          this.elevationTexture = new CM.Texture(device, this.elevationImage);
        }
        state.setShaderData("u_elevationTexture", new CM.ShaderData(1, 'texture'));
        state.setShaderData("u_pixelSize", new CM.ShaderData(1.0 / this.elevationImage.width, 'float'));
        this.elevationTexture.activate(gl.TEXTURE1);

        renderHillshade = true;
      }

      if (hillshadeEnabled && !renderHillshade && this.coords.z <= CM.Conf.elevation.maxZoom && !this.elevationImageFailed) {
        return;
      }

      if (passMeshes.length > 0) {
        //state.setShaderData('u_origin', this._tileOriginShaderData);
        this._bindOriginShaderData(state);

        for (var i = 0; i < passMeshes.length; ++i) {
          var mesh = passMeshes[i];
          if (renderHillshade) {
            mesh.setTechnique("elevation");
          } else {
            mesh.setTechnique("fill");
          }
          mesh.draw(device, state, gl.TRIANGLES);
        }
      }
    }
  },

  renderTransparentPolygons: function(deltaMillis, device, state, pass) {
    if (this.loaded && this.numTransparentPolygonPasses() > pass) {

      var gl = device.gl;
      this._prepareTransparentPolygonPass(device, pass);
      var passMeshes = this.polygonTransparentMeshes[pass];

      if (passMeshes.length > 0) {
        this._bindOriginShaderData(state);

        for (var i = 0; i < passMeshes.length; ++i) {
          var mesh = passMeshes[i];
          mesh.setTechnique("fill");
          mesh.draw(device, state, gl.TRIANGLES);
        }
      }
    }
  },

  renderLines: function (deltaMillis, device, state, pass) {

    if (this.loaded && this.linePasses && this.linePasses.length > pass) {


      this._prepareLinePass(device, pass);
      var passMeshes = this.lineMeshes[pass];
      if (passMeshes.length > 0) {
        var gl = device.gl;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        //state.setShaderData('u_origin', this._tileOriginShaderData);
        this._bindOriginShaderData(state);

        for (var i = 0; i < passMeshes.length; ++i) {
          var mesh = passMeshes[i];
          // Don't specify primitive type
          mesh.draw(device, state);
        }

        gl.disable(gl.BLEND);
      }
    }
  },

  finishCacheTarget: function () {
    this._textureCacheReady = true;
    this._textureCacheTarget.deactivate();
  },

  renderCache: function (deltaMillis, device, state) {
    if (this._textureCacheReady) {
      var gl = device.gl;
      this._textureCacheTarget.getColorTexture().activate(gl.TEXTURE0);
      state.setShaderData(new CM.ShaderData(0, 'texture'));
      state.pushTransform(this._modelMatrix);
      this._cacheMesh.draw(device, state, degl.TRIANGLE_STRIP);
      state.popTransform();
    }
  }
});

CM.VectorTile.NEGATIVE_ZERO = -1000000;

CM.VectorTile.POLYGON_MATERIAL = null;

CM.VectorSymbolRenderer = L.Class.extend({
  _projection: L.Projection.SphericalMercator,
  _map: null,
  _badgeAtlas: null,
  _badgesReady: false,
  _symbolFeatures: null,
  _pixelAlignEnabled: false,

  initialize: function (map) {
    this._map = map;
    this._symbolFeatures = {};
    this._iconRequests = {};
  },

  cleanup: function() {
  },

  onLabelProcessorUpdate: function(features) {
    var currentFeatures = {};
    var labelsChanged = false;
    var map = this._map;

    for (var i in this._symbolFeatures) {
      var symbolFeature = this._symbolFeatures[i];
      currentFeatures[symbolFeature.id] = symbolFeature;
    }

    for (var i = 0; i < features.length; i++) {
      var feature = features[i];

      if (!(feature.id in currentFeatures)) {

        var newFeature = this._createNewSymbolFeature(feature);
        newFeature.debugVerts = feature.debugVerts;

        if (newFeature.showLabel) {
          newFeature.label = this._createLabel(feature);
        }

        if (newFeature.showIcon) {
          newFeature.icon = this._createIcon(feature);
        }

        this._symbolFeatures[newFeature.id] = newFeature;
        labelsChanged = true;

        if (feature.prevId && (feature.prevId in currentFeatures)) {
          // This is a restyled version of an existing label.
          // Don't do the animation.
          newFeature.animationAlpha = 1;
          currentFeatures[feature.prevId].animationAlpha = 0;
        } else {
          map.addAnimation(newFeature.id, {
            object: newFeature,
            properties: ['animationAlpha'],
            start: 0,
            end: 1,
            duration: 300
          });
        }
      } else {
        var oldFeature = currentFeatures[feature.id];
        oldFeature.debugVerts = feature.debugVerts;

        oldFeature.showLabel = feature.showLabel;
        oldFeature.showIcon = feature.showIcon;

        if (oldFeature.showLabel && !oldFeature.label) {
          oldFeature.label = this._createLabel(feature);
        }

        if (oldFeature.showIcon && !oldFeature.icon) {
          oldFeature.icon = this._createIcon(feature);
        }
      }

      // This feature is meant to exist, do not erase it!.
      delete currentFeatures[feature.id];
    }

    for (var k in currentFeatures) {
      var symbolFeature = currentFeatures[k];
      if (!symbolFeature.disappearing) {
        symbolFeature.disappearing = true;
        map.addAnimation(symbolFeature.id, {
          object: symbolFeature,
          properties: ['animationAlpha'],
          start: symbolFeature.animationAlpha,
          end: 0,
          duration: 300 * symbolFeature.animationAlpha
        });
        labelsChanged = true;
      }
    }

    if (labelsChanged) {
      map.setNeedsRender(true);
    }
  },

  _createIcon: function(feature) {
    var style = feature.style;
    var color = CM.VectorStyle.colorToNormalized(style['icon-color']);

    return {
      alpha: 1.0,
      offset: style['icon-offset'] || [0,0],
      size: style['icon-size'] || [0,0],
      assetName: style['icon-image'] || null,
      blendColor: color,
      angle: feature.angle
    }
  },

  _createLabel: function (feature) {
    var style = feature.style;
    var labelObj = new CM.Label({
      angle: feature.angle,
      fontFamily: style['text-face-name'] || "SanFrancisco",
      fontWeight: style['text-weight'],
      textStyle: style['text-style'],
      textSize: style['text-size'],
      textColor: CM.VectorStyle.colorToNormalized(style['text-fill']),
      outlineColor: CM.VectorStyle.colorToNormalized(style['text-halo-fill']),
      outlineWidth: style['text-halo-radius'],
      textAlignment: style['text-align'],
      textVerticalAlignment: style['text-vertical-alignment'],
      textCharSpacing: style['text-character-spacing'],
      textLineSpacing: style['text-line-spacing'],
      textOffset: new L.Point(style['text-dx'], style['text-dy']),
    });
    labelObj.setText(feature.label);

    if (feature.badgeType) {
      var badgeStyle = CM.VectorSymbolRenderer.BADGE_SYTLES[feature.badgeType];
      labelObj.outlineWidth = badgeStyle.outlineWidth;
      labelObj.textColor = badgeStyle.textColor;
      labelObj.textCharSpacing = 0;
      labelObj.textOffset.x = 0;
      labelObj.textOffset.y = 0;
      labelObj.fontFamily = badgeStyle.fontFamily;
      labelObj.fontWeight = badgeStyle.fontWeight;
      labelObj.textSize = CM.VectorSymbolRenderer.BADGE_TEXT_SIZE;
    }

    var maxWidth = style['text-wrap-width'];

    if (feature.type == CM.MapFeatureType.Line && !feature.badgeType) {
      labelObj.pathSegment = feature.segmentId;
      labelObj.pathPoints = feature.path;
      labelObj.size = new L.Point(0,0);
    } else {
      labelObj.size = new L.Point(maxWidth || 200, 200);
    }

    return labelObj;
  },

  _createNewSymbolFeature: function (feature) {
    return {
      label: null,
      icon: null,
      id: feature.id,
      feature: feature,
      animationAlpha: 0,
      disappearing: false,
      absolutePosition: new L.Point(feature.point.x, feature.point.y),
      position: this._projection.unproject(feature.point),
      badgeType: feature.badgeType,
      showLabel:feature.showLabel,
      showIcon:feature.showIcon,
      angle: feature.angle
    };
  },

  _queueLabels: function(vectorRenderer, features) {

    var dpr = CM.Conf.devicePixelRatio;
    var feature, x,y;
    for (var i = 0; i < features.length; ++i) {
      feature = features[i];
      x = feature.position.x + feature.label.textOffset.x;
      y = feature.position.y + feature.label.textOffset.y;

      if (this._pixelAlignEnabled) {
        x = Math.round(x * dpr) / dpr;
        y = Math.round(y * dpr) / dpr;
      }
      feature.label.position = new L.Point(x,y);
      feature.label.alpha = feature.animationAlpha;
      vectorRenderer.addLabel(feature.label);
    }
  },

  _queueBadges: function(vectorRenderer, features) {

    var anchorPoint = new L.Point(0.5, 0.5);

    var dpr = CM.Conf.devicePixelRatio;

    for (var i = 0; i < features.length; i++) {
      var badgeFeature = features[i];
      var badgeStyle = CM.VectorSymbolRenderer.BADGE_SYTLES[badgeFeature.badgeType];
      var badgeSize = badgeStyle.size;

      var slotName = badgeFeature.badgeType;

      if (badgeFeature.label && badgeFeature.feature.label.length > 2) {
        slotName += "_long";
      }

      var x = badgeFeature.position.x - (anchorPoint.x * badgeSize.x);
      var y = badgeFeature.position.y - (anchorPoint.y * badgeSize.y);

      if (this._pixelAlignEnabled) {
        x = Math.round(x * dpr) / dpr;
        y = Math.round(y * dpr) / dpr;
      }

      vectorRenderer.addIcon(new CM.SpriteRenderer.Object({
        position: new L.Point(x,y),
        size: badgeSize,
        slotName: slotName,
        alpha: badgeFeature.animationAlpha,
        angle: badgeFeature.angle
      }));
    }
  },

  _queueIcons: function(vectorRenderer, features) {

    var anchorPoint = new L.Point(0.5, 0.5);
    var dpr = CM.Conf.devicePixelRatio;

    for (var i = 0; i < features.length; i++) {
      var iconFeature = features[i];
      var icon = iconFeature.icon;
      var x = iconFeature.position.x - (anchorPoint.x * icon.size[0]) - icon.offset[0];
      var y = iconFeature.position.y - (anchorPoint.y * icon.size[1]) - icon.offset[1];

      if (this._pixelAlignEnabled) {
        x = Math.round(x * dpr) / dpr;
        y = Math.round(y * dpr) / dpr;
      }

      vectorRenderer.addIcon(new CM.SpriteRenderer.Object({
        position: new L.Point(x,y),
        size: new L.Point(icon.size[0], icon.size[1]),
        slotName: icon.assetName,
        alpha: iconFeature.animationAlpha * icon.alpha,
        blendColor: icon.blendColor
      }));
    }
  },

  render: function (vectorRenderer) {

    if (Object.keys(this._symbolFeatures).length > 0) {

      this._pixelAlignEnabled = this._map.isMoving() || this._map.isZooming();

      var labels = [];
      var badges = [];
      var icons = [];

      var removed = [];

      var mapBounds = this._map.getProjectedBounds();

      for (var k in this._symbolFeatures) {
        var feature = this._symbolFeatures[k];
        if (feature.disappearing && feature.animationAlpha < 0.01) {
          removed.push(feature);
          continue;
        }
        if (!mapBounds.contains(feature.absolutePosition)) {
          continue;
        }
        feature.position = this._map.screenProject(feature.absolutePosition);

        if (feature.showLabel) {
          labels.push(feature);
          if (feature.badgeType) {
            badges.push(feature);
          }
        }
        if (feature.showIcon) {
          icons.push(feature);
        }
      }

      removed.forEach(function (v) {
        delete this._symbolFeatures[v.id]
      }.bind(this));

      if (badges.length) {
        this._queueBadges(vectorRenderer, badges);
      }

      if (icons.length) {
        this._queueIcons(vectorRenderer, icons);
      }

      if (labels.length) {
        this._queueLabels(vectorRenderer, labels);
      }
    }
  }
});

CM.VectorSymbolRenderer.BADGE_SYTLES = {
  "badges_loop": {
    textColor: [0.59, 0.59, 0.59, 1],
    outlineWidth: 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(25, 25)
  },
  "badges_county": {
    textColor: [0.59, 0.59, 0.59, 1],
    outlineWidth: 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(25, 25)
  },
  "badges_state": {
    textColor: [0.59, 0.59, 0.59, 1],
    outlineWidth: 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(25, 25)
  },
  "badges_us": {
    textColor: [0.59, 0.59, 0.59, 1],
    outlineWidth: 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(25, 25)
  },
  "badges_interstate": {
    textColor: [1, 1, 1, 1],
    outlineWidth: 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(25, 25)
  },
  "traffic_arrow": {
    "textColor": [0, 0, 0, 0],
    "outlineWidth": 0,
    fontWeight: 800,
    fontFamily: "SanFrancisco",
    "size": new L.Point(17, 10)
  }
};

CM.VectorSymbolRenderer.BADGE_TEXT_SIZE = 8;

var DEFAULT_MAP_STYLE = CM.Files['style.json'];

CM.VectorLayer = CM.TileLayer.extend({

  _projection: L.Projection.SphericalMercator,

  _styleReady: false,

  _nextWorker: 0,

  initialize: function (url, options) {
    options.maxCacheSize = options.maxCacheSize || CM.VectorLayer.CACHE_MAX_SIZE;
    options.networkPriority = 1;
    options.numTileLoaders = options.numTileLoaders || CM.VectorLayer.MAX_TILE_LOADERS;

    CM.TileLayer.prototype.initialize.call(this, url, options);
    this.setRenderLayer(L.Layer.RenderLayerMap);

    this.on('tiledataloaded', this._onTileDataLoaded.bind(this));
    this.on('tiledatafailed', this._onTileDataFailed.bind(this));
    this.responseType = 'arraybuffer';

    this._style = new CM.VectorStyle();
    this._style.setData(DEFAULT_MAP_STYLE);

    if (this._labelProcessor && !this._labelProcessor.styleLoaded) {
        this._labelProcessor.postMessage({name: "style_loaded", data: this._style.data
      });
    }

    this._workers = [];
    var tileLoaderUrl = CM.Conf.baseUrl + CM.Conf.distDirectory + "TileLoader.js";
    CM.WorkerBuilder.build(tileLoaderUrl, function (workers) {
      for (var i = 0; i < workers.length; i++) {
        var worker = workers[i];
        worker.postMessage(["config", L.extend(CM.Conf, {
          oceanEnabled: options.oceanEnabled,
          oneWayTileMinZoom: this.options.oneWayTileMinZoom,
          oneWayVisibleMinZoom: this.options.oneWayVisibleMinZoom
        })]);
        worker.styleLoaded = false;

        worker.onmessage = (function (e) {
          var data = e.data;
          var type = data.type;
          var key = data.key;
          var tile = this._tiles[key];
          if (tile) {
            var metrics = e.data.metrics;
            this._map.fire('vector_tile_metrics', {
              metrics: metrics,
              coords: tile.coords
            });
            this._map.setNeedsRender(true);
            if (type == "tile") {
              if (!tile.loaded) {
                tile.setData(data);
                tile.loaded = true;
                tile.styleZoom = tile.coords.z;
              }

              this.fire('tileloadsuccess', {
                tile: tile
              });

              this._labelProcessor.postMessage({
                name: "tile_added",
                data: {
                  key: key,
                  labels: data.labelFeatures,
                  zoom: tile.coords.z,
                  minStyleZoom: tile.coords.z,
                  maxStyleZoom: tile.coords.z == 13 ? 30 : 13,
                  tileBounds: tile._calculateTileBounds()
                }
              }, [data.labelFeatures]);

              if (!this._zooming) {
                var zoomFloor = Math.floor(this._map.getZoom());
                this._sendStyleUpdateMessage(tile, zoomFloor);
              }
            } else if (type == "update_style") {
              if (data.success) {
                if (tile.styleZoom == data.zoom) {
                  tile.setData(data);
                }
              }
            } else if (type == 'get_metrics') {
              var metrics = e.data.metrics;
              CM.Console.log(metrics);
            }
          }
        }).bind(this);
      }
      this._workers = workers;
      this._notifyWorkersOfTextures();
      this._update();
    }.bind(this), options.numTileLoaders);

    var labelWorkerUrl = CM.Conf.baseUrl + CM.Conf.distDirectory + "label_processor_worker.js";
    CM.WorkerBuilder.build(labelWorkerUrl, function (workers) {
      this._labelProcessor = workers[0];
      this._labelProcessor.postMessage({
        name: "config",
        data: {
          config: L.extend(CM.Conf, {
              oneWayTileMinZoom: this.options.oneWayTileMinZoom,
              oneWayVisibleMinZoom: this.options.oneWayVisibleMinZoom
            }),
          hostname: CM.Conf.baseUrl,
          files: CM.Conf.labelProcessorDeps,
          oneWayVisibleMinZoom: this.options.oneWayVisibleMinZoom
        }
      });

      this._labelProcessor.onmessage = this._handleLabelProcessorMessage.bind(this);

      this._labelProcessor.postMessage({name: "start"});
      this._labelProcessor.postMessage({name: "style_loaded", data: this._style.data});

      this._update();
    }.bind(this), 1);

    this._updateLabels([]);
    this._labelQueue = [];
    this._labelConstraints = [];
    this._shouldRenderLabels = false;
  },

  cleanup: function() {
    if (this._vectorSymbolRenderer) {
      this._vectorSymbolRenderer.cleanup();
    }

    if (this._polygonTextureAtlas) {
      this._polygonTextureAtlas.delete();
    }
  },

  addLabelConstraint: function (constraint) {
    this._labelConstraints.push(constraint);
  },

  _handleLabelProcessorMessage: function (e) {
    var message = e.data;
    this._updateLabels(message.data);
  },

  addTo: function (map) {
    var mapId = map.getContainer().id;

    this._vectorSymbolRenderer = new CM.VectorSymbolRenderer(map);

    this._zoomTimeout = null;

    this._shouldRenderLabels = true;
    map.on('scalezoomstart', function () {
      this._zoomScale = 1;
      this._zooming = true;
    }.bind(this));

    map.on('scalezoom', function (e) {
      this._zoomScale *= e.scale;
      this._zooming = true;
      if (this._zoomScale < 0.9) {
        this._shouldRenderLabels = false;
        //this._labelProcessor.postMessage({name: "stop"});
      }
    }.bind(this));

    map.on('scalezoomend zoomend', function (e) {

      this._zooming = false;
      if (!this._shouldRenderLabels) {
        this._updateLabels([]);
        this._shouldRenderLabels = true;
        //this._labelProcessor.postMessage({name: "start"});
      }
      var zoomFloor = Math.floor(this._map.getZoom());
      for (var k in this._tiles) {
        var tile = this._tiles[k];
        this._sendStyleUpdateMessage(tile, zoomFloor);
      }
    }.bind(this));

    map.on(CM.VectorRenderer.REMOTE_FILES_FINISHED_EVENT, function(e) {

      this._polygonTextures = e.textures;
      this._notifyWorkersOfTextures();
      this._remoteFilesLoaded = true;
      this._update();
    }.bind(this));

    if (map._engine._vectorRenderer) {
      this._polygonTextures = map._engine._vectorRenderer.getPolygonTextureAtlasObjects();
      this._notifyWorkersOfTextures();
    }

    CM.TileLayer.prototype.addTo.call(this, map);
  },

  _notifyWorkersOfTextures: function() {
    if (this._polygonTextures)
    {
      for (var i = 0; i < this._workers.length; i++) {
        this._workers[i].postMessage(["textures", this._polygonTextures])
      }
    }
  },

  removeFrom: function(map) {
    CM.TileLayer.prototype.removeFrom.call(this, map);
    this.cleanup();
  },

  isReady: function () {
    return this._labelProcessor &&
      this._workers.length == this.options.numTileLoaders &&
      this._remoteFilesLoaded;
  },

  _addTiles: function (bounds) {
    if (!this.isReady()) {
      return;
    }

    CM.TileLayer.prototype._addTiles.call(this, bounds);
  },

  _update: function (center, zoom) {
    if (!this.isReady()) {
      return;
    }

    CM.TileLayer.prototype._update.call(this, center, zoom);
  },

  createTile: function (coords) {
    var key = this._tileCoordsToKey(coords);
    var tile = new CM.VectorTile(coords);
    tile.setLayer(this);
    tile.key = key;
    return tile;
  },

  _removeTile: function (key) {

    this._labelProcessor.postMessage({name: "tile_removed", data: {key: key}});
    CM.TileLayer.prototype._removeTile.call(this, key);
  },

  _onTileDataLoaded: function (e) {

    var tile = e.tile;
    var response = e.response;

    var workerIndex = this._nextWorker;
    var worker = this._workers[workerIndex];
    tile.workerIndex = workerIndex;

    this._nextWorker++;
    if (this._nextWorker >= this.options.numTileLoaders) {
      this._nextWorker = 0;
    }
    if (!worker.styleLoaded) {
      worker.postMessage(["style", JSON.stringify(this._style.data)]);
      worker.styleLoaded = true;
    }

    var key = this._tileCoordsToKey(e.tile.coords);
    worker.postMessage(["tile", key, response], [response]);
  },

  _sendStyleUpdateMessage: function (tile, zoom) {

    // Only restyle zoom 13 tiles.
    if (tile.loaded && tile.workerIndex != undefined && tile.styleZoom != zoom && tile.coords.z == 13 && zoom >= 13) {
      tile.styleZoom = zoom;
      var worker = this._workers[tile.workerIndex];
      worker.postMessage(["update_style", {key: tile.key, zoom: zoom}]);
    }
  },

  printTileMetrics: function (coords) {
    var key = this._tileCoordsToKey(coords);

    var tile = this._tiles[key];

    if (tile && tile.loaded && tile.workerIndex != undefined) {
      var worker = this._workers[tile.workerIndex];
      worker.postMessage(["get_metrics", {key: key}]);
    }
  },

  _onTileLoad: function(e) {
    CM.TileLayer.prototype._onTileLoad.apply(this, arguments);

    if (e.coords.z <= CM.Conf.elevation.maxZoom && e.coords.z >= CM.Conf.elevation.minZoom) {
      var maxTile = Math.pow(2, e.coords.z);
      var wrapX = e.coords.x;
      if (wrapX >= maxTile) {
        wrapX -= maxTile * Math.floor(wrapX / maxTile);
      } else if (wrapX < 0) {
        wrapX += maxTile * Math.ceil(Math.abs(wrapX / maxTile));
      }

      var elevationTileUrl = L.Util.template(this.options.elevationUrl, {
        s: this._getSubdomain(e.coords),
        x: wrapX,
        y: this.options.tms ? this._globalTileRange.max.y - e.coords.y : e.coords.y,
        z: e.coords.z
      });
      var key = this._tileCoordsToKey(e.coords);
      var tile = this._tiles[key];
      if (tile) {
        tile.setElevationImage(null);
      }

      if (!this._elevationPathTransformer) {
        var timeout = this._map.options.robot ? 86400 : 1800;
        this._elevationPathTransformer = new CM.CloudfrontPathTransformer({
          publicKey: this._map._signingKeys.publicKey,
          privateKey: this._map._signingKeys.privateKey,
          accessKey: CM.Conf.cloudfrontAccessKey,
          url: "*tile.citymaps.com/elevation/*",
          timeout: timeout
        });
      }

      elevationTileUrl = this._elevationPathTransformer.generatePath(e.coords, elevationTileUrl);

      CM.Network.loadImage(elevationTileUrl, {noscale: true}).then(function (image) {
        var key = this._tileCoordsToKey(e.coords);
        var tile = this._tiles[key];
        if (tile) {
          if (image) {
            tile.setElevationImage(image);
          } else {
            tile.setElevationImageFailed();
          }

          this._map.setNeedsRender(true);
        }

      }.bind(this));
    }
  },

  _onTileLoadedFromCache: function (tile) {
    this._labelProcessor.postMessage({name: "tile_added", data: {key: tile.key}});

    if (!this._zooming) {
      var zoomFloor = Math.floor(this._map.getZoom());
      this._sendStyleUpdateMessage(tile, zoomFloor);
    }
    this._map.setNeedsRender(true);
  },

  _onTileRemovedFromCache: function (key, tile) {
    this._labelProcessor.postMessage({name: "tile_deleted", data: {key: key}});
    tile._cleanupMeshes();
    if (tile.workerIndex != undefined) {
      var worker = this._workers[tile.workerIndex];
      if (worker) {
        worker.postMessage(["tile_deleted", {tile: key}]);
        this._map.setNeedsRender(true);
      }
    }
  },

  _onTileDataFailed: function (e) {
    var tile = e.tile;
    var status = e.status;

    // Nothing to do
  },

  _addLabels: function (data) {
    this._labelQueue.push(data);
  },

  _processLabelQueue: function () {
    if (this._labelQueue.length > 0) {
      var data = this._labelQueue.pop();
      this._labelProcessor.postMessage({name: "tile_added", data: data});
    }
    setTimeout(this._processLabelQueue.bind(this), 16);
  },

  _updateLabels: function (features) {
    if (this._vectorSymbolRenderer) {
      this._vectorSymbolRenderer.onLabelProcessorUpdate(features);
    }
  },

  _getLabelConstraints: function () {
    var constraints = [];
    for (var i = 0; i < this._labelConstraints.length; i++) {
      constraints = constraints.concat(this._labelConstraints[i].getLabelConstraints());
    }

    var constraintsBuffer = new Float32Array(constraints.length * 5);
    var c = 0;
    for (var i = 0; i < constraints.length; i++) {
      var box = constraints[i];
      constraintsBuffer[c++] = box.center.x;
      constraintsBuffer[c++] = box.center.y;
      constraintsBuffer[c++] = box.dimensions.x;
      constraintsBuffer[c++] = box.dimensions.y;
      constraintsBuffer[c++] = box.angle;
    }

    return constraintsBuffer;
  },

  _clearLabels: function() {
    this._updateLabels([]);

    this._map.setNeedsRender(true);
  },

  render: function (deltaMillis, device, state, spriteState) {
    if (this.isReady()) {

      var start = new Date().getTime();

      var mapState = {
        projectedBounds: this._map.getProjectedBounds(),
        resolution: this._map._resolution,
        size: this._map.getSize(),
        zoom: this._map.getZoom(),
        constraints: this._getLabelConstraints()
      };

      var tileKeys = Object.keys(this._tiles);
      this._labelProcessor.postMessage({
        name: "update",
        data: mapState,
        tiles: tileKeys
      }, [mapState.constraints.buffer]);

      this._renderTiles(deltaMillis, device, state, spriteState);
      this._renderLabels(deltaMillis, device, state, spriteState);
    }
  },

  _renderTiles: function (deltaMillis, device, state, spriteState) {

    var renderer = this._map._engine._vectorRenderer;
    var key,tile;
    for (key in this._tiles) {
      tile = this._tiles[key];
      renderer.addVectorTile(tile);
    }
  },

  _renderLabels: function (deltaMillis, device, state, spriteState) {
    var renderer = this._map._engine._vectorRenderer;

    if (this._shouldRenderLabels && this._vectorSymbolRenderer) {
      this._vectorSymbolRenderer.render(renderer);
    }
  },

  applyStyle: function (data) {
    this._style = new CM.VectorStyle();
    this._style.setData(data);

    this.reloadLayer();

    if (this._labelProcessor) {
      this._labelProcessor.postMessage({name: "style_loaded", data: this._style.data});
    }

    var renderer = this._map._engine._vectorRenderer;
    if (renderer) {
      renderer._style = this._style;
    }
  },

  reloadLayer: function() {
    this._remoteFilesLoaded = false;

    this._clearLabels();
    if (this._labelProcessor) {
      this._labelProcessor.postMessage({name: "clear"});
    }

    for (var i in this._workers) {
      var worker = this._workers[i];
      worker.styleLoaded = false;
      worker.postMessage({name: "clear"});
    }

    var renderer = this._map._engine._vectorRenderer;
    if (renderer) {
      renderer.clear();
      renderer.reloadStyle();
    }

    this._removeAllTiles();
    this.clearCache();
    this.redraw();
  }
});

CM.VectorLayer.CACHE_MAX_SIZE = 10;
CM.VectorLayer.MAX_TILE_LOADERS = 1;
CM.VectorLayer.TEXTURE_ATLAS_SIZE = 1024;

/**
 * Created by edwardkimmel on 7/30/15.
 */

var CM = CM || {};
CM.BusinessConfig = {};
CM.BusinessConfig.placePinSize = new L.Point(45, 56);
CM.BusinessConfig.buildingPinSize = new L.Point(45, 67);
CM.BusinessConfig.markerSize = new L.Point(138, 67);
CM.BusinessConfig.metaSize = new L.Point(130, 56);
CM.BusinessConfig.miniSize = new L.Point(8, 8);
CM.BusinessConfig.maxZoomCutoff = 19.9;
CM.BusinessConfig.defaultBlendColor = vec4.fromValues(1, 1, 1, 1);

CM.BusinessConfig.pinCollisionSize = new L.Point(75, 86);
CM.BusinessConfig.metaCollisionSize = new L.Point(150, 86);

CM.BusinessAlgorithm = {};
CM.BusinessAlgorithm.AlgorithmMainMap = "main_map";
CM.BusinessAlgorithm.AlgorithmInfinitySearch = "infinity_search";
CM.BusinessAlgorithm.AlgorithmClusters = "clusters";
/**
 * Created by edwardkimmel on 7/30/15.
 */

var CM = CM || {};
CM.BusinessRendererConfig = {};

CM.BusinessRendererConfig.iconSize = {x: 35, y: 35};
CM.BusinessRendererConfig.ratingSize = {x: 59, y: 10};

CM.BusinessRendererConfig.metaName = {
  size: 13,
  fontFamily: "SanFrancisco",
  fontWeight: 600,
  haloRadius: 1,
  color: vec4.fromValues(0 / 255, 0 / 255, 0 / 255, 1),
  haloColor: vec4.fromValues(255 / 255, 255 / 255, 255 / 255, 0.6)
};

CM.BusinessRendererConfig.metaCategory = {
  size: 12,
  fontFamily: "SanFrancisco",
  fontWeight: 600,
  haloRadius: 1,
  color: vec4.fromValues(74 / 255, 74 / 255, 74 / 255, 1),
  haloColor: vec4.fromValues(241 / 255, 239 / 255, 234 / 255, 0.6)
};

//CM.BusinessRendererConfig.buildingEmbedPosition = new L.Point(5, 15);
CM.BusinessRendererConfig.singleEmbedPosition = new L.Point(5, 7);

CM.BusinessRendererConfig.selectedBlendColor = vec4.fromValues(74 / 255, 154 / 255, 237 / 255, 1);
CM.BusinessRendererConfig.defaultBlendColor = vec4.fromValues(128 / 255, 129 / 255, 140 / 255, 1);
CM.BusinessRendererConfig.hoverScaleModifier = 1.0;

CM.BusinessRendererConfig.miniPinAsset = "/assets/images/business_pin_mini.png";
CM.BusinessRendererConfig.normalPinAsset = "/assets/images/pin_place_base.png";
CM.BusinessRendererConfig.buildingPinAsset = "/assets/images/pin_building_base.png";
CM.BusinessRendererConfig.normalPinMaskAsset = "/assets/images/pin_place_alpha.png";
CM.BusinessRendererConfig.buildingPinMaskAsset = "/assets/images/pin_building_alpha.png";

CM.BusinessRendererConfig.normalPinAssetRaster = "/assets/images/pin_place.png";
CM.BusinessRendererConfig.buildingPinAssetRaster = "/assets/images/pin_building.png";
CM.BusinessRendererConfig.normalPinSelectedAssetRaster = "/assets/images/pin_place_hover.png";
CM.BusinessRendererConfig.buildingPinSelectedAssetRaster = "/assets/images/pin_building_hover.png";
/**
 * Created by edwardkimmel on 7/22/15.
 */

CM.BusinessProcessorMessages = {
  /*
   hostname - The base URl for the processor
   files - The list of dependencies for the processor
   */
  config: "config",

  /*
   key - The tile key
   tile - Array of businesses
   */
  tileAdded: "tile_added",

  /*
   No required data
   */
  start: "start",

  /*
   No required data
   */
  stop: "stop",

  /*
   algorithm - string key for which algorithm to switch to.
   */
  setAlgorithm: "set_algorithm",

  /*
   businesses - array of businesses in the filter
   */
  filterAdded: "filter_added",

  /*
   No required data
   */
  filterRemoved: "filter_removed",

  /*
   bid - The bid  to add
   */
  addFocusedBid: "add_focused_bid",

  /*
   bid - The bid to remove
   */
  removeFocusedBid: "remove_focused_bid",

  /*
   No required data
   */
  clearFocusedBids: "clear_focused_bids",

  /*
   mapState
   - projectedBounds - Merc bounds of the map screen.
   - inverseResolution
   - zoom
   - size (point)
   tiles
   - Array of tile keys currently loaded and on screen
   */
  update: "update",

  /*
   bid - The bid changed
   boost - The amount to boost the visibility by
   */
  visibilityBoost: "visibility_boost"
};
// Worker for executing the business algorithm

var CM = CM || {};
var MERCATOR_WORLD_WIDTH = 40075016.68;
var HALF_MERCATOR_WORLD_WIDTH = MERCATOR_WORLD_WIDTH * 0.5;

CM.BusinessProcessor = function(messageCallback) {
    this._messageCallback = messageCallback;
    this._tiles = {};
    this._tilesLookupMap = {};
    this._sortedFeatures = [];
    this._visibleMarkersArray = [];
    this._visibilityBoost = {};
    this._focusedBids = {};
};

CM.BusinessProcessor.prototype = {
    _tiles: null,
    _tilesLookupMap: null,
    _sortedFeatures: null,
    _needsRebuildSortedFeatures: false,
    _frameTime: (1.0 / 10.0) * 1000,
    _running: false,
    _mapData: null,
    _visibleMarkersArray: null,
    _visibilityBoost: null,
    _focusedBids: null,
    _businessFilter: null,
    _algorithm: null,
    _hasReceivedNewState: false,

    postMessage: function(e) {
        this.onmessage(e);
    },

    onmessage: function(e) {
        this._hasReceivedNewState = true;

        switch (e.name) {
            case CM.BusinessProcessorMessages.config:
                var hostname = e.data.hostname;
                var files = e.data.files;

                for (var i = 0; i < files.length; i++) {
                    files[i] = hostname + files[i];
                }

                importScripts.apply(null, files);
                break;

            case CM.BusinessProcessorMessages.tileAdded:
            {
                var tile = e.data.businesses;
                var key = e.data.key;
                var lookupMap = {};
                for(var i = 0; i < tile.length; ++i) {
                    var feature = tile[i];
                    feature.key = [key, i];
                    if (!(feature.position instanceof L.Point)) {
                        feature.position = new L.Point(feature.position.x, feature.position.y);
                    }
                    lookupMap[feature.bid] = i;
                }
                this._tilesLookupMap[e.data.key] = lookupMap;
                this._tiles[e.data.key] = e.data.businesses;
                this._needsRebuildSortedFeatures = true;
                break;
            }

            case CM.BusinessProcessorMessages.start:
                this._running = true;
                this.run();
                break;

            case CM.BusinessProcessorMessages.stop:
                this._running = false;
                break;

            case CM.BusinessProcessorMessages.setAlgorithm:
                if (!this._businessFilter) {
                    this._algorithm = e.data.algorithm;
                }
                break;

            case CM.BusinessProcessorMessages.filterAdded:
                var data = e.data;
                this._businessFilter = e.data.businesses;

                for(var i = 0; i < this._businessFilter.length; ++i) {
                    var feature = this._businessFilter[i];
                    if (!(feature.position instanceof L.Point)) {
                        feature.position = new L.Point(feature.position.x, feature.position.y);
                    }
                }
                break;

            case CM.BusinessProcessorMessages.filterRemoved:
                this._businessFilter = null;
                break;

            case CM.BusinessProcessorMessages.addFocusedBid:
                this._focusedBids[e.data.bid] = true;
                break;
            case CM.BusinessProcessorMessages.removeFocusedBid:
                delete this._focusedBids[e.data.bid];
                break;
            case CM.BusinessProcessorMessages.clearFocusedBids:
                this._focusedBids = {};
                break;

            case CM.BusinessProcessorMessages.update:
                var data = e.data;
                var mapState = data.mapState;
                var projectedBounds = new L.Bounds(
                    new L.Point(mapState.projectedBounds.min.x, mapState.projectedBounds.min.y),
                    new L.Point(mapState.projectedBounds.max.x, mapState.projectedBounds.max.y)
                );

                this._mapData = {
                    projectedBounds: projectedBounds,
                    inverseResolution: mapState.inverseResolution,
                    zoom: mapState.zoom,
                    size: new L.Point(mapState.size.x, mapState.size.y),
                    projectedCenter: projectedBounds.getCenter()
                };
                var remainingTilesArray = data.tiles;
                var remainingTilesMap = {};
                for(var i = 0; i < remainingTilesArray.length; ++i) {
                    remainingTilesMap[remainingTilesArray[i]] = true;
                }
                for(var tileKey in this._tiles) {
                    if (!remainingTilesMap[tileKey]) {
                        var tile = this._tiles[tileKey];
                        for (var i = 0; i < tile.length; i++) {
                            delete this._visibilityBoost[tile[i].bid];
                        }

                        delete this._tiles[tileKey];
                        delete this._tilesLookupMap[tileKey];
                        this._needsRebuildSortedFeatures = true;
                    }
                }
                break;
            case CM.BusinessProcessorMessages.visibilityBoost:
                var data = e.data;
                if (data.boost == 0) {
                    delete this._visibilityBoost[data.bid];
                } else {
                    this._visibilityBoost[data.bid] = data.boost;
                }
                this._needsRebuildSortedFeatures = true;
                break;
        }
    },

    _findFirstHiddenBusinessIndex: function(sortedFeatures) {
        for(var i = 0; i < sortedFeatures.length; ++i) {
            var feature = sortedFeatures[i];
            if (feature.sortVisibility <= 1) {
                return i;
            }
        }
        return -1;
    },

    rebuildSortedFeatures: function() {

        var sortedFeatures = [];
        sortedFeatures.length = 0;

        var tiles = this._tiles;
        for (var k in tiles) {
            var tile = tiles[k];
            if (!tile) {
                continue;
            }
            sortedFeatures = sortedFeatures.concat(tile);
        }

        for(var i = 0; i < sortedFeatures.length; ++i) {
            var feature = sortedFeatures[i];
            feature.sortVisibility = (this._visibilityBoost[feature.bid] || 0) + feature.visibility;
        }

        sortedFeatures.sort(this.featureCompare);

        var minVisibilityEndIndex = this._findFirstHiddenBusinessIndex(sortedFeatures);
        if (minVisibilityEndIndex != -1) {
            sortedFeatures = sortedFeatures.slice(0, minVisibilityEndIndex);
        }
        
        this._sortedFeatures = sortedFeatures;
    },

    featureCompare: function(a, b) {

        var res = b.sortVisibility - a.sortVisibility;
        if (res) {
            return res;
        }
        if (a.bid < b.bid) {
            return -1
        }
        if (a.bid > b.bid) {
            return 1;
        }
        return 0;
    },

    rekeyVisibleFeatures: function() {

        var features = this._visibleMarkersArray;
        var kept = [];

        var tiles = this._tiles;
        var lookupMaps = this._tilesLookupMap;

        for(var i = 0; i < features.length; ++i) {
            var feature = features[i];
            var tile = tiles[feature.key[0]];
            if (tile != undefined) {
                kept.push(feature);
            } else {
                for(var k in tiles) {
                    var tile = tiles[k];
                    var tileLookupMap = lookupMaps[k];
                    var index = tileLookupMap[feature.bid];
                    if (index != undefined) {
                        var newFeature = tile[index];
                        kept.push(newFeature);
                        break;
                    }
                }
            }
        }

        this._visibleMarkersArray = kept;
    },

    _findFeature: function(bid) {

        var tiles = this._tiles;
        var lookupMaps = this._tilesLookupMap;

        for(var k in tiles) {
            var tile = tiles[k];
            var tileLookupMap = lookupMaps[k];
            var index = tileLookupMap[bid];
            if (index != undefined) {
                return tile[index];
            }
        }
        return null;
    },

    _updateMetaVisibility: function(features) {

        for(var k in features) {
            var feature = features[k];
            feature.showMeta = false;
        }

        for(var outer in features) {
            var outerFeature = features[outer];

            if (outerFeature.mini) {
                continue;
            }

            var metaBounds = this.calculateMarkerBounds(outerFeature.screenPosition, true);
            metaBounds.min.x += CM.BusinessConfig.pinCollisionSize.x;
            var collision = false;
            for(var inner in features) {

                if (outer == inner) {
                    continue;
                }

                var innerFeature = features[inner];

                if (innerFeature.mini) {
                    continue;
                }

                var innerBounds = this.calculateMarkerBounds(innerFeature.screenPosition, innerFeature.showMeta);
                if (innerBounds.intersects(metaBounds)) {
                    collision = true;
                    break;
                }
            }
            outerFeature.showMeta = !collision;
        }
    },

    run: function() {
        var start = new Date().getTime();

        if (this._hasReceivedNewState && this._mapData) {
            if (this._businessFilter) {
                this._runShowAll();
            } else {

                var algorithm = this._algorithm || CM.BusinessAlgorithm.AlgorithmMainMap;
                if (this._needsRebuildSortedFeatures) {
                    this._needsRebuildSortedFeatures = false;
                    this.rebuildSortedFeatures();
                    this.rekeyVisibleFeatures();
                }

                if (algorithm == CM.BusinessAlgorithm.AlgorithmMainMap) {
                    if (this._mapData.zoom >= CM.BusinessConfig.maxZoomCutoff) {
                        this._runShowAll();
                    } else {
                        this._runCollisionAlgorithm();
                    }
                } else if (algorithm == CM.BusinessAlgorithm.AlgorithmInfinitySearch) {
                    this._runInfinitySearch();
                } else if (algorithm == CM.BusinessAlgorithm.AlgorithmClusters)  {
                    this._runClusterAlgorithm();
                }
            }
            this._hasReceivedNewState = false;
        }

        var end = new Date().getTime();

        if (this._running) {
            var remaining = Math.max(1, this._frameTime - (end - start));
            setTimeout(this.run.bind(this), Math.max(50, remaining));
        }
    },

    _runShowAll: function() {

        var sortedFeatures = this._businessFilter ? this._businessFilter : this._sortedFeatures;
        var mapData = this._mapData;
        var screenBounds = new L.Bounds(new L.Point(0, 0), mapData.size);
        var message = [];
        this._visibleMarkersArray.length = 0;

        var onScreen = {};
        for (var i = 0; i < sortedFeatures.length; ++i) {
            var feature = sortedFeatures[i];
            if (!onScreen[feature.bid]) {

                // Calculate screen space data
                feature.screenPosition = this.screenProject(feature.position);
                var bounds = this.calculateMarkerBounds(feature.screenPosition, false);
                feature.bounds = bounds;
                feature.mini = false;
                // Only test features that are on screen
                if (bounds.intersects(screenBounds)) {
                    onScreen[feature.bid] = feature;
                }
            }
        }

        this._updateMetaVisibility(onScreen);
        for (var k in onScreen) {
            var feature = onScreen[k];
            message.push({ bid: feature.bid, key: feature.key, debugBounds: feature.bounds, mini: feature.mini, showMeta: feature.showMeta, focused: this._focusedBids[feature.bid] != undefined});
        }

        if (this._messageCallback) {
            this._messageCallback(message);
        }
    },

    _runCollisionAlgorithm: function() {
        var sortedFeatures = this._sortedFeatures;
        var sortedVisibleMarkers = this._visibleMarkersArray;
        sortedVisibleMarkers.sort(this.featureCompare.bind(this));

        var mapData = this._mapData;
        var screenBounds = new L.Bounds(new L.Point(0, 0), mapData.size);
        var projectedBounds = mapData.projectedBounds;
        var onScreen = {};
        var maxMini = Math.floor(mapData.size.x * mapData.size.y / 5000) * 0.25;
        var currentMini = 0;

        for(var focusedBid in this._focusedBids) {
            var feature = this._findFeature(focusedBid);
            if (feature) {

                // Calculate screen space data
                feature.screenPosition =  this.screenProject(feature.position);
                var bounds = this.calculateMarkerBounds(feature.screenPosition, true);
                feature.bounds = bounds;

                // Only test features that are on screen
                if (bounds.intersects(screenBounds)) {
                    feature.mini = false;
                    onScreen[focusedBid] = feature;
                }
            }
        }

        var length = sortedVisibleMarkers.length;
        for(var i = 0; i < length; ++i) {
            var feature = sortedVisibleMarkers[i];

            // Calculate screen space data
            feature.screenPosition =  this.screenProject(feature.position);
            var bounds = this.calculateMarkerBounds(feature.screenPosition, true);
            feature.bounds = bounds;

            // Only test features that are on screen
            if (bounds.intersects(screenBounds)) {
                var collision = false;

                // We're checking to make sure we don't collide with anything else on screen. Since we're in a sorted list, any collision is a collision with a more important pin.
                for(var k in onScreen) {
                    var feature2 = onScreen[k];

                    // Ignore collisions with mini
                    // Enable this if we're letting this loop add minis. As of now, we don't.
                    //if (feature2.mini) {
                    //    continue;
                    //}
                    if (bounds.intersects(feature2.bounds)) {
                        collision = true;
                        break;
                    }
                }

                // When testing active features, only let big pins stay. If the others are worthy of being minis, they'll get caught in the next loop.
                if (!collision) {
                    feature.mini = false;
                    onScreen[feature.bid] = feature;
                }
            }
        }

        // Take 2
        length = sortedFeatures.length;
        for(var i = 0; i < length; ++i ) {
            var feature = sortedFeatures[i];

            // If we're already on screen because of the prior loop, skip.
            if (onScreen[feature.bid]) {
                continue;
            }

            // Calculate screen space data
            feature.screenPosition =  this.screenProject(feature.position);
            var bounds = this.calculateMarkerBounds(feature.screenPosition, true);
            feature.bounds = bounds;

            // Only test features that are on screen
            if (bounds.intersects(screenBounds)) {
                var collision = false;
                for(var k in onScreen) {
                    var feature2 = onScreen[k];

                    // Ignore collision with mini
                    if (feature2.mini) {
                        continue;
                    }

                    if (bounds.intersects(feature2.bounds)) {
                        collision = true;
                        break;
                    }
                }

                // Here, we can add big or small pins.
                if (collision) {
                    if (currentMini < maxMini) {
                        currentMini++;
                        feature.mini = true;
                        onScreen[feature.bid] = feature;
                    }
                } else {
                    feature.mini = false;
                    onScreen[feature.bid] = feature;
                }
            }
        }

        var message = [];
        this._visibleMarkersArray.length = 0;

        for (var k in onScreen) {
            var feature = onScreen[k];
            if (!feature.mini) {
                this._visibleMarkersArray.push(feature);
            }
            message.push({ bid: feature.bid, key: feature.key, debugBounds: feature.bounds, mini: feature.mini, showMeta: true});
        }

        if (this._messageCallback) {
            this._messageCallback(message);
        }
    },

    _runInfinitySearch: function() {
        var sortedFeatures = this._sortedFeatures;
        var length = sortedFeatures.length;
        var mapData = this._mapData;
        var mapSize = mapData.size;
        var screenEdgePadding = 50;
        var screenBounds = new L.Bounds(new L.Point(screenEdgePadding,screenEdgePadding), new L.Point(mapSize.x - screenEdgePadding, mapSize.y - screenEdgePadding));
        var projectedBounds = mapData.projectedBounds;

        var message = [];
        this._visibleMarkersArray.length = 0;

        var maxBig = 25;//Math.floor(mapData.size.x * mapData.size.y / 20000);
        var maxMini = Math.floor(mapData.size.x * mapData.size.y / 5000);
        var onScreen = {};
        var count = 0;

        for (var i = 0; i < length; ++i) {
            var feature = sortedFeatures[i];
            if (!onScreen[feature.bid]) {

                // Calculate screen space data
                feature.screenPosition = this.screenProject(feature.position);

                if (!screenBounds.contains(feature.screenPosition)) {
                    continue;
                }

                var bounds = this.calculateMarkerBounds(feature.screenPosition, false);
                feature.bounds = bounds;
                feature.mini = count >= maxBig;
                count++;
                onScreen[feature.bid] = feature;
                if (count >= maxBig + maxMini) {
                    break;
                }
            }
        }

        for(var focusedBid in this._focusedBids) {
            var feature = this._findFeature(focusedBid);
            if (feature) {

                if (onScreen[feature.bid]) {
                    feature = onScreen[feature.bid];
                    feature.mini = false;
                    continue;
                }

                // Calculate screen space data
                feature.screenPosition =  this.screenProject(feature.position);

                if (!screenBounds.contains(feature.screenPosition)) {
                    continue;
                }

                var bounds = this.calculateMarkerBounds(feature.screenPosition, false);
                feature.bounds = bounds;
                feature.mini = false;
                onScreen[focusedBid] = feature;
            }
        }

        this._updateMetaVisibility(onScreen);
        for (var k in onScreen) {
            var feature = onScreen[k];
            message.push({ bid: feature.bid, key: feature.key, debugBounds: feature.bounds, mini: feature.mini, showMeta: feature.showMeta, focused:this._focusedBids[feature.bid] != undefined});
        }

        if (this._messageCallback) {
            this._messageCallback(message);
        }
    },

    _runClusterAlgorithm: function() {
        var sortedFeatures = this._sortedFeatures;
        var length = sortedFeatures.length;
        var mapData = this._mapData;
        var mapSize = mapData.size;
        var screenEdgePadding = 0;
        var screenBounds = new L.Bounds(new L.Point(screenEdgePadding,screenEdgePadding), new L.Point(mapSize.x - screenEdgePadding, mapSize.y - screenEdgePadding));

        var message = [];
        this._visibleMarkersArray.length = 0;

        var maxBig = Math.floor(mapData.size.x * mapData.size.y / 20000);
        var maxMini = Math.floor(mapData.size.x * mapData.size.y / 5000);
        var onScreen = {};
        var bigCount = 0, miniCount = 0;

        for (var i = 0; i < length; ++i) {
            var feature = sortedFeatures[i];
            if (!onScreen[feature.bid]) {

                // Calculate screen space data
                var screenPosition = this.screenProject(feature.position);
                feature.screenPosition = screenPosition;

                if (!screenBounds.contains(feature.screenPosition)) {
                    continue;
                }

                var collision = false;
                var halfBounds = 2.5;
                var bounds = L.bounds(L.point(screenPosition.x - halfBounds, screenPosition.y - halfBounds), L.point(screenPosition.x + halfBounds, screenPosition.y + halfBounds));
                feature.bounds = bounds;

                for(var k in onScreen) {
                    var feature2 = onScreen[k];
                    if (feature2.mini) {
                        continue;
                    }

                    if (bounds.intersects(feature2.bounds)) {
                        collision = true;
                        break;
                    }
                }

                feature.mini = collision || bigCount >= maxBig;
                if (feature.mini) {
                    miniCount++;
                    if (miniCount <= maxMini) {
                        onScreen[feature.bid] = feature;
                    }
                } else {
                    bigCount++;
                    if (bigCount <= maxBig) {
                        onScreen[feature.bid] = feature;
                    }
                }
                if (miniCount + bigCount >= maxBig + maxMini) {
                    break;
                }
            }
        }

        for(var focusedBid in this._focusedBids) {
            var feature = this._findFeature(focusedBid);
            if (feature) {
                if (onScreen[feature.bid]) {
                    feature = onScreen[feature.bid];
                    feature.mini = false;
                    continue;
                }
                // Calculate screen space data
                feature.screenPosition =  this.screenProject(feature.position);
                if (!screenBounds.contains(feature.screenPosition)) {
                    continue;
                }
                feature.mini = false;
                onScreen[focusedBid] = feature;
            }
        }

        this._updateMetaVisibility(onScreen);
        for (var k in onScreen) {
            var feature = onScreen[k];
            feature.bounds = this.calculateMarkerBounds(feature.screenPosition, false);
            message.push({ bid: feature.bid, key: feature.key, debugBounds: feature.bounds, mini: feature.mini, showMeta: feature.showMeta, focused:this._focusedBids[feature.bid] != undefined});
        }

        if (this._messageCallback) {
            this._messageCallback(message);
        }
    },

    calculateMarkerBounds: function(position, includeMeta) {
        var pinSize = CM.BusinessConfig.pinCollisionSize;
        var metaWidth = includeMeta ? CM.BusinessConfig.metaCollisionSize.x : 0;
        var min = new L.Point(position.x - (0.5 * pinSize.x), position.y - pinSize.y);
        var max = new L.Point(min.x + pinSize.x + metaWidth, min.y + pinSize.y);
        return new L.Bounds(min, max);
    },

    screenProject: function(point) {

        var mapData = this._mapData;

        var center = mapData.projectedCenter;
        // If we are way far right of the point
        if ((center.x - HALF_MERCATOR_WORLD_WIDTH) > point.x )
        {
            point = new L.Point(point.x + MERCATOR_WORLD_WIDTH, point.y);
        }
        // If we are way far left of the point
        else if ((center.x + HALF_MERCATOR_WORLD_WIDTH) < point.x)
        {
            point = new L.Point(point.x - MERCATOR_WORLD_WIDTH, point.y);
        }

        var x = (point.x - mapData.projectedBounds.min.x) * mapData.inverseResolution;
        var y = (mapData.projectedBounds.max.y - point.y) * mapData.inverseResolution;

        return new L.Point(x, y);
    }
};
/**
 * The business model used by this class and related classes has the following format
 * {
        zip: "10458",
        lon: -73.87794494628906,
        analytics_partner: 0,
        category_icon: 2000,
        rating_0_5: 5,
        visibility: 100,
        state: "NY",
        logo_image: 21689971,
        city: "Bronx",
        country: "US",
        staged_status: 401,
        category: 2022,
        category_name: "Gardens",
        address: "2900 Southern Blvd",
        name: "New York Botanical Garden",
        bid: "5dc4781d-c32b-4786-93ab-d6224f1f2250",
        lat: 40.86227798461914
    }
 * Any model given to the engine should be in this format.
 */

CM.BusinessLayer = CM.TileLayer.extend({

    initialize: function(url, options) {
        options.networkPriority = 10;

        CM.TileLayer.prototype.initialize.call(this, url, options);
        this.setRenderLayer(L.Layer.RenderLayerAnnotation);

        this.on('tiledataloaded', this._onTileDataLoaded.bind(this));
        this.on('tiledatafailed', this._onTileDataFailed.bind(this));

        this._visibleMarkers = {};
        this._htmlAttachments = {};
        this._markerTintColors = {};
        this._renderBlacklist = {};

        this._businessAlgorithm = CM.BusinessLayer.AlgorithmMainMap;

        if (!CM.Util.supportsWorkers() || options.noWorkers) {
            this._processor = new CM.BusinessProcessor(function(e) {
                this.processVisibleMarkers(e);
            }.bind(this));
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.start });
            this._processor._frameTime = (1.0 / 4.0) * 1000;

        } else {
            var workerUrl = CM.Conf.baseUrl + CM.Conf.distDirectory + "business_processor_worker.js";
            CM.WorkerBuilder.build(workerUrl, function(workers) {
                this._processor = workers[0];
                this._processor.onmessage = this.processVisibleMarkers.bind(this);
                this._processor.postMessage({
                    name: CM.BusinessProcessorMessages.config,
                    data: {
                        config: CM.Conf
                    }
                });

                this.setBusinessAlgorithm(this._businessAlgorithm);
                if (this.businessFilter) {
                    this._processor.postMessage({ name: CM.BusinessProcessorMessages.filterAdded, data: {
                        businesses: this.businessFilter.businesses
                    }});
                }
                this._processor.postMessage({ name: CM.BusinessProcessorMessages.start });

                if (this._map) {
                    this._updateProcessorState();
                }

                this._update();
            }.bind(this), 1);
        }
    },

    _onProcessorLoaded: function() {

    },

    addTo: function(map) {
        CM.TileLayer.prototype.addTo.call(this, map);

        map.on('move', function() {
            this._mapMoved = true;
        }.bind(this));

        this._businessScene = new CM.BusinessLayerScene(this._renderer);

        //if (this._processor && (this._processor instanceof CM.BusinessProcessor)) {
            map.on('moveend zoomend', this._updateProcessorState.bind(this));
            this.on('tileloadsuccess', this._updateProcessorState.bind(this));
        //} else {
        //    map.on('move', function() {
        //        this._updateProcessorState();
        //    }.bind(this));
        //}

        if (this._processor) {
            this.setBusinessAlgorithm(this._businessAlgorithm);
        }

        setTimeout(this._updateProcessorState.bind(this), 1);
    },

    removeFrom: function(map) {
        CM.TileLayer.prototype.removeFrom.call(this, map);
        this.cleanup();
    },

    cleanup: function() {
        if (this._renderer.cleanup) {
            this._renderer.cleanup();
        }
    },

    addFocusedBusinessId: function(bid) {
        if (this._processor) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.addFocusedBid, data: {
                bid:bid
            }});
        }
        this._map.setNeedsRender();
    },

    removeFocusedBusinessId: function(bid) {
        if (this._processor) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.removeFocusedBid, data: {
                bid:bid
            }});
        }
        this._map.setNeedsRender();
    },

    clearFocusedBusinessId: function(bid) {
        if (this._processor) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.clearFocusedBids, data: {
            }});
        }
        this._map.setNeedsRender();
    },

    addToRenderBlacklist: function(bid) {
        if (bid instanceof Array) {
            for(var i = 0; i < bid.length; ++i) {
                this._renderBlacklist[bid[i]] = true;
            }
        } else if (bid instanceof Object) {
            for(var k in bid) {
                this._renderBlacklist[k] = true;
            }
        } else {
            this._renderBlacklist[bid] = true;
        }

        if (this._map) {
            this._map.setNeedsRender();
        }
    },

    removeFromRenderBlacklist: function(bid) {
        if (bid instanceof Array) {
            for(var i = 0; i < bid.length; ++i) {
                delete this._renderBlacklist[bid[i]];
            }
        } else if (bid instanceof Object) {
            for(var k in bid) {
                delete this._renderBlacklist[k];
            }
        } else {
            delete this._renderBlacklist[bid];
        }

        if (this._map) {
            this._map.setNeedsRender();
        }
    },

    clearRenderBlacklist: function() {
        this._renderBlacklist = {};
        if (this._map) {
            this._map.setNeedsRender();
        }
    },

    getCurrentBlacklist: function() {
      return L.extend({}, this._renderBlacklist);
    },

    setBusinessTintColor: function (bid, hex, alpha) {
        var rgba = CM.StringUtil.rgbaFromHex(hex, alpha);
        if (rgba) {
            this._markerTintColors[bid] = rgba;
            var marker = this._visibleMarkers[bid];
            if (marker) {
                marker.blendColor = rgba;
                this._renderer.setBlendColor(marker.bid, rgba);
                this._map.setNeedsRender();
            }
        }
    },

    resetBusinessTintColor: function(bid) {
        delete this._markerTintColors[bid];

        var marker = this._visibleMarkers[bid];
        if (marker) {
            marker.blendColor = CM.BusinessConfig.defaultBlendColor;
            this._renderer.setBlendColor(marker.bid, CM.BusinessConfig.defaultBlendColor);
            this._map.setNeedsRender();
        }
    },

    clearBusinessTintColors: function(bid) {
        this._markerTintColors = {};
        for(var k in this._visibleMarkers) {
            var marker = this._visibleMarkers[k];
            marker.blendColor = CM.BusinessConfig.defaultBlendColor;
        }
        this._map.setNeedsRender();
    },

    setUrl: function(url) {
        CM.TileLayer.prototype.setUrl.call(this, url);
        if (this._map) {
            this._updateProcessorState();
        }
    },

    setBusinessAlgorithm: function(algo) {
        if (this._processor && this._map) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.setAlgorithm, data: {
                algorithm:algo
            }});
            this._updateProcessorState();
            this._map.setNeedsRender();
        }
        this._businessAlgorithm = algo;
    },

    _updateProcessorState: function() {
        if (this._processor && this._map && this._map.getProjectedBounds()) {
            var mapState = {
                projectedBounds: this._map._normalizedBounds,
                inverseResolution: this._map._inverseResolution,
                zoom: this._map.getZoom(),
                size: this._map.getSize()
            };

            var tileKeys = [];
            for(var k in this._tiles) {
                var tile = this._tiles[k];
                if (tile && tile.loaded) {
                    tileKeys.push(k);
                }
            }
            
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.update, data: {
                mapState: mapState,
                tiles: tileKeys
            } });
        }
    },

    _defaultAttachIconOptions: {
        persistent: true,
        size: new L.Point(30,30)
    },

    setAttachmentIcon: function(bid, url, options) {
        options = L.extend(options || {}, this._defaultAttachIconOptions);
        this._renderer.setAttachmentIcon(bid, url, options);
    },

    setVisibilityBoost: function(bid, visibility) {
        this._processor.postMessage({
            name: CM.BusinessProcessorMessages.visibilityBoost,
            data: {
                bid: bid,
                boost: visibility
            }
        });
    },

    _featureForProcessorResponse: function(bid, key) {
        var feature = null;
        if (this.businessFilter) {
            feature = this.businessFilter.businesses[this.businessFilter.indexMap[bid]];
        } else {
            var tile = this._tiles[key[0]];
            if (tile && tile.businesses.length > key[1])  {
                feature = tile.businesses[key[1]];
            }
        }
        return feature;
    },

    processVisibleMarkers: function(message) {
        var data = message.data || message;
        var newVisibleMarkers = {};

        for (var i = 0; i < data.length; i++) {
            var obj = data[i];
            var bid = obj.bid;
            var key = obj.key;
            var focused = obj.focused;
            var mini = obj.mini;
            var showMeta = obj.showMeta;

            var blacklisted = this._renderBlacklist[bid];

            var feature = this._featureForProcessorResponse(bid, key);
            if (feature) {
                if (!blacklisted) {
                    if (!this._businessScene.contains(bid)) {
                        this.showFeature(feature, {
                            mini:mini,
                            showMeta:showMeta
                        });
                        this._renderer.setOverrideZ(bid, focused);
                    } else {
                        this._businessScene.setMini(bid, mini, true);
                        this._businessScene.setShowMeta(bid, showMeta, true);
                    }
                } else {
                    this.hideFeature(feature);
                }
                newVisibleMarkers[bid] = feature;
                delete this._visibleMarkers[bid];
            }
        }
        for (var k in this._visibleMarkers) {
            var marker = this._visibleMarkers[k];
            this.hideFeature(marker);
        }

        this._visibleMarkers = newVisibleMarkers;
    },

    _addTiles: function (bounds) {

        if (!this._processor) {
            return;
        }

        CM.TileLayer.prototype._addTiles.call(this, bounds);
    },

    _update: function(center, zoom) {
        if (!this._processor) {
            return;
        }

        CM.TileLayer.prototype._update.call(this, center, zoom);
    },

    createTile: function(coords) {
        var tile = CM.TileLayer.prototype.createTile.call(this, coords);
        tile.businesses = [];
        tile.indexMap = {};
        return tile;
    },

    _onTileDataLoaded: function(e) {
        var tile = e.tile;
        var response = e.response;

        if (this._tiles[tile.key])
        {
            var data = JSON.parse(response);

            tile.businesses = data.slice(0);
            this._processBusinessListForDisplay(tile.businesses);

            var indexMap = {};
            for(var i = 0; i < tile.businesses.length; ++i) {
                indexMap[tile.businesses[i].bid] = i;
            }

            tile.indexMap = indexMap;
            tile.loaded = true;

            this.fire('tileloadsuccess', {
                tile: tile
            });

            var processorMessage = tile.businesses.map(function(b) {
               return {bid: b.bid, position: b.position, visibility: b.visibility};
            });
            this._processor.postMessage({
                name: CM.BusinessProcessorMessages.tileAdded,
                data: {
                    key: tile.key,
                    businesses: processorMessage
                }
            });

            this._map.setNeedsRender(true);
        }
    },

    _onTileLoadedFromCache: function(tile) {
        var processorMessage = tile.businesses.map(function(b) {
            return {bid: b.bid, position: b.position, visibility: b.visibility};
        });
        this._processor.postMessage({
            name: CM.BusinessProcessorMessages.tileAdded,
            data: {
                key: tile.key,
                businesses: processorMessage
            }
        });
    },

    _processBusinessListForDisplay: function(businesses) {
        for (var i = 0; i < businesses.length; i++) {
            var business = businesses[i];
            business.bid = business.bid || business.object_id;
            business.position = L.Projection.SphericalMercator.project(new L.LatLng(business.lat, business.lon));
            business.logo_image = 0;
            business.imageUrl = this.getImageUrl(business);
            var displayName = business.name;
            var displaySubtitle = business.category_name;

            business.venues = undefined;
            business.venueCount = 1;
            business.size = business.venueCount == 1 ? CM.BusinessConfig.placePinSize : CM.BusinessConfig.buildingPinSize;
            business.displayName = displayName;
            business.displaySubtitle = displaySubtitle;
            business.debugBounds = null;
            business.zIndex = parseFloat(-business.lat.toFixed(6)) * 100000 + business.lon;
        }
    },

    _onTileDataFailed: function(e) {

    },

    getImageUrl: function(feature) {
        if (feature.logo_image && feature.logo_image != 0) {
            return CM.Conf.logoUrl.replace("{id}", feature.logo_image);
        }

        if (feature.category_icon && feature.category_icon != 0 && feature.category_icon != 9999) {
            return CM.Conf.categoryUrl.replace("{id}", feature.category_icon);
        }

        return CM.Conf.categoryUrl.replace("{id}", 0);
    },

    _sanitizeFilterData: function(businesses) {
        return businesses.map(function(props, business) {
            return CM.Util.select(business, props);
        }.bind(this, ['bid', 'lon', 'lat', 'category_icon', 'rating_0_5', 'visibility', 'zip', 'state', 'logo_image', 'city', 'country',
            'category', 'category_name', 'address', 'name']));
    },

    applyFilter: function(filter) {

        this.businessFilter = {};
        filter = this._sanitizeFilterData(filter);
        this._processBusinessListForDisplay(filter);
        this.businessFilter.businesses = filter;
        var indexMap = {};
        for(var i = 0; i <filter.length; ++i) {
            indexMap[filter[i].bid] = i;
        }
        this.businessFilter.indexMap = indexMap;

        if (this._processor) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.filterAdded, data: {
                businesses: filter
            }});
        }
    },

    showFeature: function(feature, options) {
        var bid = feature.bid;
	    var blendColor = this._markerTintColors[bid] || CM.BusinessConfig.defaultBlendColor;
        this._businessScene.addFeatureToScene(feature, options);
        this._renderer.setBlendColor(feature.bid, blendColor);
        if (!options.mini) {
            this._map.fire("business_added", feature);
        }
        this._map.setNeedsRender();
    },

    hideFeature: function(feature) {

        var bid = feature.bid;
        this._businessScene.removeFeatureFromScene(bid);
        var attachment = this._htmlAttachments[bid];
        if (attachment && attachment.object.parentNode) {
            this._map.getContainer().removeChild(attachment.object);
        }

        var isMini = this._businessScene.isMini(bid);
        if (!isMini) {
            this._map.fire("business_removed", {bid:bid});
        }
        this._map.setNeedsRender();
    },

    removeFilter: function() {
        this.businessFilter = null;

        if (this._processor) {
            this._processor.postMessage({ name: CM.BusinessProcessorMessages.filterRemoved });
        }
    },

    render: function(deltaMillis, device, state, spriteState) {

        if (!this._processor) {
            return;
        }

        this._updateProcessorState();

        this._renderer.render(device, spriteState);
    },

    handleMouseEvent: function(e) {
        // Prevent clicks if the map has been moved
        if (e.type == 'click') {
            if (this._mapMoved) {
                // Also reset this so the next click WILL click the map
                return;
            }
        }

        if (e.type == 'mousedown') {
            this._mapMoved = false;
        }

        var mousePos = this._map.mouseEventToContainerPoint(e);

        var markers = this._visibleMarkers;
        var sortedMarkers = Object.keys(markers)
            .filter(function(k){ return !this._businessScene.isMini(k);}.bind(this))
            .map(function(k) { return markers[k] })
            .sort(function(a, b) { return b.zIndex - a.zIndex;});

        for (var k in sortedMarkers) {
            var marker = sortedMarkers[k];
            var screenPos = this._map.screenProject(marker.position);
            var size = marker.size;
            if (screenPos && size) {
                var bounds = new L.Bounds(new L.Point(screenPos.x - size.x * 0.5, screenPos.y - size.y), new L.Point(screenPos.x + size.x * 0.5, screenPos.y));
                if (bounds.contains(mousePos)) {
                    // Marker now represents the marker under the cursor
                    if (e.type == 'mousemove') {
                        // If the hover has changed markers
                        if (this._hoveredMarker != marker) {
                            if (this._hoveredMarker) {
                                this._map.fire("business_mouseleave", this._hoveredMarker);
                            }
                            // Setup the current marker
                            this._map.fire("business_mouseenter", marker);
                            this._hoveredMarker = marker;
                            this._map.setNeedsRender(true);
                        } else {
                            this._map.fire("business_mousemove", marker);
                        }
                    } else {
                        this._map.fire("business_" + e.type, marker);
                    }
                    return true;
                }
            }
        }

        if (e.type == 'mousemove' && this._hoveredMarker) {
            // We found nothing, so null out hovered marker
            this._map.fire("business_mouseleave", this._hoveredMarker);
            this._hoveredMarker = null;
        }

        return false;
    },

    cancelMouseEvent: function() {
        if (this._hoveredMarker) {
            this._map.fire("business_mouseleave", this._hoveredMarker);
            this._hoveredMarker = null;
        }
    },

    calculateMarkerBounds: function(position, includeMeta) {
        var pinSize = CM.BusinessConfig.placePinSize;
        var metaWidth = includeMeta ? CM.BusinessConfig.metaSize.x : 0;
        var min = new L.Point(position.x - (0.5 * pinSize.x), position.y - pinSize.y);
        var max = new L.Point(min.x + pinSize.x + metaWidth, min.y + pinSize.y);
        return new L.Bounds(min, max);
    },

    getLabelConstraints: function() {
        var constraints = [];
        if (this.isVisible()) {
            for (var k in this._visibleMarkers) {
                var marker = this._visibleMarkers[k];

                if (!this._businessScene.isMini(marker.bid)) {
                    var bounds = this.calculateMarkerBounds(this._map.screenProject(marker.position), true);
                    var box = new CM.Box(bounds.getCenter(), bounds.getSize().multiplyBy(0.5), 0);
                    constraints.push(box);
                }
            }
        }
        return constraints;
    },

    addAttachment: function(bid, object, options) {
        this._renderer.addAttachment(bid, object, options);

        this._map.setNeedsRender(true);
    },

    removeAttachment: function(bid) {
        this._renderer.removeAttachment(bid);
    },

    setBusinessState: function (bid, state) {
        this._businessScene.setBusinessState(bid, state);
    }
});

CM.BusinessLayer.AlgorithmMainMap = CM.BusinessAlgorithm.AlgorithmMainMap;
CM.BusinessLayer.AlgorithmInfinitySearch = CM.BusinessAlgorithm.AlgorithmInfinitySearch;
CM.BusinessLayer.AlgorithmClusters = CM.BusinessAlgorithm.AlgorithmClusters;

'use strict';

CM.BusinessLayerScene = L.Class.extend({

  initialize: function (renderer, options) {
    this._renderer = renderer;
    this._scene = {};
    this._disappearingMarkers = {};
    this._states = {};
  },

  _defaultAddOptions: {
    animated: true,
    mini: false,
    showMeta: true
  },

  _defaultRemoveOptions: {
    animated: true
  },

  addFeatureToScene: function (feature, options) {
    var bid = feature.bid;
    if (!this.contains(bid)) {
      options = L.extend(this._defaultAddOptions, options);

      var marker = new CM.BusinessLayerScene.BusinessMarker(feature);
      marker.mini = options.mini;
      marker.metaVisible = options.showMeta;

      this._renderer.cancelTransitions(bid);
      this._scene[bid] = marker;
      if (this._disappearingMarkers[bid]) {
        this._renderer.removeObject(bid);
        delete this._disappearingMarkers[bid];
      }
      this._renderer.addObject(feature, {metaAlpha: marker.metaVisible ? 1 : 0, mini: marker.mini});

      if (this._states[bid]) {
        this._renderer.onBusinessStateChanged(bid, this._states[bid]);
      }

      if (options.animated && !options.mini) {
        this._animateMarkerAdd(marker);
      }
    }
  },

  setMini: function (bid, mini, animated) {
    var marker = this._scene[bid];
    if (marker && marker.mini != mini) {
      marker.mini = mini;
      this._renderer.cancelTransitions(bid);
      this._renderer.removeObject(bid);
      this._renderer.addObject(marker.feature, {metaAlpha: marker.metaVisible ? 1 : 0, mini: mini});
      if (animated && !mini) {
        this._animateMarkerAdd(marker);
      }
    }
  },

  setShowMeta: function (bid, show, animated) {
    var marker = this._scene[bid];
    if (marker && marker.metaVisible != show) {
      marker.metaVisible = show;
      if (animated) {
        this._animateMetaAlpha(marker);
      } else {
        this._renderer.setMetaAlpha(marker.metaVisible ? 1 : 0);
      }
    }
  },

  removeFeatureFromScene: function (bid, options) {
    var marker = this._scene[bid];
    if (marker) {
      options = L.extend(this._defaultRemoveOptions, options);
      delete this._scene[bid];
      if (options.animated) {
        this._disappearingMarkers[bid] = marker;
        this._animateDisappearingMarker(marker);
      } else {
        this._renderer.removeObject(bid);
      }
    }
  },

  contains: function (bid) {
    return (bid in this._scene);
  },

  isMini: function (bid) {
    var marker = this._scene[bid];
    return marker && marker.mini;
  },

  clearScene: function () {
    for (var k in this._scene) {
      var marker = this._scene[k];
      this.removeFeatureFromScene(marker.feature);
    }
  },

  _removeDisappearingMarker: function (bid) {
    var marker = this._disappearingMarkers[bid];
    if (marker) {
      delete this._disappearingMarkers[bid];
      this._renderer.removeObject(bid);
    }
  },

  _animateMarkerAdd: function (marker) {
    this._renderer.applyTransition(marker.feature.bid, CM.BusinessRenderer.Transition.MarkerEnter);
  },

  _animateDisappearingMarker: function (marker) {
    this._renderer.applyTransition(marker.feature.bid, CM.BusinessRenderer.Transition.MarkerLeave, function (bid, complete) {
      if (complete) {
        this._removeDisappearingMarker(bid)
      }
    }.bind(this, marker.feature.bid));
  },

  _animateMetaAlpha: function (marker) {
    this._renderer.applyTransition(marker.feature.bid, marker.metaVisible ? CM.BusinessRenderer.Transition.MetaEnter : CM.BusinessRenderer.Transition.MetaLeave);
  },

  setBusinessState: function (bid, state) {
    var marker = this._scene[bid];

    if (!state) {
      delete this._states[bid];

      if (marker) {
        marker.state = null;
        this._renderer.onBusinessStateChanged(marker.feature.bid, null);
      }
    } else {
      this._states[bid] = state;
      if (marker) {
        marker.state = state;
        this._renderer.onBusinessStateChanged(marker.feature.bid, state);
      }
    }
  }
});

CM.BusinessLayerScene.BusinessMarker = L.Class.extend({

  initialize: function (feature, options) {
    this.feature = feature;
    this.mini = false;
    this.visible = true;
    this.metaVisible = true;
    this.state = null;
  }
});
CM.BusinessLayerWebGLRenderer = CM.BusinessRenderer.extend({
  initialize: function (map) {
    CM.Renderer.prototype.initialize.call(this);

    this._map = map;

    var engine = map.getEngine();
    if (typeof engine == CM.WebGLEngine)
      throw "Wrong type of engine! How did this happen?";

    var device = engine._device;
    var gl = engine._device.gl;

    this._attachmentIcons = {};
    this._htmlAttachments = {};

    this._fontTexture = map._engine.getFontTexture();
    this._labelRenderer = new CM.ScreenLabelRenderer(map, this._fontTexture);
    this._labelRenderer.reorderText = true;
    this._labelRenderer.srcBlendOutline = gl.SRC_ALPHA;
    this._labelRenderer.srcBlendFill =    gl.SRC_ALPHA;

    var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    var textureSize = Math.min(maxTextureSize / CM.Conf.devicePixelRatio, 1024);

    this._logoRenderer = new CM.FixedSizeAtlasRenderer(device, {
      size: new L.Point(textureSize, textureSize),
      slotSize: new L.Point(128, 96)
    });

    this._metaRenderer = new CM.FixedSizeAtlasRenderer(device, {
      size: new L.Point(textureSize, textureSize),
      slotSize: new L.Point(150, 96)
    });

    this._textureSize = textureSize;

    this._starSprites = {};
    this._objectMap = {};

    this._loadRequiredImages(engine._device);

    map.on('scalezoomstart', function () {
      this._zoomScale = 1;
    }.bind(this));

    map.on('scalezoom', function (e) {
      this._zoomScale *= e.scale;
      if (this._zoomScale < 0.9) {
        this._render = false;
      }
    }.bind(this));

    map.on('scalezoomend', function (e) {
      setTimeout(function () {
        this._render = true;
      }.bind(this), 150);
    }.bind(this));
    this._render = true;
  },

  cleanup: function() {
    this._labelRenderer.delete();
    this._logoRenderer.delete();
    this._metaRenderer.delete();
    if (this._miniPin) {
      this._miniPin.delete();
    }
    if (this._placePin) {
      this._placePin.delete();
    }
    if (this._placePinMask) {
      this._placePinMask.delete();
    }
    if (this._buildingPin) {
      this._buildingPin.delete();
    }
    if (this._buildingPinMask) {
      this._buildingPinMask.delete();
    }
    if (this._starSprites) {
      for(var k in this._starSprites) {
        this._starSprites[k].delete();
      }
    }
    if (this._mesh) {
      this._mesh.delete();
    }
    if (this._metaMesh) {
      this._metaMesh.delete();
    }
    if (this._miniMesh) {
      this._miniMesh.delete();
    }
  },

  setAttachmentIcon: function (bid, url, options) {
    var renderObject = this._objectMap[bid];
    if (this._attachmentIcons[bid]) {
      if (renderObject && renderObject.attachmentIconTexture) {
        this._removeAttachmentIcon(renderObject);
      }
      delete this._attachmentIcons[bid];
    }
    if (url) {
      this._attachmentIcons[bid] = {
        url: url,
        persistent: options.persistent || true,
        size: options.size || new L.Point(30, 30)
      };
      if (renderObject) {
        this._addAttachmentIcon(renderObject);
      }
    }
  },

  defaultObjectOptions: {
    alpha: 1,
    scale: 1,
    metaAlpha: 1,
    mini: false
  },

  addObject: function (feature, options) {
    var bid = feature.bid;
    if (bid && !this._objectMap[bid]) {
      options = L.extend(this.defaultObjectOptions, options);
      var renderObject = {
        feature: feature,
        alpha: 1,
        scale: 1,
        metaAlpha: options.metaAlpha,
        buildingPin: feature.venueCount > 1,
        mini: options.mini,
        overrideZ: false,
        blendColor: null,
        imageTexture: null,
        metaTexture: null,
        attachmentIconTexture: null,
        attachmentUrl: null,
        screenPosition: null,
        size: null,
        nameLabel: null,
        subtitleLabel: null
      };
      this._objectMap[bid] = renderObject;

      if (!renderObject.mini) {
        if (renderObject.buildingPin) {
          renderObject.size = CM.BusinessConfig.buildingPinSize;
        } else {
          renderObject.size = CM.BusinessConfig.placePinSize;
        }
        if (!feature.atlasKey) {
          feature.atlasKey = feature.imageUrl;
          if (feature.venueCount > 1) {
            feature.atlasKey += "-b";
          }
        }
        renderObject.imageTexture = this._logoRenderer.findTexture(feature.atlasKey, renderObject.size, feature.logo_image == 0);
        renderObject.metaTexture = this._metaRenderer.findTexture(bid);
        this._addAttachmentIcon(renderObject);
      } else {
        renderObject.size = CM.BusinessConfig.miniSize;
      }
    }
  },

  removeObject: function (bid) {
    var renderObject = this._objectMap[bid];
    this._removeRenderObject(this._objectMap[bid]);
  },

  _removeRenderObject: function (renderObject) {
    if (renderObject) {
      var bid = renderObject.feature.bid;
      delete this._objectMap[bid];

      var imageTexture = renderObject.imageTexture;
      if (imageTexture) {
        this._logoRenderer.returnTexture(imageTexture.key);
        renderObject.imageTexture = null;
        this._sanitizeImageTextureForReuse(imageTexture);
      }

      if (renderObject.metaTexture) {
        this._metaRenderer.returnTexture(renderObject.metaTexture.key);
        renderObject.metaTexture = null;
      }

      var attachmentTexture = renderObject.attachmentIconTexture;
      if (attachmentTexture) {
        this._removeAttachmentIcon(renderObject);
      }
    }
  },

  _removeAttachmentIcon: function (renderObject) {
    var attachmentTexture = renderObject.attachmentIconTexture;
    this._logoRenderer.returnTexture(attachmentTexture.key);
    this._sanitizeImageTextureForReuse(attachmentTexture);
    renderObject.attachmentIconTexture = null;
  },

  _sanitizeImageTextureForReuse: function (imageTexture) {
    if (imageTexture.usages == 0 && !imageTexture.persistent && imageTexture.image) {
      imageTexture.image.delete();
      imageTexture.image = null;
    }
  },

  removeAllObjects: function () {
    var objects = L.extend({}, this._objectMap);
    for (var k in objects) {
      var renderObject = this._objectMap[k];
      this._removeRenderObject(renderObject);
    }
  },

  _addAttachmentIcon: function (renderObject) {
    var attachment = this._attachmentIcons[renderObject.feature.bid];
    if (attachment) {
      renderObject.attachment = attachment;
      renderObject.attachmentIconTexture = this._logoRenderer.findTexture(attachment.url, attachment.size, attachment.persistent);
    }
  },

  drawAttachmentIconIntoAtlas: function (device, renderObject) {
    var clearColor = vec4.fromValues(0, 0, 0, 0);
    if (renderObject.attachmentIconTexture) {
      this._logoRenderer.renderTexture(device, renderObject.attachmentIconTexture, clearColor, clearColor, function (device, atlasState) {
        atlasState.setShaderData("u_cornerRadius", new CM.ShaderData(0.0, 'float'));
        renderObject.attachmentIconTexture.image.srcBlend = gl.SRC_ALPHA;
        renderObject.attachmentIconTexture.image.draw(device, atlasState);
      }.bind(this));
    }
  },

  drawLoadingPinIntoAtlas: function (device) {
    var clearColor = vec4.fromValues(0, 0, 0, 0);
    var imageTexture = this._logoRenderer.findTexture('loading-pin', CM.BusinessConfig.placePinSize, true);
    this.loadingPinImageTexture = imageTexture;

    this._logoRenderer.renderTexture(device, imageTexture, clearColor, clearColor, function (imageTexture, device, atlasState) {
      var pin = this._placePin;
      pin.setPosition(imageTexture.absolutePosition);
      pin.draw(device, atlasState);
    }.bind(this, imageTexture));
  },

  drawPinMasksIntoAtlas: function(device) {
    var clearColor = vec4.fromValues(0, 0, 0, 0);
    var imageTexture = this._logoRenderer.findTexture('place-pin-mask', CM.BusinessConfig.placePinSize, true);
    this._placePinOutlineMask = imageTexture;

    this._logoRenderer.renderTexture(device, imageTexture, clearColor, clearColor, function (imageTexture, device, atlasState) {
      var pin = this._placePinMask;
      pin.setPosition(imageTexture.absolutePosition);
      pin.draw(device, atlasState);
    }.bind(this, imageTexture));

    imageTexture = this._logoRenderer.findTexture('building-pin-mask', CM.BusinessConfig.buildingPinSize, true);
    this._buildingPinOutlineMask = imageTexture;

    this._logoRenderer.renderTexture(device, imageTexture, clearColor, clearColor, function (imageTexture, device, atlasState) {
      var pin = this._buildingPinMask;
      pin.setPosition(imageTexture.absolutePosition);
      pin.draw(device, atlasState);
    }.bind(this, imageTexture));

    this._pinMasksLoaded = true;
  },

  drawImageIntoAtlas: function (device, renderObject) {
    var gl = device.gl;
    
    var imageTexture = renderObject.imageTexture;
    if (imageTexture) {
      var feature = renderObject.feature;
      this.imageLoadedThisFrame = true;
      var clearColor = vec4.fromValues(0, 0, 0, 0);
      var bgColor = clearColor;

      var isBuilding = (feature.venues && feature.venues.length > 0);
      var pin = isBuilding ? this._buildingPin : this._placePin;

      this._logoRenderer.renderTexture(device, imageTexture, clearColor, bgColor, function (feature, imageTexture, device, atlasState) {
        pin.setPosition(imageTexture.absolutePosition);
        pin.draw(device, atlasState);

        atlasState.setShaderData("u_cornerRadius", new CM.ShaderData(2.0, 'float'));

        var spriteSize = imageTexture.image.getSize();
        atlasState.setShaderData("u_inSize", new CM.ShaderData(vec2.fromValues(150, 150), 'vec2'));
        atlasState.setShaderData("u_outSize", new CM.ShaderData(vec2.fromValues(spriteSize.x, spriteSize.y), 'vec2'));

        //imageTexture.image.setTechnique("lanczos");

        imageTexture.image.srcBlend = gl.SRC_ALPHA;
        imageTexture.image.draw(device, atlasState);
      }.bind(this, feature, imageTexture));
    }
  },

  _makeNamelabel: function(str) {
    var metaDataWidth = CM.BusinessConfig.metaSize.x;
    var style = CM.BusinessRendererConfig.metaName;

    var label = new CM.Label({
      position: new L.Point(),
      size: new L.Point(metaDataWidth - 18, 18),
      anchorPoint: new L.Point(0, 0),
      verticalAlignment: 'top',
      textSize: style.size,
      outlineColor: style.haloColor,
      outlineWidth: style.haloRadius,
      textColor: style.color,
      fontFamily: style.fontFamily,
      fontWeight: style.fontWeight
    });
    label.setText(str);
    return label;
  },

  _makeSubtitleLabel: function(str) {
    var metaDataWidth = CM.BusinessConfig.metaSize.x;
    var style = CM.BusinessRendererConfig.metaCategory;

    var label = new CM.Label({
      position: new L.Point(),
      size: new L.Point(metaDataWidth - 12, 12),
      anchorPoint: new L.Point(0, 0),
      verticalAlignment: 'top',
      textSize: style.size,
      outlineColor: style.haloColor,
      outlineWidth: style.haloRadius,
      textColor: style.color,
      fontFamily: style.fontFamily,
      fontWeight: style.fontWeight
    });
    label.setText(str);
    return label;
  },

  drawMetaIntoAtlas: function (device, renderObject) {
    var feature = renderObject.feature;

    var lineHeight = 12;
    var metaTexture = renderObject.metaTexture;
    var metaDataCursor = new L.Point(
      metaTexture.absolutePosition.x,
      metaTexture.absolutePosition.y
    );

    var clearColor = vec4.fromValues(0, 0, 0, 0);
    var bgColor = clearColor;

    var metaDataWidth = CM.BusinessConfig.metaSize.x;

    this._labelRenderer.removeAllObjects();

    this._metaRenderer.renderTexture(device, metaTexture, clearColor, bgColor, function (feature, metaDataCursor, metaTexture, device, atlasState) {
      var label = null, length=null;
      if (feature.displayName) {
        label = renderObject.nameLabel;
        label.position.x = metaDataCursor.x;
        label.position.y = metaDataCursor.y;
        this._labelRenderer.addObject(label);
        var placement = this._labelRenderer.shapeLabel(label);
        metaDataCursor.y += !placement ? 0 : placement.maxY + 3;
      }

      if (feature.displaySubtitle) {
        label = renderObject.subtitleLabel;
        label.position.x = metaDataCursor.x;
        label.position.y = metaDataCursor.y;
        this._labelRenderer.addObject(label);
        var placement = this._labelRenderer.shapeLabel(label);
        metaDataCursor.y += !placement ? 0 : placement.maxY;
      }

      metaDataCursor.y += 2;
      this._labelRenderer.render(device, atlasState);

      // Render metadata
      if (!(feature.venues && feature.venues.length > 0) && feature.rating_0_5) {

        var ratingSprite = this._starSprites[feature.rating_0_5];
        ratingSprite.setPosition(metaDataCursor);

        ratingSprite.draw(device, atlasState);
        metaDataCursor.y += ratingSprite.getSize().y;
      }

      var height = (metaDataCursor.y - metaTexture.absolutePosition.y);
      metaTexture.width = metaDataWidth / this._textureSize;
      metaTexture.height = height / this._textureSize;
      metaTexture.size = new L.Point(metaDataWidth, height);
    }.bind(this, feature, metaDataCursor, metaTexture));
  },

  isReady: function () {
    return this._requiredImagesLoaded;
  },

  _loadRequiredImages: function (device) {
    var promises = [];
    var gl = device.gl;

    promises.push(new Promise(function (resolver) {
      var pinImageUrl = CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.normalPinAsset);

      this._placePin = new CM.Sprite();
      this._placePin.setSize(CM.BusinessConfig.placePinSize);
      this._placePin.srcBlend = gl.ONE;
      this._placePin.setAnchorPoint(new L.Point(0, 0));
      this._placePin.loadURL(pinImageUrl, function () {
        resolver();
      }.bind(this));
    }.bind(this)));

    promises.push(new Promise(function (resolver) {
      var pinImageUrl = CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.normalPinMaskAsset);

      this._placePinMask = new CM.Sprite();
      this._placePinMask.setSize(CM.BusinessConfig.placePinSize);
      this._placePinMask.srcBlend = gl.ONE;
      this._placePinMask.setAnchorPoint(new L.Point(0, 0));
      this._placePinMask.loadURL(pinImageUrl, function () {
        resolver();
      }.bind(this));
    }.bind(this)));

    promises.push(new Promise(function (resolver) {
      var buildingImageUrl = CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.buildingPinAsset);
      this._buildingPin = new CM.Sprite();
      this._buildingPin.setSize(CM.BusinessConfig.buildingPinSize);
      this._buildingPin.srcBlend = gl.ONE;
      this._buildingPin.setAnchorPoint(new L.Point(0, 0));
      this._buildingPin.loadURL(buildingImageUrl, function () {
        resolver();
      }.bind(this));
    }.bind(this)));

    promises.push(new Promise(function (resolver) {
      var buildingImageUrl = CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.buildingPinMaskAsset);
      this._buildingPinMask = new CM.Sprite();
      this._buildingPinMask.setSize(CM.BusinessConfig.buildingPinSize);
      this._buildingPinMask.srcBlend = gl.ONE;
      this._buildingPinMask.setAnchorPoint(new L.Point(0, 0));
      this._buildingPinMask.loadURL(buildingImageUrl, function () {
        resolver();
      }.bind(this));
    }.bind(this)));

    promises.push(new Promise(function (resolver) {
      this._miniPin = new CM.Texture(device);

      CM.Network.loadImage(CM.Conf.baseUrl + CM.BusinessRendererConfig.miniPinAsset).then(function (image) {
        this._miniPin.setImage(image);
        resolver();
      }.bind(this));
    }.bind(this)));

    for (var i = 0.5; i <= 5.0; i += 0.5) {

      var asset = "stars_" + i + ".png";
      var dpr = CM.Conf.devicePixelRatio;
      promises.push(new Promise(function (id, resolver) {
        var sprite = new CM.Sprite();
        sprite.blendEnabled = false;
        sprite.setAnchorPoint(new L.Point(0, 0));
        sprite.imageDpr = dpr;
        sprite.loadURL(CM.Network.getScaledImageURL(CM.Conf.baseUrl + "/assets/images/" + asset), function () {
          resolver();
        }.bind(this));
        this._starSprites[id] = sprite;
      }.bind(this, i)));
    }

    Promise.all(promises).then(function () {
      this._requiredImagesLoaded = true;
    }.bind(this));
  },

  _prepareRender: function (device) {
    var gl = device.gl;

    if (!this._starSprites) {
      this._starSprites = {};
      this._readyStarSprites = 0;
    }

    if (!this._mesh) {
      this._mesh = new CM.Mesh(device, "business", {
        vertexBufferUsage: gl.DYNAMIC_DRAW
      });
      this._mesh.setTechnique("business");

      this._metaMesh = new CM.Mesh(device, "sprite_batch", {
        vertexBufferUsage: gl.DYNAMIC_DRAW
      });
      this._metaMesh.setTechnique("simple");


      this._miniMesh = new CM.Mesh(device, "business", {
        vertexBufferUsage: gl.DYNAMIC_DRAW
      });
      this._miniMesh.setTechnique("mini");
    }
  },

  _shouldLoadImageTexture: function (imageTexture, url) {
    if (!imageTexture || !imageTexture.image || !url) {
      return;
    }
    var isDownloading = imageTexture.image.isDownloadingImage();
    var hasUrl = imageTexture.image.hasUrlSrc(url);
    return (!imageTexture.image.imageLoaded && (!hasUrl || !isDownloading));
  },

  _prepareMarkers: function (device, state, readyMarkers, miniMarkers) {

    var hasRenderedIntoLogoAtlas = false,
      hasRenderedIntoMetaAtlas = false;

    for (var k in this._objectMap) {
      var renderObject = this._objectMap[k];
      var feature = renderObject.feature;

      if (renderObject.mini) {
        miniMarkers.push(renderObject);
        continue;
      }

      readyMarkers.push(renderObject);

      var imageTexture = renderObject.imageTexture;
      var metaTexture = renderObject.metaTexture;

      if (imageTexture && !imageTexture.image) {
        imageTexture.image = new CM.Sprite(null, {
          effect: "sprite_business",
          textureOptions: {
            minFilter: device.gl.NEAREST,
            magFilter: device.gl.NEAREST
          }
        });
        imageTexture.image.setAnchorPoint(new L.Point(0.0, 0.0));
      }

      var embedPosition = (feature.venues && feature.venues.length > 0) ? CM.BusinessRendererConfig.buildingEmbedPosition : CM.BusinessRendererConfig.singleEmbedPosition;
      imageTexture.image.setPosition(imageTexture.absolutePosition.add(embedPosition));

      if (this._shouldLoadImageTexture(imageTexture, feature.imageUrl)) {
        imageTexture.image.setSize(CM.BusinessRendererConfig.iconSize);
        imageTexture.image.loadURL(feature.imageUrl, function (imageTexture, e) {
          if (imageTexture.usages > 0) {
            this._map.setNeedsRender();
          }
        }.bind(this, imageTexture));
      }

      var attachmentIconTexture = renderObject.attachmentIconTexture;
      if (attachmentIconTexture && !attachmentIconTexture.image) {

        attachmentIconTexture.image = new CM.Sprite(null, {
          effect: "sprite_business"
        });
        attachmentIconTexture.image.setPosition(attachmentIconTexture.absolutePosition);
        attachmentIconTexture.image.setAnchorPoint(new L.Point(0.0, 0.0));
      }

      if (attachmentIconTexture && this._shouldLoadImageTexture(attachmentIconTexture, renderObject.attachment.url)) {
        attachmentIconTexture.image.setSize(size);
        attachmentIconTexture.image.loadURL(renderObject.attachment.url, function (imageTexture) {
          if (imageTexture.usages > 0) {
            this._map.setNeedsRender();
          }
        }.bind(this, attachmentIconTexture));
      }

      if (renderObject.metaAlpha > 0) {
        if (feature.displayName && !renderObject.nameLabel) {
          renderObject.nameLabel = this._makeNamelabel(renderObject.feature.displayName);
          this._labelRenderer.preloadLabel(renderObject.nameLabel, function () {
            this._map.setNeedsRender();
          }.bind(this));
        }

        if (feature.displaySubtitle && !renderObject.subtitleLabel) {
          renderObject.subtitleLabel = this._makeSubtitleLabel(renderObject.feature.displaySubtitle);
          this._labelRenderer.preloadLabel(renderObject.subtitleLabel, function () {
            this._map.setNeedsRender();
          }.bind(this));
        }
      }

      if (attachmentIconTexture && attachmentIconTexture.image.imageLoaded) {
        this.drawAttachmentIconIntoAtlas(device, renderObject);
      }

      if (!hasRenderedIntoLogoAtlas) {
        if (imageTexture && imageTexture.image && imageTexture.image.imageLoaded) {
          if (!imageTexture.drawn && !this.imageLoadedThisFrame) {
            this.drawImageIntoAtlas(device, renderObject);
            hasRenderedIntoLogoAtlas = true;
          }
        }
      }

      if (renderObject.metaAlpha > 0 && !hasRenderedIntoMetaAtlas) {
        if (metaTexture && renderObject.metaAlpha > 0) {
          if (!renderObject.metaTexture.drawn && this._isMetaReady(renderObject)) {
            this.drawMetaIntoAtlas(device, renderObject);
          }
        }
      }

      if (this.imageLoadedThisFrame || hasRenderedIntoLogoAtlas || hasRenderedIntoMetaAtlas) {
        this._map.setNeedsRender();
      }
    }
  },

  _isMetaReady: function(renderObject) {
    var feature = renderObject.feature;
    var nameReady = !feature.displayName || renderObject.nameLabel && this._labelRenderer.isLabelReady(renderObject.nameLabel);
    var subtitleReady = !feature.displaySubtitle || renderObject.subtitleLabel && this._labelRenderer.isLabelReady(renderObject.subtitleLabel);

    return nameReady && subtitleReady;
  },

  _updateObjectPositions: function (renderObjectArray) {

    var shouldPixelAlignPositions = !this._map.isMoving() || !this._map.isZooming();
    var density = CM.Conf.devicePixelRatio;

    for (var i = 0; i < renderObjectArray.length; ++i) {
      var renderObject = renderObjectArray[i];
      var feature = renderObject.feature;

      var pos = this._map.screenProject(feature.position);
      if (shouldPixelAlignPositions) {
        pos.x = Math.round(pos.x * density) / density;
        pos.y = Math.round(pos.y * density) / density;
      }
      renderObject.screenPosition = pos;
    }
  },

  _buildMiniVertexArray: function (miniMarkers) {
    var vertexSize = 3;
    var idx = 0;
    var vertices = new Float32Array(miniMarkers.length * vertexSize * 6);
    var width = CM.BusinessConfig.miniSize.x;
    var height = CM.BusinessConfig.miniSize.y;
    var anchorPoint = new L.Point(0.5, 0.5);

    var coords = [
      new L.Point(0.0, 0.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 1.0)
    ];

    var ushortMax = 65535;

    var uint8Array = new Uint8Array(vertices.buffer);
    var uint16Array = new Uint16Array(vertices.buffer);
    var int16Array = new Int16Array(vertices.buffer);

    for (var i = 0; i < miniMarkers.length; i++) {
      var renderObject = miniMarkers[i];
      var pos = renderObject.screenPosition;
      for (var j = 0; j < coords.length; j++) {
        var offset16 = idx * 2;
        var offset8 = idx * 4;

        int16Array[offset16] = (((pos.x + (width * coords[j].x)) - (anchorPoint.x * width))) * 4;
        int16Array[offset16 + 1] = ((pos.y + (height * coords[j].y) - (anchorPoint.y * height))) * 4;
        uint16Array[offset16 + 2] = coords[j].x * ushortMax;
        uint16Array[offset16 + 3] = coords[j].y * ushortMax;
        uint8Array[offset8 + 8] = renderObject.alpha * 255;
        idx += vertexSize;
      }
    }

    return vertices;
  },

  _buildMarkerVertexArray: function (renderObjects) {
    var vertexSize = 5;
    var numMarkers = renderObjects.reduce(function (prev, renderObject) {
      var numAttachments = renderObject.attachmentIconTexture && renderObject.attachmentIconTexture.drawn ? 1 : 0;
      return numAttachments + 1 + prev;
    }, 0);

    var vertices = new Float32Array(numMarkers * vertexSize * 6);
    var idx = 0;
    var anchorPoint = new L.Point(0.5, 1.0);

    var coords = [
      new L.Point(0.0, 0.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 1.0)
    ];

    for (var i = 0; i < renderObjects.length; i++) {
      var renderObject = renderObjects[i];
      var feature = renderObject.feature;
      if (!renderObject.overrideZ) {
        renderObject.z = parseFloat(-feature.position.y.toFixed(2)) + feature.position.x * 0.001;
      } else {
        renderObject.z = 10000;
      }
    }

    renderObjects.sort(function (f1, f2) {
      var res = f1.z - f2.z;
      if (res != 0) {
        return res;
      }
      var s1 = f1.feature.bid;
      var s2 = f2.feature.bid;
      if (s1 < s2)
        return -1;
      if (s1 > s2)
        return 1;
      return 0;
    });

    var uint8Array = new Uint8Array(vertices.buffer);
    var uint16Array = new Uint16Array(vertices.buffer);
    var int16Array = new Int16Array(vertices.buffer);

    for (var i = 0; i < renderObjects.length; i++) {
      var renderObject = renderObjects[i];

      var markerSize = renderObject.size;

      var selected = renderObject.state && renderObject.state.contains('selected');
      var hover = renderObject.state && renderObject.state.contains('hover');
      var blendColor = (selected || hover) ? CM.BusinessRendererConfig.selectedBlendColor : CM.BusinessRendererConfig.defaultBlendColor;
      var scaleMod = hover ? CM.BusinessRendererConfig.hoverScaleModifier : 1;

      var scale = renderObject.scale * scaleMod;

      var width = markerSize.x * scale;
      var height = markerSize.y * scale;

      var pos = renderObject.screenPosition.subtract(new L.Point(anchorPoint.x * width, anchorPoint.y * height));
      var imageTexture = renderObject.imageTexture.drawn ? renderObject.imageTexture : this.loadingPinImageTexture;

      var ushortMax = 65535;

      var maskTexture = renderObject.buildingPin ? this._buildingPinOutlineMask : this._placePinOutlineMask;
      for (var j = 0; j < coords.length; j++) {
        var offset16 = idx * 2;
        var offset8 = idx * 4;

        int16Array[offset16] = (pos.x + (width * coords[j].x)) * 4;
        int16Array[offset16 + 1] = (pos.y + (height * coords[j].y)) * 4;

        uint16Array[offset16 + 2] = (imageTexture.x + (imageTexture.width * coords[j].x)) * ushortMax;
        uint16Array[offset16 + 3] = (imageTexture.y + (imageTexture.height * coords[j].y)) * ushortMax;

        uint16Array[offset16 + 4] = (maskTexture.x + (maskTexture.width * coords[j].x)) * ushortMax;
        uint16Array[offset16 + 5] = (maskTexture.y + (maskTexture.height * coords[j].y)) * ushortMax;

        uint8Array[offset8 + 12] = blendColor[0] * 255;
        uint8Array[offset8 + 13] = blendColor[1] * 255;
        uint8Array[offset8 + 14] = blendColor[2] * 255;
        uint8Array[offset8 + 15] = blendColor[3] * 255;

        uint8Array[offset8 + 16] = renderObject.alpha * 255;

        uint8Array[offset8 + 17] = imageTexture.textureId;

        idx += vertexSize;
      }

      if (renderObject.attachmentIconTexture && renderObject.attachmentIconTexture.drawn) {
        imageTexture = renderObject.attachmentIconTexture;
        var size = imageTexture.image.getSize();

        pos.x -= size.x * 0.35;
        pos.y -= size.y * 0.35;

        for (var j = 0; j < coords.length; j++) {
          var offset16 = idx * 2;
          var offset8 = idx * 4;

          int16Array[offset16] = (pos.x + (scale * size.x * coords[j].x)) * 4;
          int16Array[offset16 + 1] = (pos.y + (scale * size.y * coords[j].y)) * 4;

          uint16Array[offset16 + 2] = (imageTexture.x + (imageTexture.width * coords[j].x)) * ushortMax;
          uint16Array[offset16 + 3] = (imageTexture.y + (imageTexture.height * coords[j].y)) * ushortMax;

          uint16Array[offset16 + 4] = 0;
          uint16Array[offset16 + 5] = 0;

          uint8Array[offset8 + 12] = 255;
          uint8Array[offset8 + 13] = 255;
          uint8Array[offset8 + 14] = 255;
          uint8Array[offset8 + 15] = 255;

          uint8Array[offset8 + 16] = renderObject.alpha * 255;

          uint8Array[offset8 + 17] = imageTexture.textureId;

          idx += vertexSize;
        }
      }
    }
    return vertices;
  },

  _buildMetaInfoVertices: function (renderObjects) {

    var idx = 0;
    var vertexSize = 4;

    var vertices = new Float32Array(renderObjects.length * vertexSize * 6);

    var coords = [
      new L.Point(0.0, 0.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 0.0),
      new L.Point(0.0, 1.0),
      new L.Point(1.0, 1.0)
    ];

    var uint8Array = new Uint8Array(vertices.buffer);
    var uint16Array = new Uint16Array(vertices.buffer);
    var int16Array = new Int16Array(vertices.buffer);

    var ushortMax = 65535;

    var density = CM.Conf.devicePixelRatio;
    for (var i = 0; i < renderObjects.length; i++) {
      var renderObject = renderObjects[i];
      var textureDimensions = renderObject.metaTexture;

      var markerSize = renderObject.size;
      var scale = renderObject.scale;
      var markerSizeX = markerSize.x * scale;
      var markerSizeY = markerSize.y * scale;
      var width = textureDimensions.size.x * scale;
      var height = textureDimensions.size.y * scale;
      var xPadding = 5 * scale;
      var yPadding = (renderObject.buildingPin ? 8 : 0) * scale;
      var xCoord = renderObject.screenPosition.x + markerSizeX * 0.5 + xPadding;
      var yCoord = renderObject.screenPosition.y - markerSizeY + yPadding;

      xCoord = Math.round(xCoord * density) / density;
      yCoord = Math.round(yCoord * density) / density;

      for (var j = 0; j < coords.length; j++) {

        var offset16 = idx * 2;
        var offset8 = idx * 4;

        int16Array[offset16] = (xCoord + (width * coords[j].x)) * 4;
        int16Array[offset16 + 1] = (yCoord + (height * coords[j].y)) * 4;

        uint16Array[offset16 + 2] = (textureDimensions.x + (textureDimensions.width * coords[j].x)) * ushortMax;
        uint16Array[offset16 + 3] = (textureDimensions.y + (textureDimensions.height * coords[j].y)) * ushortMax;

        uint8Array[offset8 + 8] = 255;
        uint8Array[offset8 + 9] = 255;
        uint8Array[offset8 + 10] = 255;
        uint8Array[offset8 + 11] = 255;

        uint8Array[offset8 + 12] = (renderObject.alpha * renderObject.metaAlpha) * 255;

        uint8Array[offset8 + 13] = textureDimensions.textureId;

        idx += vertexSize;
      }
    }
    return vertices;
  },

  _transitionComplete: function (complete, callback, anim) {
    if (callback) {
      callback(complete);
    }
  },

  applyTransition: function (bid, key, completion) {
    var renderObject = this._objectMap[bid];
    if (renderObject) {
      switch (key) {
        case CM.BusinessRenderer.Transition.MarkerEnter:
        {
          renderObject.alpha = 0;
          this._map.addAnimation(bid + 'enter', {
            object: renderObject,
            properties: ['alpha'],
            delay: 150,
            start: 0,
            end: 1,
            duration: 250,
            complete: this._transitionComplete.bind(this, true, completion),
            cancel: this._transitionComplete.bind(this, false, completion)
          });
        }
          break;
        case CM.BusinessRenderer.Transition.MarkerLeave:
          if (completion) {
            completion(true);
          }
          break;
        case CM.BusinessRenderer.Transition.MetaEnter:
        {
          this._map.addAnimation(bid + "meta", {
            object: renderObject,
            properties: ['metaAlpha'],
            delay: 0,
            start: renderObject.metaAlpha,
            end: 1,
            duration: 300 * (1.0 - renderObject.metaAlpha),
            complete: this._transitionComplete.bind(this, true, completion),
            cancel: this._transitionComplete.bind(this, false, completion)
          });
        }
          break;
        case CM.BusinessRenderer.Transition.MetaLeave:
        {
          this._map.addAnimation(bid + "meta", {
            object: renderObject,
            properties: ['metaAlpha'],
            delay: 0,
            start: renderObject.metaAlpha,
            end: 0,
            duration: 300 * renderObject.metaAlpha,
            complete: this._transitionComplete.bind(this, true, completion),
            cancel: this._transitionComplete.bind(this, false, completion)
          });
        }
          break;
      }
    }
  },

  cancelTransitions: function (bid) {
    var renderObject = this._objectMap[bid];
    if (renderObject) {
      this._map.cancelAnimationsForObject(renderObject);
    }
  },

  setMetaAlpha: function (bid, alpha) {
    var renderObject = this._objectMap[bid];
    if (renderObject && renderObject.metaAlpha != alpha) {
      renderObject.metaAlpha = alpha;
      this._map.setNeedsRender();
    }
  },

  setBlendColor: function (bid, color) {
    var renderObject = this._objectMap[bid];
    if (renderObject) {
      renderObject.blendColor = color;
      this._map.setNeedsRender();
    }
  },
  setOverrideZ: function (bid, override) {
    var renderObject = this._objectMap[bid];
    if (renderObject && renderObject.overrideZ != override) {
      renderObject.overrideZ = override;
      this._map.setNeedsRender();
    }
  },

  render: function (device, state) {

    if (!this.isReady()) {
      return;
    }

    if (this._render) {
      var gl = device.gl;

      // Any static assets must be rendered first to ensure they are all rendered into page 0 (shader assumes this)
      if (!this.loadingPinImageTexture) {
        this.drawLoadingPinIntoAtlas(device);
      }
      if (!this._pinMasksLoaded) {
        this.drawPinMasksIntoAtlas(device);
      }

      var readyMarkers = [];
      var miniMarkers = [];
      this.imageLoadedThisFrame = false;

      this._prepareRender(device);
      this._prepareMarkers(device, state, readyMarkers, miniMarkers);

      if (miniMarkers.length > 0) {

        this._updateObjectPositions(miniMarkers);
        var vertices = this._buildMiniVertexArray(miniMarkers);
        this._miniMesh.setData(vertices, miniMarkers.length * 6);
        this._miniPin.activate(gl.TEXTURE0);
        state.setShaderData('u_texture', new CM.ShaderData(0, 'texture'));
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this._miniMesh.draw(device, state, gl.TRIANGLES);
        gl.disable(gl.BLEND);
      }

      if (readyMarkers.length > 0) {

        this._updateObjectPositions(readyMarkers);
        var vertices = this._buildMarkerVertexArray(readyMarkers);
        this._mesh.setData(vertices, vertices.length / 5);

        var textureLocations = [];
        for (var i = 0; i < this._logoRenderer.getTextureCount(); i++) textureLocations.push(i);

        state.setShaderData("u_texture[0]", new CM.ShaderData(textureLocations, 'texture'));
        for (var i = 0; i < this._logoRenderer.getTextureCount(); i++) {
          this._logoRenderer.getRenderTexture(i).activate(gl.TEXTURE0 + i);
        }

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        this._mesh.draw(device, state, gl.TRIANGLES);
        gl.disable(gl.BLEND);

        var metaMarkers = readyMarkers.filter(function (o) {
          return o.metaAlpha > 0.01 && o.metaTexture && o.metaTexture.drawn;
        });

        if (metaMarkers.length > 0) {
          vertices = this._buildMetaInfoVertices(metaMarkers);
          this._metaMesh.setData(vertices, metaMarkers.length * 6);

          textureLocations = [];
          for (var i = 0; i < this._metaRenderer.getTextureCount(); i++) {
            textureLocations.push(i);
          }

          state.setShaderData("u_texture[0]", new CM.ShaderData(textureLocations, 'texture'));
          for (var i = 0; i < this._metaRenderer.getTextureCount(); i++) {
            this._metaRenderer.getRenderTexture(i).activate(gl.TEXTURE0 + i);
          }

          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          this._metaMesh.draw(device, state, gl.TRIANGLES);
          gl.disable(gl.BLEND);
        }
      }
    }
    this._renderAttachments();

    //for (var i = 0; i < this._metaRenderer.getTextureCount(); i++) {
    //  if (!this.bigSprite) {
    //    this.bigSprite = new CM.Sprite();
    //    this.bigSprite.setPosition(new L.Point(512 * i, 0));
    //    this.bigSprite.setSize(new L.Point(512, 512));
    //    this.bigSprite.setAnchorPoint(new L.Point(0.0, 0.0));
    //  }
    //  this.bigSprite._imageTexture = this._metaRenderer.getRenderTarget(0).getColorTexture();
    //  this.bigSprite.draw(device, state);
    //}
    /*if (this._logoRenderer.getTextureCount() >= 1) {

      if (!this.bigSprite) {
        this.bigSprite = new CM.Sprite();
        this.bigSprite._imageTexture = this._logoRenderer.getRenderTarget(0).getColorTexture();
        this.bigSprite.setPosition(new L.Point(0, 0));
        this.bigSprite.setSize(new L.Point(1024, 1024));
        this.bigSprite.setAnchorPoint(new L.Point(0.0, 0.0));
      }

      this.bigSprite.draw(device, state);
    }*/
  },

  addAttachment: function (bid, object, options) {
    options = L.extend({
      anchorPoint: new L.Point(0, 0),
      attachmentAnchorPoint: new L.Point(0.5, 0),
      size: new L.Point(0, 0)
    }, options);

    this.removeAttachment(bid);

    this._htmlAttachments[bid] = {
      object: object,
      options: options
    };

    if (this._map) {
      this._map.setNeedsRender();
    }
  },

  removeAttachment: function (bid) {
    var attachment = this._htmlAttachments[bid];
    delete this._htmlAttachments[bid];
    if (attachment) {
      if (attachment.object.parentNode) {
        var pane = this._map.getPane('citymapsWebGLHtmlPane');
        pane.removeChild(attachment.object);
      }
    }
  },

  _renderAttachments: function () {

    var pane = this._map.getPane('citymapsWebGLHtmlPane');

    for (var k in this._htmlAttachments) {
      var renderObject = this._objectMap[k];
      var attachment = this._htmlAttachments[k];
      var object = attachment.object;
      if (renderObject && !renderObject.mini && this._render) {

        if (!object.parentNode) {
          pane.appendChild(object);
        }

        object.style.display = "";
        var screenPosition = renderObject.screenPosition;
        var scale = renderObject.scale;
        var anchorPoint = attachment.options.anchorPoint;
        var attachmentAnchor = attachment.options.attachmentAnchorPoint;
        var size = attachment.options.size;

        var offsetX = 0;
        var offsetY = 0;
        // Translate to the top left corner of the pin
        offsetX += CM.BusinessConfig.placePinSize.x * -0.5;
        offsetY += CM.BusinessConfig.placePinSize.y * -1;

        // Offset into the pin based on attachment anchor
        offsetX += CM.BusinessConfig.placePinSize.x * attachmentAnchor.x;
        offsetY += CM.BusinessConfig.placePinSize.y * attachmentAnchor.y;

        // Now scale the offset based on the marker's scale;
        offsetX *= scale;
        offsetY *= scale;

        // Now offset by the object's size & anchor point
        offsetX -= anchorPoint.x * size.x;
        offsetY -= anchorPoint.y * size.y;

        screenPosition.x += offsetX;
        screenPosition.y += offsetY;
        L.DomUtil.setPosition(object, screenPosition);
      } else {
        if (object.parentNode) {
          pane.removeChild(object);
        }
      }
    }
  },

  onBusinessStateChanged: function (bid, state) {
    var feature = this._objectMap[bid];
    feature.state = state;

    this._map.setNeedsRender(true);
  }
});



var pinHTML = '\
<div class="_citymapsengine-pin-container"> \
    <div class="_citymapsengine-pin-body" style="">\
        <img class="_citymapsengine-pin-image" width="35" height="35" />\
    </div> \
    <div class="_citymapsengine-pin-meta"> \
        <div class="_citymapsengine-pin-meta-content"> \
            <p class="name"></p> \
            <p class="category"></p> \
            <p><img class="rating"/></p> \
        </div>\
    </div>\
 </div>';

CM.BusinessLayerHTMLRenderer = CM.BusinessRenderer.extend({
  initialize: function(map) {
    CM.Renderer.prototype.initialize.call(this);

    this._map = map;

    //map.on('move', this._updateMarkers.bind(this));
    // map.on('zoomstart', this._hideMarkers.bind(this));
    //map.on('zoomend', this._showMarkers.bind(this));

    this._htmlObjects = {};

    this._htmlAttachments = {};

    this._attachmentIcons = {};

    this._pinAssetBackgroundImage = 'url('+CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.normalPinAssetRaster) + ')';
    this._pinAssetSelectedBackgroundImage = 'url('+CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.normalPinSelectedAssetRaster) + ')';

    this._buildingPinAssetBackgroundImage = 'url('+CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.buildingPinAssetRaster) + ')';
    this._buildingPinSelectedAssetBackgroundImage = 'url('+CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.buildingPinSelectedAssetRaster) + ')';

  },

  _setBackgroundImage: function(element, feature, selected) {
    if (feature.venues && feature.venues.length > 0) {
      L.DomUtil.addClass(element, 'building');
      element.style.backgroundImage = selected ? this._buildingPinSelectedAssetBackgroundImage : this._buildingPinAssetBackgroundImage;
    } else {
      element.style.backgroundImage = selected ? this._pinAssetSelectedBackgroundImage : this._pinAssetBackgroundImage;
    }
  },

  addObject: function(feature, options) {
    var bid = feature.bid;

    if (this._htmlObjects[bid]) {
      return;
    }

    var marker = new L.Marker(new L.LatLng(feature.lat, feature.lon));
    var htmlObject = document.createElement("div");
    htmlObject.style.position = "absolute";
    htmlObject.style.zIndex = 10000;

    var anchor, size;

    var mini = options.mini || false;
    var isBuildingPin = (feature.venues && feature.venues.length > 0);
    var size;
    if (mini) {
      size = CM.BusinessConfig.miniSize;
    } else if (isBuildingPin) {
      size = CM.BusinessConfig.buildingPinSize;
    } else {
      size = CM.BusinessConfig.placePinSize;
    }

    var metaAlpha = options.metaAlpha || 0;
    htmlObject.style.width = "" + size.x + "px";
    htmlObject.style.height = "" + size.y + "px";

    if (mini) {
      var image = new Image();
      L.DomUtil.addClass(image, '_citymapsengine-pin-mini');
      image.src = CM.Network.getScaledImageURL(CM.Conf.baseUrl + CM.BusinessRendererConfig.miniPinAsset);
      image.width = size.x;
      image.height = size.y;
      htmlObject.appendChild(image);
      anchor = new L.Point(size.x * 0.5, size.y * 0.5);
    } else {
      htmlObject.innerHTML = pinHTML;

      var container = Sizzle("._citymapsengine-pin-container", htmlObject)[0];
      container.style.width = size.x + "px";
      container.style.height = size.y + "px";

      var pin = Sizzle("._citymapsengine-pin-body", htmlObject)[0];
      if (isBuildingPin) {
        L.DomUtil.addClass(pin, 'building');
      }

      pin.style.width = size.x + "px";
      pin.style.height = size.y + "px";
      this._setBackgroundImage(pin, feature, false);

      var image = Sizzle("._citymapsengine-pin-image", htmlObject)[0];

      image.src = feature.imageUrl;

      var meta = Sizzle("._citymapsengine-pin-meta", htmlObject)[0];

      var name = Sizzle("._citymapsengine-pin-meta .name", htmlObject)[0];
      name.innerText = feature.displayName;

      var category = Sizzle("._citymapsengine-pin-meta .category", htmlObject)[0];
      category.innerText = feature.displaySubtitle;

      var rating = Sizzle("._citymapsengine-pin-meta .rating", htmlObject)[0];
      if (!feature.rating_0_5) {
        rating.style.opacity = 0;
      } else {
        rating.src = CM.Network.getScaledImageURL(CM.Conf.baseUrl + "/assets/images/stars_" + feature.rating_0_5 + ".png");
      }
      anchor = new L.Point(size.x * 0.5, size.y);
    }

    var icon = new L.DivIcon({
      html: htmlObject.innerHTML,
      className: 'citymapsengine-business',
      iconAnchor: anchor,
      iconSize: [size.x, size.y]
    });

    marker.setIcon(icon);
    marker.addTo(this._map);

    marker.feature = feature;
    this._htmlObjects[bid] = marker;
    this._applyAttachmentIcon(bid);
    this._applyAttachment(bid);

    if (!mini) {
      this.setMetaAlpha(bid, metaAlpha);
      var pin = Sizzle("._citymapsengine-pin-container ._citymapsengine-pin-body", marker._icon)[0];
      this._htmlOn(pin, 'click dblclick mousedown mouseup mouseenter mouseleave', function(e) {
        this._map.fire("business_" + e.type, feature);
      }.bind(this));
    }
  },

  _htmlOn: function(target, events, func) {
    events = L.Util.splitWords(events);
    for (var i = 0, len = events.length; i < len; i++) {
      target.addEventListener(events[i], func);
    }
  },

  removeObject: function(bid) {
    var marker = this._htmlObjects[bid];
    if (marker) {
      marker.removeFrom(this._map);
      delete this._htmlObjects[bid];
      this._removeAttachmentIcon(bid);
    }
  },

  applyTransition: function(bid, key, completion) {
    var marker = this._htmlObjects[bid];
    if (marker) {
      switch(key) {
        case CM.BusinessRenderer.Transition.MarkerEnter:
        {
          var pin = Sizzle("._citymapsengine-pin-container", marker._icon)[0];
          this._playAnimation(pin, "_citymapsengine-pin-enter", completion);
        }
          break;
        case CM.BusinessRenderer.Transition.MarkerLeave:
        {
          var container = Sizzle("._citymapsengine-pin-container", marker._icon)[0];
          this._playAnimation(container, "_citymapsengine-pin-exit", completion);
        }
          break;
        case CM.BusinessRenderer.Transition.MetaEnter:
        {
          var meta = Sizzle("._citymapsengine-pin-meta", marker._icon)[0];
          if (meta) {
            this._playAnimation(meta, "_citymapsengine-meta-enter", function (completion) {
              meta.style.display = "";
              this.setMetaAlpha(bid, 1);
              if (completion) {
                completion(true);
              }
            }.bind(this, completion));
          }
        }
          break;
        case CM.BusinessRenderer.Transition.MetaLeave:
        {
          var meta = Sizzle("._citymapsengine-pin-meta", marker._icon)[0];
          if (meta) {
            this._playAnimation(meta, "_citymapsengine-meta-exit", function (completion) {
              this.setMetaAlpha(bid, 0);
              meta.style.display = "none";
              if (completion) {
                completion(true);
              }
            }.bind(this, completion));
          }
        }
          break;
      }
    }
  },

  _playAnimation: function(htmlObject, animationClass, completion) {
    if (htmlObject && animationClass) {
      L.DomUtil.addClass(htmlObject, animationClass);
      L.DomEvent.on(htmlObject, 'webkitAnimationEnd oanimationend msAnimationEnd animationend', function(completion) {
        L.DomUtil.removeClass(this, animationClass);
        if (completion) {
          completion(true);
        }
      }.bind(htmlObject, completion));
    } else {
      if (completion) {
        completion(true);
      }
    }
  },

  cancelTransitions: function(bid) {
    var marker = this._htmlObjects[bid];
    if (marker) {
    }
  },

  setMetaAlpha: function(bid, alpha) {
    var marker = this._htmlObjects[bid];
    if (marker) {
      var meta = Sizzle("._citymapsengine-pin-meta", marker._icon)[0];
      if (meta) {
        //setTimeout(function(alpha) {
        meta.style.opacity = alpha;
        if (alpha == 0) {
          meta.style.display = "none";
        } else {
          meta.style.display = "";
        }
        //}.bind(meta, alpha), 10);
      }
    }
  },

  setBlendColor: function(bid, color) {
    var marker = this._htmlObjects[bid];
    if (marker) {
      var pin = Sizzle("._citymapsengine-pin-body", marker._icon)[0];
      if (pin) {
        var hex = CM.StringUtil.rgbToHex(color[0], color[1], color[2]);
        if (hex == "#ffffff") {
          //pin.style.backgroundColor = "";
        } else {
          //pin.style.backgroundColor = hex;
        }
      }
    }
  },

  _hideMarkers: function() {
    for (var k in this._htmlObjects) {
      var object = this._htmlObjects[k];
      object.style.visibility = "invisible";
    }
  },

  _showMarkers: function() {
    for (var k in this._htmlObjects) {
      var object = this._htmlObjects[k];
      object.style.visibility = "visible";
    }
  },

  setAttachmentIcon: function(bid, url) {
    if (url) {
      var img = new Image();
      img.src = url;
      img.onload = function () {
        this._attachmentIcons[bid] = img;
        this._applyAttachmentIcon(bid);
      }.bind(this);
    } else {
      this._removeAttachmentIcon(bid);
      delete this._attachmentIcons[bid];
    }
  },

  _applyAttachmentIcon: function(bid) {
    var icon = this._attachmentIcons[bid];
    var marker = this._htmlObjects[bid];
    // If both marker and icon exist, and icon hasn't been added yet;
    if (marker && icon && !icon.parentNode) {
      marker._icon.appendChild(icon);
      icon.style.position = "absolute";
      icon.style.left = -(icon.height * 0.25) + "px";
      icon.style.top = -(icon.height * 0.25) + "px";
    }
  },

  _removeAttachmentIcon: function(bid) {
    var icon = this._attachmentIcons[bid];
    if (icon && icon.parentNode) {
      icon.parentNode.removeChild(icon);
    }
  },

  addAttachment: function(bid, object, options) {
    options = L.extend({
      anchorPoint: new L.Point(0, 0),
      attachmentAnchorPoint: new L.Point(0.5, 0),
      size: new L.Point(0,0)
    }, options);

    this._htmlAttachments[bid] = {
      object: object,
      options: options
    };

    this._applyAttachment(bid);
  },

  removeAttachment: function(bid) {
    var attachment = this._htmlAttachments[bid];
    if (attachment && attachment.object.parentNode) {
      attachment.object.parentNode.removeChild(attachment.object);
    }

    delete this._htmlAttachments[bid];
  },

  _applyAttachment: function(bid) {
    var marker = this._htmlObjects[bid];
    var attachment = this._htmlAttachments[bid];
    if (marker && attachment) {
      var object = attachment.object;

      var markerSize = CM.BusinessConfig.placePinSize;
      if (!object.parentNode) {
        var offsetX = 0;
        var offsetY = 0;

        var anchorPoint = attachment.options.anchorPoint;
        var attachmentAnchor = attachment.options.attachmentAnchorPoint;
        var size = attachment.options.size;

        // Offset into the pin based on attachment anchor
        offsetX += markerSize.x * attachmentAnchor.x;
        offsetY += markerSize.y * attachmentAnchor.y;

        // Now offset by the object's size & anchor point
        offsetX -= anchorPoint.x * size.x;
        offsetY -= anchorPoint.y * size.y;

        object.style.position = "absolute";
        object.style.left = offsetX + "px";
        object.style.top = offsetY + "px";

        marker._icon.appendChild(object);
      }
    }
  },

  onBusinessStateChanged: function (bid, state) {
    var marker = this._htmlObjects[bid];

    var pin = Sizzle("._citymapsengine-pin-body", marker._icon)[0];

    if (pin) {
      var selected = state.contains('selected');
      var hover = state.contains('hover');

      this._setBackgroundImage(pin, marker.feature, (selected || hover));

      if (hover) {
        pin.style.transform = 'scale(' + CM.BusinessRendererConfig.hoverScaleModifier + ')';
      } else {
        pin.style.transform = '';
      }
      this._map.setNeedsRender(true);
    }
  }
});
var regionPinSize = new L.Point(53, 59);
var regionPinAnchorPoint = new L.Point(0.5, 1.0);

CM.RegionLayer = CM.TileLayer.extend({
  initialize: function (url, options) {
    CM.TileLayer.prototype.initialize.call(this, url, options);

    this._visibleMarkers = {};

    this.on('tileloadstart', this._onTileLoad);
  },

  addTo: function (map) {
    this._fontTexture = map.getFontTexture();
    this._labelRenderer = new CM.ScreenLabelRenderer(map, this._fontTexture);

    this._renderer = new CM.FixedSizeAtlasRenderer(map.device, {
      size: new L.Point(2048, 2048),
      slotSize: new L.Point(128, 64)
    });

    this._containerImage = new CM.Sprite();
    this._containerImage.loadURL("/assets/images/region_base.png", function () {
      this._containerImageReady = true;
    }.bind(this));

    var maskImage = new Image();
    maskImage.src = "/assets/images/region_mask.png";
    maskImage.onload = function () {
      this._alphaMask = new CM.Texture(map.device, maskImage);
      this._maskImageReady = true;
    }.bind(this);

    CM.TileLayer.prototype.addTo.call(this, map);
  },

  _addTile: function (coords, container) {

    var tilePos = this._getTilePos(coords),
      key = this._tileCoordsToKey(coords);

    var tile = {
      markers: [],
      loaded: false,
      key: key
    };

    tile.coords = coords;

    this._tiles[key] = tile;
    this.fire('tileloadstart', {
      tile: tile,
      coords: coords
    });
  },

  _onTileLoad: function (e) {
    var url = this.getTileUrl(e.coords);

    CM.Network.send(url, {
      success: function (response) {
        //delete this._xhr[e.tile.key];

        var data = JSON.parse(response);
        for (var i = 0; i < data.length; i++) {
          data[i].position = L.Projection.SphericalMercator.project(new L.LatLng(data[i].lat, data[i].lon));
          data[i].imageUrl = this.getImageUrl(data[i]);
          data[i].alpha = 1;
        }

        e.tile.markers = data.slice(0);
        e.tile.loaded = true;
      }.bind(this)
    });
  },

  _determineVisibleMarkers: function () {
    var tiles = this._tiles;
    for (var k in tiles) {
      var tile = tiles[k];
      if (!tile.loaded) {
        continue;
      }

      var markers = tile.markers;

      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i];
        marker.screenPosition = this._map.screenProject(marker.position);

        var bounds = this._calculateBounds(marker);
        if (!this._hasCollision(bounds, marker)) {
          marker.bounds = bounds;
          this._showMarker(marker);
        }
      }
    }
  },

  _calculateBounds: function (marker) {
    return new L.Bounds(marker.screenPosition.subtract(regionPinSize), marker.screenPosition.add(regionPinSize));
  },

  _hasCollision: function (bounds, marker) {
    for (var i in this._visibleMarkers) {
      var nMarker = this._visibleMarkers[i];

      if (nMarker.gid != marker.gid && nMarker.bounds.intersects(bounds)) {
        return true;
      }
    }

    return false;
  },

  _showMarker: function (marker) {
    this._visibleMarkers[marker.gid] = marker;

    marker.texture = this._renderer.findTexture(marker.gid, regionPinSize);

    this._labelRenderer.preloadText(marker.name, 14, function () {
      marker.textReady = true;
    });

    //var renderPromise = this._drawMarker(this._map.device, marker);

    /*Promise.all([textPromise, renderPromise]).then(function() {
     marker.ready = true;
     marker.alpha = 0;

     this._map.addAnimation({
     object: marker,
     properties: ['alpha'],
     start: 0,
     end: 1,
     duration: 300
     });
     }.bind(this));*/
  },

  _hideMarker: function (gid) {
    var marker = this._visibleMarkers[gid];

    this._map.addAnimation({
      object: marker,
      properties: ['alpha'],
      start: 0,
      end: 1,
      duration: 300,
      complete: function () {
        delete this._visibleMarkers[gid];
      }.bind(this)
    });
  },

  _drawMarker: function (device, marker) {
    var gl = device.gl;
    
    var clearColor = vec4.fromValues(0, 0, 0, 0);
    var bgColor = this._map.backgroundColor;

    var markerSprite = new CM.Sprite();
    markerSprite.setTechnique("masked");

    markerSprite.loadURL(marker.imageUrl, function () {
      this._renderer.renderTexture(device, marker.texture, clearColor, bgColor, function (device, atlasState) {
        this._containerImage.setPosition(marker.texture.absolutePosition);
        this._containerImage.draw(device, atlasState);

        this._alphaMask.activate(gl.TEXTURE1);
        atlasState.setShaderData('u_alphaMaskTexture', new CM.ShaderData(1, 'texture'));

        markerSprite.setSize(regionPinSize);
        markerSprite.setPosition(marker.texture.absolutePosition);
        markerSprite.setAnchorPoint(new L.Point(0, 0));
        markerSprite.draw(device, atlasState);
      }.bind(this));

      marker.ready = true;
    }.bind(this));
  },

  isReady: function () {
    return this._containerImageReady &&
      this._maskImageReady;
  },

  render: function (deltaMillis, device, state, spriteState) {
    if (!this._mesh) {
      this._mesh = new CM.Mesh(device, "business", {
        vertexBufferUsage: gl.DYNAMIC_DRAW
      });
    }

    this._determineVisibleMarkers();

    if (this.isReady()) {
      var readyMarkers = [];

      for (var i in this._visibleMarkers) {
        var marker = this._visibleMarkers[i];
        if (marker.textReady && !marker.drawn) {
          marker.drawn = true;
          this._drawMarker(device, marker);
        }

        if (marker.ready) {
          readyMarkers.push(marker);
        }
      }

      if (readyMarkers.length > 0) {
        var vertexSize = 9;
        var vertices = new Float32Array(readyMarkers.length * vertexSize * 6);

        var coords = [
          new L.Point(0.0, 0.0),
          new L.Point(1.0, 0.0),
          new L.Point(0.0, 1.0),
          new L.Point(1.0, 0.0),
          new L.Point(0.0, 1.0),
          new L.Point(1.0, 1.0)
        ];

        var idx = 0;
        var anchorPoint = new L.Point(0.5, 1.0);

        // this._labelRenderer.removeAllObjects();

        for (var i = 0; i < readyMarkers.length; i++) {
          var feature = readyMarkers[i];
          feature.screenPosition = this._map.screenProject(feature.position);
          feature.bounds = L.Marker.calculateMarkerBounds(feature.screenPosition, markerSize, anchorPoint);
          feature.size = regionPinSize;

          var textureDimensions = feature.texture;

          for (var j = 0; j < coords.length; j++) {
            var width = feature.size.x;
            var height = feature.size.y;
            vertices[idx] = (feature.screenPosition.x + (width * coords[j].x)) - (regionPinAnchorPoint.x * width);
            vertices[idx + 1] = feature.screenPosition.y + (height * coords[j].y) - (regionPinAnchorPoint.y * height);

            vertices[idx + 2] = textureDimensions.x + (textureDimensions.width * coords[j].x);
            vertices[idx + 3] = textureDimensions.y + (textureDimensions.height * coords[j].y);

            vertices[idx + 4] = 1;
            vertices[idx + 5] = 1;
            vertices[idx + 6] = 1;
            vertices[idx + 7] = 1;

            vertices[idx + 8] = feature.alpha;

            idx += vertexSize;
          }
        }

        this._mesh.setData(vertices, readyMarkers.length * 6);

        spriteState.setShaderData("u_texture", new CM.ShaderData(0, 'texture'));
        this._renderer.getRenderTarget().getColorTexture().activate(gl.TEXTURE0);

        gl.enable(gl.BLEND);
        this._mesh.draw(device, spriteState, gl.TRIANGLES);
        gl.disable(gl.BLEND);
      }

      if (!this.bigSprite) {
        this.bigSprite = new CM.Sprite();
        this.bigSprite._imageTexture = this._renderer.getRenderTarget().getColorTexture();
        this.bigSprite.setPosition(new L.Point(100, 100));
        this.bigSprite.setSize(new L.Point(2048, 2048));
        this.bigSprite.setAnchorPoint(new L.Point(0.0, 0.0));
      }

      this.bigSprite.draw(device, spriteState);
    }


  },

  getImageUrl: function (marker) {
    return "http://res.citymaps.io" + marker.image_url;
  }
});
/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
  continuousScrollWheelZoom: true,
  wheelDebounceTime: 40
});

L.Map.ContinuousScrollWheelZoom = L.Handler.extend({
  addHooks: function () {
    L.DomEvent.on(this._map._container, {
      mousewheel: this._onWheelScroll,
      MozMousePixelScroll: L.DomEvent.preventDefault
    }, this);

    this._delta = 0;
  },

  removeHooks: function () {
    L.DomEvent.off(this._map._container, {
      mousewheel: this._onWheelScroll,
      MozMousePixelScroll: L.DomEvent.preventDefault
    }, this);
  },

  _onWheelScroll: function (e) {
    if (this._timer) {
      clearTimeout(this._timer);
    } else {
      // If no timer, this is a start event
      this._map.fire('scalezoomstart');
      this._mousePos = this._map.mouseEventToContainerPoint(e);
    }

    var delta = L.DomEvent.getWheelDelta(e);

    var scale = 1.0 - (-delta / 100);

    this._map.fire('scalezoom', {scale: scale});

    this._map.scaleBy(scale, this._mousePos);

    this._timer = setTimeout(function () {
      this._timer = null;
      this._map.fire('scalezoomend');
    }.bind(this), 50);
  }
});

L.Map.addInitHook('addHandler', 'continuousScrollWheelZoom', L.Map.ContinuousScrollWheelZoom);

L.Map.mergeOptions({
    continuousTouchZoom: L.Browser.touch && !L.Browser.android23,
    bounceAtZoomLimits: true
});

L.Map.ContinuousTouchZoom = L.Map.TouchZoom.extend({
    _updateOnMove: function () {
        if (!this._lastScale) {
            this._lastScale = this._scale;
            this._map.fire('scalezoomstart');
        }

        // Divide fractional part of the scale factor by 10
        var scaleDelta = 1 + (((this._scale / this._lastScale) - 1) * 0.1);

        this._lastScale = this._scale;

        if (scaleDelta != 1.0) {
            this._map.fire('scalezoom', { scale: scaleDelta});
            this._map.scaleBy(scaleDelta, this._map.getSize().divideBy(2));
        }
    },

    _onTouchEnd: function () {
        this._updateOnMove();

        this._map.fire('scalezoomend');

        this._lastScale = null;
    }
});

L.Map.addInitHook('addHandler', 'continuousTouchZoom', L.Map.ContinuousTouchZoom);

CM.WebGLEngine = L.Class.extend({
  options: {
    continuousScrollWheelZoom: true,
    continuousTouchZoom: true,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    touchZoom: false
  },

  initialize: function (map) {
    this._map = map;

    this._htmlAttachments = [];
  },

  initializeRenderer: function () {
    var map = this._map;

    var devicePixelRatio = CM.Conf.devicePixelRatio;
    this.inverseFactor = 1.0 / this.factor;

    this._canvas = document.createElement("canvas");

    var width = map.getContainer().clientWidth || 1;
    var height = map.getContainer().clientHeight || 1;

    this._canvas.width = width * devicePixelRatio;
    this._canvas.height = height * devicePixelRatio;
    this._canvas.style.width = (width) + "px";
    this._canvas.style.height = (height) + "px";
    this._canvas.style.position = "absolute";

    this._htmlAttachmentPane = L.DomUtil.create('div', 'citymapsWebGLHtmlPane');

    map.getPanes()['citymapsWebGLHtmlPane'] = this._htmlAttachmentPane;

    map.getContainer().insertBefore(this._htmlAttachmentPane, map.getContainer().firstChild);
    map.getContainer().insertBefore(this._canvas, map.getContainer().firstChild);

    this._initRenderer();

    this._numFrames = 0;
    this._frameCounter = 0;

    map.on('move', function (e) {
      this._moving =  true;
      this.setNeedsRender(true);
    }.bind(this));

    map.on('moveend', function () {
      this._moving = false;
    }.bind(this));

    map.on('dblclick', function (e) {
      var endZoom = this._map.getZoom() + 1;
      var point = e.containerPoint;
      this._onZoomAnimation(point, endZoom)
    }.bind(this));

    map.on('zoomanim', function (e) {
      this._onZoomAnimation(e.origin, e.zoom)
    }.bind(this));

    this._animations = {};

    //L.extend(L.Marker.prototype, CM.MarkerWebGLExt);

    L.DomUtil.addClass(map.getContainer(), 'leaflet-webgl');
  },

  createBaseLayer: function (options) {
    options = L.extend({
      reuseTiles: true,
      subdomains: CM.Conf.vectorMapTileSubdomains,
      continuousWorld: true,
      unloadInvisibleTiles: true,
      loadWhileZooming: false,
      minZoom: 1,
      maxZoom: 30,
      LODZooms: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
      oceanEnabled: true,
      numTileLoaders: CM.Conf.tileLoaderWorkerCount || 8
    }, options);
    
    this.vectorLayer = new CM.VectorLayer(CM.Conf.vectorMapTileUrl, options);

    return this.vectorLayer;
  },
  
  createBuildingLayer: function(map) {
    var buildingLayer = new CM.VectorLayer(CM.Conf.buildingTileUrl, {
      reuseTiles: true,
      subdomains: CM.Conf.vectorMapTileSubdomains,
      continuousWorld: true,
      unloadInvisibleTiles: true,
      loadWhileZooming: false,
      minZoom: 15,
      maxZoom: 30,
      LODZooms: [15, 16, 17],
      oceanEnabled: false,
      numTileLoaders: 1
    });
    buildingLayer.addTo(map);
    this.buildingLayer = buildingLayer;
    return buildingLayer;
  },

  attachBusinessRenderer: function (businessLayer) {
    businessLayer._renderer = new CM.BusinessLayerWebGLRenderer(this._map);

    //this.vectorLayer.addLabelConstraint(businessLayer);
  },

  getBackgroundColor: function () {
    return this._backgroundColor
  },

  _initRenderer: function () {
    var map = this._map;

    var ratio = CM.Conf.devicePixelRatio;

    this._device = new CM.GraphicsDevice(this._canvas, this._canvas.width, this._canvas.height, {
      antialias: ratio == 1 // Only antialis 1x displays, 2x+ displays don't need it and this kills performance
    });


    var defaultStyle = CM.Files['style.json'];
    var backgroundColor = defaultStyle.profile['background-color'] || [242,242,242,1];
    this._backgroundColor = vec4.fromValues(backgroundColor[0] / 255.0, backgroundColor[1] / 255.0, backgroundColor[2] / 255.0, 1.0);
    this._device.setBackgroundColor(this._backgroundColor);
    this._device.clear();

    var fov = 45.0;
    var aspect = this._canvas.width / this._canvas.height;

    this._camera = new CM.MapCamera(aspect, fov, 1.0, -1.0);

    this._camera.setMaxResolution(CM.GeoUtils.getResolutionForZoom(map.getMinZoom()));
    this._camera.setMinResolution(CM.GeoUtils.getResolutionForZoom(map.getMaxZoom()));
    this._camera.resize(this._canvas.clientWidth, this._canvas.clientHeight);

    this._spriteMatrix = mat4.ortho(mat4.create(), 0.0, this._canvas.clientWidth, this._canvas.clientHeight, 0.0, -1.0, 1.0);

    this._device.loadEffects("shaders.xml", "effects.xml");

    this._fontTexture = new CM.FontTexture(this._device);

    this._vectorRenderer = new CM.VectorRenderer(map, this._device);

    this.setNeedsRender(true);
  },

  cleanup: function() {
    this._fontTexture.delete();
    this._device.cleanup();
  },

  setNeedsResize: function (needsResize) {
    this._needsResize = needsResize;
  },

  setNeedsRender: function (needsRender) {
    if (!this._needsRender && needsRender) {
      requestAnimationFrame(this._render.bind(this));
    }

    this._needsRender = needsRender;
  },
  _render: function (time) {
    this._needsRender = false;

    if (this.isReady()) {
      var map = this._map;

      var lastFrame = this._lastFrameTime || time;
      var deltaMillis = time - lastFrame;
      this._lastFrameTime = time;

      this._updateAnimations(deltaMillis);

      if (this._needsResize) {
        this._resized();
      }

      var center = map.options.crs.projection.project(map.getCenter());
      var normalizedCenter = map.options.crs.projection.project(map.getWrappedCenter());

      map._resolution = CM.GeoUtils.getResolutionForZoom(map.getZoom());
      if (this._zPosition) {
        map._resolution = this._zPosition / this._camera.baseResolution;
      }
      map._inverseResolution = 1.0 / map._resolution;
      var width = (map._resolution * this._canvas.clientWidth) * 0.5;
      var height = (map._resolution * this._canvas.clientHeight) * 0.5;

      if (width < 1 || height < 1) {
        CM.Console.warn('Map has no size, stop trying to render D:');
        return;
      }

      map.setProjectedBounds(new L.Bounds(
        new L.Point(center.x - width, center.y - height),
        new L.Point(center.x + width, center.y + height)
      ));

      map._normalizedBounds = new L.Bounds(
        new L.Point(normalizedCenter.x - width, normalizedCenter.y - height),
        new L.Point(normalizedCenter.x + width, normalizedCenter.y + height)
      );

      this._camera.reset();
      var zPosition = this._zPosition || 0;
      this._camera.translate(vec3.fromValues(center.x, center.y, zPosition));

      this._camera.zoomToResolution(CM.GeoUtils.getResolutionForZoom(map.getZoom()));

      this._camera.update();

      var viewMatrix = this._camera.viewMatrix;
      var inverseViewMatrix = mat4.create();
      mat4.invert(inverseViewMatrix, viewMatrix);

      var renderState = new CM.RenderState();
      renderState.setShaderData('u_time', new CM.ShaderData(this._lastFrameTime, 'float'));
      renderState.projection = this._camera.projectionMatrix;

      renderState.pushTransform(inverseViewMatrix);

      var projCenter = this._map.getProjectedCenter();
      var mapMatrix = mat4.create();
      mat4.translate(mapMatrix, mapMatrix, vec3.fromValues(projCenter.x, projCenter.y, 0.0));
      renderState.pushTransform(mapMatrix);

      var spriteState = new CM.RenderState();
      spriteState.setShaderData('u_time', new CM.ShaderData(this._lastFrameTime, 'float'));
      spriteState.projection = this._spriteMatrix;


      spriteState.pushTransform(mat4.create());

      if (this._device.isReady()) {

        this._device.preRender();
        this._device.clear();

        this._vectorRenderer.clear();

        var start = new Date().getTime();
        var layers = map._layers;

        for(var renderLayer = 0; renderLayer < L.Layer.RenderLayerCount; ++renderLayer) {
          for (var i in layers) {
            var layer = layers[i];
            if (layer.render && layer.isVisible() && layer._map && layer.getRenderLayer() == renderLayer) {
              layer.render(deltaMillis, this._device, renderState, spriteState);
            }
          }
          if (renderLayer == L.Layer.RenderLayerMap) {
            this._vectorRenderer.render(deltaMillis, this._device, renderState, spriteState);
          }
        }
        var end = new Date().getTime();
      }

      for (var i = 0; i < this._htmlAttachments.length; i++) {
        var a = this._htmlAttachments[i];
        var pixelPosition = map.latLngToContainerPoint(a.latlng);
        L.DomUtil.setPosition(a.obj, pixelPosition);
      }

      this._frameCounter += deltaMillis;
      if (this._frameCounter > 1000) {
        this._frameCounter -= 1000;

        var fps = document.getElementById("fps");
        if (fps) {
          fps.innerHTML = this._numFrames + "";
        }
        this._numFrames = 1;
      } else {
        this._numFrames += 1;
      }

      //this.labels.render(this._device, spriteState);

      /*if (!this.fontSprite) {
       this.fontSprite = new CM.Sprite();
       this.fontSprite._imageTexture = this.font._atlasTexture;
       this.fontSprite.setPosition(new L.Point(0, 0));
       this.fontSprite.setSize(new L.Point(2048, 2048));
       this.fontSprite.setAnchorPoint(new L.Point(0.0, 0.0));
       }

       this.fontSprite.draw(this._device, spriteState);*/

      if (this._moving || map._animatingZoom) {
        this.setNeedsRender(true);
      }

      if (!this._needsRender) {
        var fps = document.getElementById("fps");
        if (fps) {
          fps.innerHTML = "stopped";
        }
        this._frameCounter = 1000;
      }
    }
  },

  _updateAnimation :function(key, anim, deltaMillis) {
    anim.elapsed += deltaMillis;

    var elapsed = anim.delay == undefined ? anim.elapsed : anim.elapsed - anim.delay;

    if (elapsed < 0) {
      return;
    }

    var linearT = Math.min(elapsed / anim.duration, 1.0);
    var easedT;
    if (anim.easing) {
      easedT = anim.easing(linearT);
    } else {
      easedT = linearT;
    }

    var value = anim.start + (anim.end - anim.start) * easedT;

    if (anim.properties) {
      for (var j = 0; j < anim.properties.length; j++) {

        if (anim.callback) {
          anim.callback(anim, easedT, anim.properties[j]);
        } else {
          anim.object[anim.properties[j]] = value;
        }
      }
    } else {
      if (anim.callback) {
        anim.callback(anim, easedT, linearT);
      }
    }

    if (linearT >= 1.0) {
      if (anim.complete) {
        anim.complete(anim);
      }
      delete this._animations[key];
    }
  },

  _updateAnimations: function (deltaMillis) {

    var animations = this._animations;
    for (var k in animations) {
      this._updateAnimation(k, animations[k], deltaMillis);
    }

    if (Object.keys(animations).length > 0) {
      this.setNeedsRender(true);
    }
  },

  _resized: function () {
    this._needsResize = false;
    var map = this._map;

    var newSize = map.getSize();

    var dpr = CM.Conf.devicePixelRatio;

    var width = newSize.x || 1;
    var height = newSize.y || 1;

    this._canvas.width = width * dpr;
    this._canvas.height = height * dpr;
    this._canvas.style.width = width + "px";
    this._canvas.style.height = height + "px";

    this._device.resize(this._canvas.width, this._canvas.height);

    var fov = 45.0;
    var aspect = this._canvas.width / this._canvas.height;

    this._camera = new CM.MapCamera(aspect, fov, 1.0, -1.0);

    this._camera.setMaxResolution(CM.GeoUtils.getResolutionForZoom(map.getMinZoom()));
    this._camera.setMinResolution(CM.GeoUtils.getResolutionForZoom(map.getMaxZoom()));
    this._camera.resize(this._canvas.clientWidth, this._canvas.clientHeight);

    this._spriteMatrix = mat4.ortho(mat4.create(), 0.0, this._canvas.clientWidth, this._canvas.clientHeight, 0.0, -1.0, 1.0);

    this.setNeedsRender(true);
  },

  /*addLayer: function (layer) {
   if (layer instanceof CM.TileLayer) {
   this.glLayers.push(layer);
   }

   if (layer instanceof L.Marker) {
   this._marekrs
   }

   return L.Map.prototype.addLayer.apply(this, layer);
   },*/

  getRenderer: function () {
    return this._renderer;
  },

  isReady: function () {
    return (this._device && this._device.isReady() && this._map._loaded);
  },

  scaleBy: function (scale, mousePos) {
    var map = this._map;

    var zoom = map._limitZoom(map.getZoom() * scale);
    map.setZoomAround(mousePos, zoom, {animate: false});
  },

  getZoom: function () {
    return Math.floor(L.Map.prototype.getZoom.call(this));
  },

  applyStyle: function (data) {

    var backgroundColor = data.profile['background-color'] || [242,242,242,1];
    this._backgroundColor = vec4.fromValues(backgroundColor[0] / 255.0, backgroundColor[1] / 255.0, backgroundColor[2] / 255.0, 1.0);
    this._device.setBackgroundColor(this._backgroundColor);

    if (this.vectorLayer) {
      this.vectorLayer.applyStyle(data);
    }

    if (this.buildingLayer) {
      this.buildingLayer.applyStyle(data);
    }
  },

  getFontTexture: function () {
    return this._fontTexture;
  },

  _resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {
    L.Map.prototype._resetView.apply(this, arguments);
  },

  addAnimation: function (key, animation) {
    animation.elapsed = 0;
    this._animations[key] = animation;
    this.setNeedsRender(true);
  },

  cancelAnimation: function (key) {
    var anim = this._animations[key];
    if (anim) {
      if (anim.cancelled) {
        anim.cancelled();
      }
      delete this._animations[key];
    }
    this.setNeedsRender(true);
  },

  cancelAnimationsForObject: function (object) {

    var deleted = {};
    for (var k in this._animations) {
      var anim = this._animations[k];
      if (anim.object == object) {
        deleted[k] = k;
      }
    }

    for (var k in deleted) {
      delete this._animations[k];
    }
  },

  _onZoomAnimation: function (point, endZoom) {

    var map = this._map;
    var startZoom = map.getZoom();

    map.stop();
    map._zooming = true;

    this.addAnimation('dblclickzoom', {
      object: map,
      start: startZoom,
      end: endZoom,
      duration: 200,
      easing: CM.EasingFunctions['ease-in-out'],
      callback: function (anim, t) {
        var zoom = startZoom + (endZoom - startZoom) * t;
        map.setZoomAround(point, zoom, {animate: false});
        map.setNeedsRender();
      },
      complete: function() {
        map._zooming = false;
      }
    });
  },

  addHTMLAttachment: function (object, latlng) {
    this._htmlAttachments.push({
      obj: object,
      latlng: latlng
    });
  },

  handleMouseEvent: function (e) {
    var map = this._map;

    var eventOnMap = e.target === this._canvas;

    if (eventOnMap) {
      this._acceptingDomEvents = true;
      var keys = Object.keys(map._layers).reverse();
      for (var i = 0; i < keys.length; i++) {
        var layer = map._layers[keys[i]];
        if (layer.handleMouseEvent && layer.handleMouseEvent(e)) {
          return true;
        }
      }
    } else if (this._acceptingDomEvents) {
      this._acceptingDomEvents = false;
      var keys = Object.keys(map._layers).reverse();
      for (var i = 0; i < keys.length; i++) {
        var layer = map._layers[keys[i]];
        if (layer.cancelMouseEvent) {
          layer.cancelMouseEvent();
        }
      }
    }

    return false;
  },

  getSnapshot: function () {
    return new Promise(function (resolver) {
      var pixels = new Uint8Array(this._canvas.width * this._canvas.height * 4);
      var gl = this._device.gl;
      gl.readPixels(0, 0, this._canvas.width, this._canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

      // Flip pixels because OpenGL puts 0,0 at bottom left
      var clamedPixels = new Uint8ClampedArray(pixels.length);
      for (var y = 0; y < this._canvas.height; y++) {
        for (var x = 0; x < this._canvas.width; x++) {
          var index = (y * this._canvas.width) + x;
          var indexNew = ((this._canvas.height - y - 1) * this._canvas.width) + x;

          clamedPixels[indexNew * 4] = pixels[index * 4];
          clamedPixels[indexNew * 4 + 1] = pixels[index * 4 + 1];
          clamedPixels[indexNew * 4 + 2] = pixels[index * 4 + 2];
          clamedPixels[indexNew * 4 + 3] = pixels[index * 4 + 3];
        }
      }

      var imageData = new ImageData(clamedPixels, this._canvas.width, this._canvas.height);

      var canvas = document.createElement("canvas");
      canvas.width = this._canvas.width;
      canvas.height = this._canvas.height;

      var context = canvas.getContext("2d");
      context.putImageData(imageData, 0, 0);

      resolver(canvas)
    }.bind(this));
  },

  setView: function(center, zoom, options) {
    if (options.animate) {
      var map = this._map;
      var proj = map.options.crs.projection;
      var self = this;

      var fromPosition = proj.project(map.getCenter());
      var toPosition = proj.project(center);

      var distance = fromPosition.distanceTo(toPosition);
      var minPixels = window.innerWidth * 0.75;
      var peakRes = distance / minPixels;

      var fromRes = CM.GeoUtils.getResolutionForZoom(map.getZoom());
      var fromZ = this._camera.getZPosition(fromRes);
      var toRes = CM.GeoUtils.getResolutionForZoom(zoom);
      var toZ = this._camera.getZPosition(toRes);

      var points = new Array(3);
      points[0] = vec3.fromValues(fromPosition.x, fromPosition.y, fromZ);
      points[1] = vec3.create();
      points[2] = vec3.fromValues(toPosition.x, toPosition.y, toZ);

      if (fromZ > toZ) {
        points[1][0] = (points[0][0] + points[2][0] + points[2][0]) / 3.0;
        points[1][1] = (points[0][1] + points[2][1] + points[2][1]) / 3.0;
      } else {
        points[1][0] = (points[2][0] + points[0][0] + points[0][0]) / 3.0;
        points[1][1] = (points[2][1] + points[0][1] + points[0][1]) / 3.0;
      }

      if (peakRes > fromRes) {
        points[1][2] = this._camera.getZPosition(peakRes);
      } else {
        points[1][2] = (fromZ + toZ) / 2.0;
      }

      map.fire('scalezoomstart');
      this._moving = true;

      this.addAnimation('panzoomanim', {
        object: map,
        start: 0,
        end: 1,
        duration: options.duration || 300,
        easing: CM.EasingFunctions['ease-in-out-quad'],
        callback: function (anim, t, linearT) {
          var t2 = t * t;
          var oneMinusT = 1.0 - t;
          var oneMinusT2 = oneMinusT * oneMinusT;

          var p0step = vec3.scale(vec3.create(), points[0], oneMinusT2);
          var p1step = vec3.scale(vec3.create(), points[1], t * oneMinusT * 2);
          var p2step = vec3.scale(vec3.create(), points[2], t2);

          var position = vec3.add(vec3.create(), vec3.add(vec3.create(), p0step, p1step), p2step);
          var zoom = CM.GeoUtils.getZoomForResolution(position[2] / self._camera.baseResolution);
          map.setView(proj.unproject(new L.Point(position[0], position[1])), zoom, {animate: false});
        },
        complete: function() {
          map.setView(center, zoom);
          map.fire('scalezoomend');
          map.fire('moveend');
          self._moving = false;
        }
      });
    }
  }
});

CM.RasterEngine = L.Class.extend({
  options: {
    continuousScrollWheelZoom: false,
    touchZoom: 'center'
  },

  initialize: function (map) {
    this._map = map;
  },

  initializeRenderer: function () {
    var map = this._map;

    map.on('move', function () {
      var projCenter = map.options.crs.projection.project(map.getCenter());

      map._resolution = CM.GeoUtils.getResolutionForZoom(map._zoom);
      map._inverseResolution = 1.0 / map._resolution;
      var width = (map._resolution * map.getContainer().clientWidth) * 0.5;
      var height = (map._resolution * map.getContainer().clientHeight) * 0.5;
      map.setProjectedBounds(new L.Bounds(
        new L.Point(projCenter.x - width, projCenter.y - height),
        new L.Point(projCenter.x + width, projCenter.y + height)
      ));

      var worldSize = (20037508.34 * 2);
      var normalizedX = projCenter.x % worldSize;

      map._normalizedBounds = new L.Bounds(
        new L.Point(normalizedX - width, projCenter.y - height),
        new L.Point(normalizedX + width, projCenter.y + height)
      );
    }.bind(this));

    // Kind of a hack, but since the map may already have a position set,
    // we have to fire a move to make sure things are initialized
    //map.fire('move');
  },

  setNeedsResize: function () {

  },

  setNeedsRender: function (needsRender) {
    this._needsRender = needsRender;
  },

  createBaseLayer: function (options) {
    options = L.extend({
      minZoom: 1,
      maxZoom: 30
    }, options);

    var dpr = Math.ceil(CM.Conf.devicePixelRatio || 1);

    var BASE_URL = 'https://api.mapbox.com/styles/v1/citymaps/cis0i4wic004cg9kuhct4b6sw/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiY2l0eW1hcHMiLCJhIjoicExCcXlTNCJ9.Q-ioNE02NVz-jX4QtHYtxw';
    var RETINA_URL = 'https://api.mapbox.com/styles/v1/citymaps/cis0i4wic004cg9kuhct4b6sw/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiY2l0eW1hcHMiLCJhIjoicExCcXlTNCJ9.Q-ioNE02NVz-jX4QtHYtxw';
    var rasterUrl = dpr > 1 ? RETINA_URL : BASE_URL;
    return new L.TileLayer(rasterUrl, options);
  },

  createBuildingLayer: function(map) {
    // Nothing to do, this is baked in
    return null;
  },

  attachBusinessRenderer: function (businessLayer) {
    businessLayer._renderer = new CM.BusinessLayerHTMLRenderer(this._map);
  },

  handleMouseEvent: function (e) {
    return false;
  },

  getSnapshot: function () {
    return new Promise(function (resolver) {
      var canvas = document.createElement("canvas");
      resolver(canvas);
    });
  }
});

L.Map.ScrollWheelZoom.prototype._oldPerformZoom = L.Map.ScrollWheelZoom.prototype._performZoom;
L.Map.ScrollWheelZoom.prototype._performZoom = function() {
  var delta = this._delta;
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);

  var abs = Math.abs(delta);
  delta = Math.log(abs + 1) * (delta / abs);
  delta = Math.max(Math.min(delta, 4), -4);
  this._delta = delta;
  L.Map.ScrollWheelZoom.prototype._oldPerformZoom.call(this);
};

CM.Map = L.Map.extend({

  glLayers: [],

  initialize: function(id, options) {
    options = options || {};

    var engine = this._initializeEngine(options.forceRaster);

    options = L.extend(options, this._engine.options);
    options.maxZoom = engine.maxZoom || 20;//options.maxZoom;
    options.minZoom = engine.minZoom || options.minZoom;
    options.bounceAtZoomLimits = false;

    L.Map.prototype.initialize.call(this, id, options);

    var startupDeps = [];
    if (options.apiKey) {
      startupDeps.push(this._validateApiKey(options.apiKey));
    } else {
      throw "API Key is missing";
    }

    if (options.signedUrls) {
      this._loadUrlSigningKeys();
    }

    this._engine.initializeRenderer();

    this._moving = false;
    this._zooming = false;

    this.on('movestart', function(e){
      this._moving = true;
    }.bind(this));

    this.on('move', function(e){
      var center = this.getCenter();
      var wrapped = center.wrap();
      if (!center.equals(wrapped)) {
        //this._resetView(wrapped, this.getZoom(), true, false);
      }
    }.bind(this));

    this.on('moveend', function(e){
      this._moving = false;
    }.bind(this));

    this.on('scalezoomstart', function(e){
      this._zooming = true;
    }.bind(this));

    this.on('scalezoomend', function(e){
      this._zooming = false;
    }.bind(this));

    this.on('resize', this.onResize.bind(this));

    this.onResize();

    var baseLayer = this._engine.createBaseLayer(this.options.baseLayerOptions || {});
    this.baseLayer = baseLayer;

    this.businessLayer = new CM.BusinessLayer(this._defaultVenueUrl(), {
      continuousWorld: true,
      minZoom: 10,
      maxZoom: 30,
      LODZooms: [11, 13, 15, 17],
      noWorkers: options.noWorkers || false,
      loadWhileZooming: false
    });

    this._engine.attachBusinessRenderer(this.businessLayer);
    this._animations = {};

    baseLayer.addTo(this);
    var buildingLayer;
    if (this.options.buildingsEnabled) {
      buildingLayer = this._engine.createBuildingLayer(this);
      if (buildingLayer) {
        buildingLayer.setTileLayerReady(false);
      }
      this.buildingLayer = buildingLayer;
    }
    this.businessLayer.addTo(this);

    if (baseLayer.setTileLayerReady) {
      baseLayer.setTileLayerReady(false);
    }
    this.businessLayer.setTileLayerReady(false);

    Promise.all(startupDeps).then(function() {
      if (options.signedUrls) {

        // robot - 24 hour, not - 30 min
        var timeout = options.robot ? 86400 : 1800;
        if (baseLayer.addPathTransformer) {
          baseLayer.addPathTransformer(new CM.CloudfrontPathTransformer({
            publicKey: this._signingKeys.publicKey,
            privateKey: this._signingKeys.privateKey,
            accessKey: CM.Conf.cloudfrontAccessKey,
            url: "*tile.citymaps.com/map/*",
            timeout: timeout
          }));
        }

        if (buildingLayer) {
          buildingLayer.addPathTransformer(new CM.CloudfrontPathTransformer({
            publicKey: this._signingKeys.publicKey,
            privateKey: this._signingKeys.privateKey,
            accessKey: CM.Conf.cloudfrontAccessKey,
            url: "*tile.citymaps.com/building/*",
            timeout: timeout
          }));
          buildingLayer.setTileLayerReady(true);
        }

        this.businessLayer.addPathTransformer(new CM.CloudfrontPathTransformer({
          publicKey: this._signingKeys.publicKey,
          privateKey: this._signingKeys.privateKey,
          accessKey: CM.Conf.cloudfrontAccessKey,
          url: "*//tile.citymaps.com/venue/*",
          urlRegex: "^.*tile.citymaps.com/venue/.*$",
          timeout: timeout
        }));
      }
      if (baseLayer.setTileLayerReady) {
        baseLayer.setTileLayerReady(true);
      }
      this.businessLayer.setTileLayerReady(true);

      this.setNeedsRender(true);
      this.latLngBounds = new L.LatLngBounds(new L.LatLng(0,0), new L.LatLng(0,0));
    }.bind(this));
  },

  _defaultVenueUrl: function() {
    return this.options.venue_url || CM.Conf.venueMapTileUrl;
  },

  resetBusinessLayer: function() {
    this.resetBusinessLayerUrl();
    this.resetBusinessLayerLODZooms();
    this.resetBusinessLayerMinZoom();
    this.businessLayer.setBusinessAlgorithm(CM.BusinessLayer.AlgorithmMainMap);
    this.businessLayer.clearRenderBlacklist();
  },

  resetBusinessLayerUrl: function() {
    this.businessLayer.setUrl(CM.Conf.protocol + this._defaultVenueUrl());
  },

  resetBusinessLayerLODZooms: function() {
    this.businessLayer.setLODZooms([9, 11, 13, 15, 17]);
  },

  resetBusinessLayerMinZoom: function() {
    this.businessLayer.options.minZoom = 9;
  },

  onResize: function() {
    this.setNeedsResize(true);
    var newSize = this.getSize();
    if (newSize.x < 1 || newSize.y < 1) {
      this.setMinZoom(2);
    } else {
      var resolutionAtMinZoom = CM.GeoUtils.MERCATOR_WORLD_WIDTH / Math.max(newSize.x, newSize.y);
      var minZoom = CM.GeoUtils.getZoomForResolution(resolutionAtMinZoom) + 0.2;
      this.setMinZoom(Math.max(2, minZoom));
    }
  },

  isMoving: function() {
    return this._moving;
  },

  isZooming: function() {
    return this._zooming;
  },

  addAnimation: function(key, animation) {
    this._engine.addAnimation(key, animation);
  },

  cancelAnimation: function(key) {
    this._engine.cancelAnimation(key);
  },

  cancelAnimationsForObject: function(object) {
    this._engine.cancelAnimationsForObject(object);
  },

  getEngine: function() {
    return this._engine;
  },

  _initializeEngine: function(forceRaster) {
    if (!CM.Util.supportsWebGL(forceRaster)) {
      this._engine = new CM.RasterEngine(this);
      return this._engine;
    }

    this._engine = new CM.WebGLEngine(this);

    return this._engine;
  },

  getProjectedBounds: function() {
    return this._projectedBounds;
  },

  setProjectedBounds: function(bounds) {
    this._projectedBounds = bounds;
    this._projectedCenter = bounds.getCenter();
    this.latLngBounds = new L.LatLngBounds(L.Projection.SphericalMercator.unproject(bounds.min), L.Projection.SphericalMercator.unproject(bounds.max));
  },

  getProjectedCenter: function() {
    return this._projectedCenter;
  },

  getBounds: function() {
    return this.latLngBounds;
  },

  getBaseLayer: function() {
    return this.baseLayer;
  },

  screenProject: function(point) {

    var worldWidth = CM.GeoUtils.MERCATOR_WORLD_WIDTH;
    var halfWorldWidth = worldWidth * 0.5;
    var center = this._projectedCenter;
    // If we are way far right of the point
    // if (point.x > halfWorldWidth)
    // {
    //   point = new L.Point(point.x - worldWidth, point.y);
    // }
    // // If we are way far left of the point
    // else if (point.x < -halfWorldWidth)
    // {
    //   point = new L.Point(point.x + worldWidth, point.y);
    // }

    //point = new L.Point(point.x % (worldWidth * 2), point.y);

    if (point.x > -halfWorldWidth && point.x < halfWorldWidth) {
      var x = (point.x - this._normalizedBounds.min.x) * this._inverseResolution;
      var y = (this._normalizedBounds.max.y - point.y) * this._inverseResolution;

      return new L.Point(x, y);
    } else {
      var x = (point.x - this._projectedBounds.min.x) * this._inverseResolution;
      var y = (this._projectedBounds.max.y - point.y) * this._inverseResolution;

      return new L.Point(x, y);
    }
  },

  scaleBy: function(scale, mousePos) {

    var zoom = this.getZoom();
    if (zoom) {
      zoom = this._limitZoom(this.getZoom() * scale);
      var scale = this.getZoomScale(zoom),
        viewHalf = L.Projection.SphericalMercator.project(this.getCenter()),//this.getSize().divideBy(2),
        containerPoint = L.Projection.SphericalMercator.project(this.containerPointToLatLng(mousePos)),
        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
        newCenter = L.Projection.SphericalMercator.unproject(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {zoom: {animate: false}});
    }
  },

  setNeedsResize: function(needsResize) {
    needsResize = needsResize || true;

    this._engine.setNeedsResize(needsResize);
    this.setNeedsRender(needsResize);
  },

  setNeedsRender: function(needsRender) {
    needsRender = needsRender || true;
    this._engine.setNeedsRender(needsRender);
  },

  applyBusinessFilter: function(data) {
    this.businessLayer.applyFilter(data);
  },

  removeBusinessFilter: function() {
    this.businessLayer.removeFilter();
  },

  applyStyle: function(style) {
    this._engine.applyStyle(style);

    this.setNeedsRender(true);
  },

  _handleDOMEvent: function (e) {
    this.setNeedsRender(true);
    // Check canvas for webgl engine.

    if (e.type.indexOf("mouse") >= 0 || e.type.indexOf("click") >= 0) {
      if (this._engine.handleMouseEvent(e)) {
        return;
      }
    }
    L.Map.prototype._handleDOMEvent.call(this, e);
  },

  addHTMLAttachment: function(object, latlng) {
    this.getContainer().appendChild(object);

    this._engine.addHTMLAttachment(object, latlng);
  },

  getCenter: function() {
    return L.Map.prototype.getCenter.call(this);
  },

  getWrappedCenter: function() {
    return this.wrapLatLng(this.getCenter(this));
  },

  _animateZoom: function (center, zoom, startAnim, noUpdate) {
    if (this._engine._onZoomAnimation) {
      this._engine._onZoomAnimation(center, zoom);
    } else {
      L.Map.prototype._animateZoom.call(this, center, zoom, startAnim, noUpdate);
      setTimeout(function() {
        if (this._animatingZoom) {
          this._onZoomTransitionEnd();
        }
      }.bind(this), 250);
    }
  },

  _validateApiKey: function(key) {
    return new Promise(function(resolver) {
      //var fullKey = key + window.location.hostname + CM.CITYMAPS_SECRET;
      var fullKey = key + "com.citymaps.mobile" + CM.CITYMAPS_SECRET;
      var hashedKey = CM.StringUtil.SHA1Hash(fullKey);

      var url = CM.Conf.apiKeyValidateUrl + key + "?hash=" + hashedKey;

      CM.Network.send(url, {
        success: function(data) {
          var json = JSON.parse(data);
          if (json.valid) {
            resolver();
          } else {
            throw "API Key failed to validate.  Please check your API key and try again.";
          }
        },

        error: function() {
          CM.Console.log("API Key server not working");
          resolver();
        }
      })
    });
  },

  _loadUrlSigningKeys: function() {
    this._signingKeys = {};

    this._signingKeys.publicKey = CM.Keys["rsa-" + CM.Conf.cloudfrontAccessKey + ".cer"];
    this._signingKeys.privateKey = CM.Keys["pk-" + CM.Conf.cloudfrontAccessKey + ".cer"];
  },

  getSnapshot: function() {
    return new Promise(function(resolver, reject) {
      var size = this.getSize();
      if (size.width < 1 || size.height < 1) {
        reject();
        return;
      }
      this._engine.getSnapshot().then(function(canvas) {
        resolver(canvas)
      }.bind(this))
    }.bind(this))
  },

  setView: function(center, zoom, options) {
    if (this._engine.setView && options && options.animate) {
      this._engine.setView.apply(this._engine, arguments);
      return this;
    } else {
      var letLeafletAnimate = !this._engine.setView || (options && options.animate);
      return L.Map.prototype.setView.call(this, center, zoom, {reset:!letLeafletAnimate});
    }
  }
});

CM.CITYMAPS_SECRET = "4e1546ddc0de4e9db622dac75da14ac0";

CM.map = function (id, options) {
  options = options || {};

  var map = new CM.Map(id, L.extend({
    minZoom: 2,
    maxZoom: 20,
    inertiaDeceleration: 7500,
    inertiaMaxSpeed: 4000,
    apiKey: "e13dff88738346c9a821957ac621b30f",
    signedUrls: true,
    buildingsEnabled: true,
    baseLayerOptions: {
      elevationEnabled: true,
      elevationUrl: CM.Conf.elevation.defaultTileURL,
      oneWayTileMinZoom: 13,
      oneWayVisibleMinZoom: 16
    }
  }, options));

  //map.vectorLayer.addLabelConstraint(map.businessLayer);

  /*map.regionLayer = new CM.RegionLayer("//tilecache.citymaps.com/venue/{z}/{x}/{z}_{x}_{y}.json.gz", {
   continuousWorld: true,
   minZoom: 1,
   maxZoom: 11,
   LODZooms: [3, 5, 7, 9]
   });
   map.regionLayer.addTo(map);*/



  return map;
};
/**
 * Created by edwardkimmel on 7/23/15.
 */

var CM = CM || {};
CM.Support = CM.Support || {};

CM.Support.State = L.Class.extend({

  initialize: function (initialStates) {
    if (typeof initialStates === 'string') {
      initialStates = L.Util.splitWords(initialStates);
    }
    this._states = {};
    this._stateCount = 0;

    if (initialStates) {
      for (var i = 0; i < initialStates.length; ++i) {
        this.addState(initialStates[i]);
      }
    }
  },

  addState: function (state) {
    if (!this.contains(state)) {
      this._states[state] = true;
      this._stateCount++;
    }
  },

  removeState: function (state) {
    if (this.contains(state)) {
      delete this._states[state];
      this._stateCount--;
    }
  },

  contains: function (state) {
    return this._states[state];
  },

  containsAll: function (states) {
    if (typeof states === 'string') {
      var keys = L.Util.splitWords(states);
      states = {};
      for (var k in keys) {
        states[k] = true;
      }
    } else if (states instanceof CM.Support.State) {
      states = states._states;
    }
    for (var k in states) {
      if (!this.contains(k)) {
        return false;
      }
    }
    return true;
  },

  allContained: function (states) {

  },

  stateLength: function () {
    return this._stateCount;
  }
});

CM.Support.Selector = L.Class.extend({
  initialize: function (requiredState, properties) {
    if (requiredState instanceof CM.Support.State) {
      this._state = requiredState;
    } else {
      this._state = new CM.Support.State(requiredState);
    }
    L.extend(this, properties);
  },

  stateLength: function () {
    return this._state.stateLength();
  },

  stateMeetsRequirements: function (state) {
    if (!state instanceof CM.Support.State) {
      state = new CM.Support.State(state);
    }
    return state.containsAll(this._state);
  }
});

CM.Support.SelectorList = L.Class.extend({
  initialize: function () {
    this._selectors = [];
  },

  addSelector: function (selector) {
    this.insert(selector, this._selectors);
  },

  removeSelector: function (selector) {
    this._selectors = this._selectors.filter(function (e) {
      return e != selector;
    });
  },

  findSelectorForState: function (state) {
    for (var i = 0; i < this._selectors.length; ++i) {
      var selector = this._selectors[i];
      if (selector.stateMeetsRequirements(state)) {
        return selector;
      }
    }
    return null;
  },

  compareSelectors: function (a, b) {
    return b.stateLength() - a.stateLength();
  },

  insert: function (element, array) {
    array.splice(this.locationOf(element, array, this.compareSelectors), 0, element);
    return array;
  },

  locationOf: function (element, array, compareFunc, start, end) {
    start = start || 0;
    end = end || array.length;
    var pivot = parseInt(start + (end - start) / 2, 10);

    var compare;
    if (end - start <= 1 || (compare = compareFunc(array[pivot], element)) == 0) return pivot;
    if (compare < 0) {
      return this.locationOf(element, array, compareFunc, pivot, end);
    } else {
      return this.locationOf(element, array, compareFunc, start, pivot);
    }
  }
});
/**
 * Created by edwardkimmel on 7/23/15.
 */

var CM = CM || {};
CM.Support = CM.Support || {};

/*
 Options
 - loadWhileMoving - determine whether tiles should be loaded while the map is in motion.

 Usage
 - Listen to the following events
 -tileloadsuccess - called when a tile has been retrieved.
 -tileloadfailure - called when a tile has failed to load
 -tileloadfinished - called when all tiles have been loaded.
 -tileunload - called when a tile has been removed.
 */

CM.Support.JsonDataTileLayer = CM.TileLayer.extend({
  initialize: function (url, options) {
    CM.TileLayer.prototype.initialize.call(this, url, options);
    this.setRenderLayer(L.Layer.RenderLayerUnrenderable);
    
    this._waitingForMovementToEnd = false;

    this.on('tiledataloaded', this._onTileDataLoaded.bind(this));
    this.on('tiledatafailed', this._onTileDataFailed.bind(this));
  },

  addTo: function (map) {
    CM.TileLayer.prototype.addTo.call(this, map);
  },

  _update: function (center, zoom) {
    var map = this._map;

    if (!map) {
      return;
    }
    CM.TileLayer.prototype._update.call(this, center, zoom);
  },

  getTiles: function () {
    return L.extend({}, this._tiles);
  },

  areTilesLoaded: function () {
    if (this._waitingForMovementToEnd) {
      return false;
    }

    var tiles = this._tiles;
    for (var k in tiles) {
      if (!tiles[k].loaded) {
        return false;
      }
    }
    return true;
  },

  _onTileDataLoaded: function (e) {
    var tile = e.tile;
    var response = e.response;

    if (this._tiles[tile.key]) {
      tile.json = JSON.parse(response);
      tile.loaded = true;

      this.fire('tileloadsuccess', {
        tile: tile
      });

      this._checkForTilesComplete();
    }
  },

  _onTileDataFailed: function (e) {
    var tile = e.tile;
    tile.loaded = true;

    this.fire('tileloadfailure', {
      tile: tile
    });

    this._checkForTilesComplete();

  },

  _checkForTilesComplete: function () {
    if (this.areTilesLoaded()) {
      this.fire('tileloadfinished', {
        tiles: this._tiles
      });
    }
  }
});
//# sourceMappingURL=citymaps-src.js.map